<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【读书笔记】C++性能优化指南</title>
    <link href="/2021/01/12/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91C++%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/"/>
    <url>/2021/01/12/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91C++%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="C-性能优化指南"><a href="#C-性能优化指南" class="headerlink" title="C++性能优化指南"></a>C++性能优化指南</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>Experimentation, rather than intuition, is a theme of this book</p></blockquote><p>优化的时候有些技巧是与人的直觉相违背的。</p><blockquote><p>It takes the same amount of time to write efficient code as slow, wasteful code.</p></blockquote><p>作者的观点是养成写优化的代码的习惯，即使不知道那段代码是否为性能瓶颈。但是在不确定是否能优化的时候，就不要尝试牺牲效率、时间、代码可读性、代码出错率去做不确定的工作。</p><p><strong>Reduce Memory Allocation and Copying</strong></p><p>进行内存操作的时间可能是CPU计算的上千倍。</p><p><strong>Remove Computation</strong></p><p>关注热点代码：重复执行的部分</p><blockquote><p>Developers should therefore attempt not to go all OCD on a big code base changing every occurrence of i++ to ++i.</p></blockquote><p>不要代替编译器去做优化</p><p><strong>Use Better Data Structures</strong></p><p>略</p><p><strong>Increase Concurrency</strong></p><p>多线程方面的优化</p><p><strong>Optimize Memory Management</strong></p><p>改变原有的内存管理机制</p><h2 id="内存速度"><a href="#内存速度" class="headerlink" title="内存速度"></a>内存速度</h2><p>指令和数据都存储在内存中，内存被划分为字（words），一小部分内存有直接对应的地址，称为registers, 其余内存地址都由地址寄存器来映射。</p><blockquote><p>Main memory is so slow that a desktop processor can execute hundreds of instructions in the length of time it takes to fetch a single data word from main memory.</p></blockquote><p>内存读取比执行指令慢了几百倍，部分因为内存距CPU太远，存取有延时。</p><blockquote><p>Access to a nonsequential location completes in somewhere between 6 and 10 cycles</p></blockquote><p>随机读取需要6-10个周期完成，顺序读取可以只要一个周期。</p><img src="/2021/01/12/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91C++%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/2020-11-18-17-21-07.png" srcset="/img/loading.gif" class=""><p>随机读取时间可以粗略估计成50ns，如果以GHz量级衡量CPU运行频率，那么一次内存存取需要50个CPU周期来完成。</p><p>但只要读取的数据在原数据的cache line里，就可以只附加十分之一的时间读取到数据，所以顺序读取的速度为随机读取的十分之一左右。</p><p><strong>缓存cache</strong></p><p>（见 <a href="https://blog.csdn.net/qq_21125183/article/details/80590934）" target="_blank" rel="noopener">https://blog.csdn.net/qq_21125183/article/details/80590934）</a></p><img src="/2021/01/12/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91C++%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/2020-11-18-17-40-01.png" srcset="/img/loading.gif" class=""><p>cache在CPU内部，每次从内存中读取数据的时候，实际上是先存到cahce里，再从cache读取到CPU中，cache line一次读64Byte的数据，CPU一次从cache中读8Byte(64位)的数据，<strong>因此字节不对齐并不影响现代CPU的读取速度，因为一个cache line已经把附近的数据也包含进去了</strong></p><p>当代码中出现长if-else语句时，执行的代码可能不在原来的cache中，所以尽量保证循环中的代码的跳跃行数不要太多。</p><p>另外，if分支也让编译器难以改变代码顺序来优化指令执行速度。</p><p>调用操作系统的指令是非常耗费时间的，可能比调用自身的方法慢一百倍量级。</p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><p>string每次写入都会进行重新拷贝，这样是非常耗时的。一些方法可以优化string的性能，并且适用于其他场合。</p><ol><li>用修改替换重新写入：+=操作符等价于append,不会将原来的字符串复制一份。（提升10倍）</li><li>预分配内存：每次扩展容量事实上都包含一次全部的复制，预分配内存可以减少若干次复制操作（提升20%左右）</li><li>使用迭代器：迭代器在几乎任何情况下都比角标寻址要快（提升20%）</li><li>将返回值作为输出参数，并传递引用：传递引用避免了一次拷贝，但是代价是每次调用都会进行一次解引用（取指针指向的地址）操作。返回值不需要多次执行，所以这个代价可以接受。</li><li>利用append或substr对整块内容进行存取（快20%左右）</li><li>采用C风格的固定大小数组，能快上100倍左右。</li></ol><h2 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h2><p><strong>预先计算</strong></p><p>将可预见的重复计算部分放一开始的运行期、编译期或直接内置结果。</p><p><strong>懒计算</strong></p><p>只有在需要结果的时候才计算，这样能消除中间的一些重复计算过程</p><p><strong>批处理</strong></p><p>对一批数据进行处理，取代单个数据连续地处理</p><p><strong>结果缓存</strong></p><p>对中间结果缓存，减少重复计算开销</p><p><strong>双重检查</strong></p><p>先检查必要条件是否满足，大部分情况下都能得到正确的结果；如果检测的必要条件都满足，再用复杂的方法去检查所有条件是否满足，使得小部分情况下也能输出正确的结果。</p><h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p><strong>堆分配内存是极慢的</strong></p><p>new一个对象，首先要在应用程序本身被分配到的内存中寻找合适大小的区块，如果没有，就需要向OS申请更大块的内存（这个操作极其耗时）</p><p>delete也是很慢的，这是因为delete要尽量回收内存碎片，会做许多不必要的操作。</p><p><strong>栈内存与堆内存</strong></p><p>栈内存比堆内存快，栈内存有cache映射，可以直接读取，不要间接寻址。堆内存因为不确定被分配到哪了，可能不在cache中。</p><p>函数调用涉及参数的复制、函数入栈，重复调用应当写成inline.</p><p>栈内存在运行中创建和销毁开销是0，因为所有操作都是编译期被确定好了的，没有检查。栈内存因为会被反复调用，所以大概率处于cache中（然而本身只是一块普通的内存，不一定总是在cache中，而且如果栈中的数组太大，也不会全部被包含在cache中，此时的随机读写和堆内存中的读写速度是一样的，但栈调用没有new操作和delete操作耗费的时间，依然更快）</p><p>全局变量被分配在全局存储区中，对于小变量，全局存储区不如栈的效率高（有cache），但是对于大数组，在哪开都是一样的，因为cache都无法在64Byte内读取到所有元素。</p><p><strong>避免动态分配内存</strong></p><p>两阶段初始化：先统一分配内存，再在需要的时候将数据装入完成初始化，这样就避免了动态分配内存。</p><p>避免的一个方法就是用静态的大数组代替可变数组，将能确定下来的东西先确定了，从而避免低效的再分配。</p><p>第二个方法是避免再分配内存。可以在循环外进行初始化，对于类和大数组可将复制变为引用，减少一次内存分配。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【算法】查询</title>
    <link href="/2021/01/12/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%9F%A5%E8%AF%A2/"/>
    <url>/2021/01/12/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><h2 id="基本概念与分类"><a href="#基本概念与分类" class="headerlink" title="基本概念与分类"></a>基本概念与分类</h2><p>平均查找长度：进行比较次数的平均期望。</p><p>线性查找表：表中数据的联系是线性的，可以用折半查找，搜索效率是O(logn)</p><p>静态查找结构：线性表只适用于没有插入和删除的情况，若存在动态增删，则需要用动态查找结构。</p><p>基于关键字比较的查找结构vs哈希方法：hash方法将关键字映射到内存地址上，使得关键字相连数据（或完整关键字）能够被直接访问到。</p><h2 id="散列技术"><a href="#散列技术" class="headerlink" title="散列技术"></a>散列技术</h2><p><strong>散列函数</strong></p><p>hash函数将关键字映射到有限连续的地址空间，尽量保证一对一映射且不浪费内存。</p><p>散列函数的计算要求不随输入规模变化而变化，一般采用数值计算。</p><p>当关键字线性分布时，用线性映射方法即可得到近似均匀的地址，典型例为乘法散列函数</p><p>当关键字并不均匀分布，但低位变化近似随机时（可以理解为，一群老年人集中在60-80岁，但是个位的变化随机，所以可以分为个位0-9的10个组，每个组的人数近似均匀），可以用取模来进行均匀化，称为模散列函数</p><p>当关键字分布不均匀且比较离散时，可以将关键字进行复杂的混合运算（如平方），然后取中间的几位，因为混合后关键字的不均匀性被初值的敏感性抵消了（混沌现象），所以得到的结果近似均匀。这种称为平方取中法，缺点是计算耗时长。</p><p>当关键字位数很多，且每一位数字分布大致均匀时，可以采用折叠法，即将长串数字进行分割，然后相加，但相加并不能将某些不均匀性抹除。</p><p><strong>冲突处理</strong></p><p>开散列（链表处理）：</p><p>散列处存放的是链表头地址而不是散列关键字，这样就可以在一个地方存储多个关键字</p><p>链表越长，查找效率越低，链表长度平均值被定义为负载因子。</p><p>闭散列法：</p><p>散列处存放的不一定是原本对应的值，而可能是前后对应的值。每次要先检测该位置是不是确实是hash计算出的值，如果不是，就向后线性查找。</p><p>也可以不采用线性探测，即进行增长间隔的探测，以求在最短时间内跳过其他区域的关键字。</p><p>闭散列比开散列时间复杂度更低，但空间复杂度更高（当闭散列负载因子上升时，时间复杂度会急剧上升）</p><p>双重散列（？）</p><p><strong>插入与删除</strong></p><p>闭散列的删除只能设置一个标志位，如果直接删除，会导致后续的元素丢失（找到空位，误以为结束了）</p><p>插入就是在空位处填充</p><p><strong>hash技术总结</strong></p><p>优点是近似O(1)的查找、插入和删除性能</p><p>缺点：</p><ol><li>性能随着负载因子波动，接近满负载时时性能急剧下降，而且要求散列函数设计良好。</li><li>对闭散列进行多次删除操作会造成大量无效空间，并且降低查找性能。</li><li>散列的空间顺序和关键字排序不一定对应，使得查找前一个和查找后一个这种操作无法实现</li></ol><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>分块查找法：块与块之间抽象出有序的特征，但是块内部可以是无序的。</p><p>多级查找表：先按照性质A对所有元素进行分类，再按照性质B对每组元素进行再分类，从而在查找的时候只需要先后比较关键字的性质A和B，即可快速找到。</p><p>倒排表：多关键字情况下，在每种关键字下对元素进行划分，然后可以直接取每次划分的集合交集，实现多关键字合并查找。</p><p>总结：索引将关键字在高维下划分，一个特征对应一个维度，这要求一个关键字能分解出多个独立特征，并且特征的分类不重合。</p><h2 id="树算法分类以及适用情况"><a href="#树算法分类以及适用情况" class="headerlink" title="树算法分类以及适用情况"></a>树算法分类以及适用情况</h2><p>所有查询都是针对一个维度的、可以进行“线性地”比较大小的关键字（a&gt;b, b&gt;c一定满足a&gt;c）</p><p>对于一次构建、无插入删除的查询需求，直接进行一次排序，然后建立索引或者直接二分查找，排序复杂度为O(NlogN), 单次查找复杂度为O(logN), 底数根据索引结构可以建得非常大，使得查找时间几乎不随数据量变化</p><p>对于带有插入、删除、查询的需求，就需要维护一个树，让单次操作达到O(logN)的复杂度。因为随着插入值的不同，树的结构可能退化成线性表，所以需要各种re-balance操作，让树的结构与数据关系有关，但是树的平衡性与插入数据无关：<strong>这得以实现的原因是，一组特定数据可以对应很多个二叉查找树，re-balance操作使得当前二叉树在这个状态空间中不断向着平衡或近似平衡的方向转移</strong>，通过添加特定的约束，使得树状态在高维状态空间中被持续映射到低维的平衡树空间中。</p><h3 id="树堆-Treap"><a href="#树堆-Treap" class="headerlink" title="树堆 Treap"></a>树堆 Treap</h3><p>treap利用随机性维护二叉树的平衡。在BST的基础上，treap让每个节点包括一个权重，使得BST也成为一个堆，堆的性质并不重要，重要的是新增节点权重的随机性。新增权重越接近堆底，周围节点的权重越低，越有概率超过父节点的权重，旋转调整的概率和幅度就越大。</p><p>这就形成了一个平衡：在堆顶位置的节点基本不需要调整，在堆底的节点大概率会向堆顶移动。节点位置是关键字决定的，节点是否需要调整是概率决定的，<strong>于是关键字相对大小与概率相绑定</strong>，整个结构就完成了宏观上对两侧进行平衡的效果。</p><h3 id="伸展树-splay"><a href="#伸展树-splay" class="headerlink" title="伸展树 splay"></a>伸展树 splay</h3><p>splay通过伸展操作让节点总是被移动到根上，在移动的过程中，新增节点的影响通过旋转被平摊到整个树中，平均深度不断减小。</p><p>splay没有附加性质，但是新增节点无论在哪，添加效果都会被平摊到整个树上。</p><h3 id="红黑树-red-black-tree"><a href="#红黑树-red-black-tree" class="headerlink" title="红黑树 red black tree"></a>红黑树 red black tree</h3><p>红黑树指定了一个保证效率的性质：根节点到每个叶子节点经历的黑色节点数目都相同。为了与严格的AVL区分，红黑树放开了黑色节点的条件，即只让它们数目相同，但不必与红等间隔分布（但红不能连续）</p><p>通过局部的旋转可以维持局部性质，从而保证查询效率，同时也减少了无效的过于精确的平衡。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>建立整体性质的树算法：在局部性质被破坏的时候（插入删除节点），利用旋转操作（二叉树的状态转移操作）来进行局部性质的再平衡，从而保证整体性质不变。</p><p>利用随机性的树算法：在局部性质可能被破坏的情况下，利用一个与插入数据大小无关的随机量，让平衡性只与操作次数有关，而与数据无关。</p><h2 id="OJ6-转系后排名"><a href="#OJ6-转系后排名" class="headerlink" title="OJ6 转系后排名"></a>OJ6 转系后排名</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><strong>思路</strong></p><p>插入、删除、查询均要求log(N)复杂度，可以利用GPA的组成有序性，将每一位作为查找树的一层</p><p>数据结构包括</p><ol><li>一个编号表：固定编号，从编号映射到GPA；</li><li>一个skiplist，共7层，每一层用GPA的该位分组，非叶子节点存储该节点下学生总人数，和自身对应的位数字，叶子节点存储该GPA对应同学个数。skiplist存储顺序无意义，每个点包括4个指针：指向父节点（用于增删节点）、指向左侧和右侧兄弟（右侧总是比左侧大）、指向第一个儿子节点、自身对应位数字、对应同学个数（可以与位数字共享一个整型数）</li></ol><p><strong>空间复杂度</strong></p><p>编号表是O(N)的，不超过1000KB；skiplist每个节点16Byte，假设每个同学对应一个GPA，那么也不超过5000KB</p><p><strong>时间复杂度</strong></p><p>新增同学：编号表直接填入GPA；skiplist中添加新GPA或者更新数字，查找GPA位置每层最多搜索10次，总共最多搜索不超过70次，也就是10lg(GPA)。新增链表O(1)，反向更新数字最多7次，就是lg(GPA)，综合下来是11lg(GPA)</p><p>删除同学：首先要查找GPA，然后减少人数，如果人数只有一个就删除链表，综合也是11lg(GPA)</p><p>给编号查询排名：先查询GPA，O(1)，然后累加法得到前面的人数，最多也是10lg(GPA)</p><p>给编号查询排名前一位的GPA：存储按照GPA存，只要查询当前节点下左兄弟或者左侧父节点的最右侧兄弟。和直接查询排名是一样的复杂度</p><p>查询后一位的GPA：同理</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong>debug记录</strong></p><ol><li>若干地方逻辑混乱，序号用错</li><li>在写查找前一个节点时，没有考虑清楚回溯和再下降的条件：回溯只能在当前节点下无法找到相邻节点才运行，再下降是只要找到新的非0节点即可下降。错误的想法是试图用节点下子节点总数去决定是否需要回溯：即使有子节点，也不一定在查找的节点前面</li><li>输入输出问题：必须用scanf和printf，否则IO操作一定被卡</li></ol><p><strong>可优化的地方</strong></p><p>这个数据结构实际上是利用题设附加条件实现一个简化版的skiplist，在re-balance上不采用随机平衡，而是依靠数据范围确定了一个查找下界：必定在6层60次之内查找完。</p><p>查询上，这个实现不是最理想的：如果将每一层的节点联通，就可以实现前后相邻查找严格等于直接查找的复杂度，这需要在插入的时候事先将前后节点连接起来。</p><p>利用数字的结构，将所有数据存储在树的节点连接关系上，可以在每个节点节省一个int的空间，<strong>通过组合的方式将原本10e6的空间压缩到1.11*min(N,10e6)的空间中（N是树叶子节点的数量）</strong></p><p>在对节点进行分类的时候，可以不拘泥于10进制的分类原则，如果采用2进制或4进制分类，总搜索次数为40次，但理论最低值为3进制分类的情况。<strong>但因为在求余的时候得到O(1)的开销，2进制或4进制比3进制的效果要好很多</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【算法】排序</title>
    <link href="/2021/01/12/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/01/12/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h2><p>内排序、外排序：排序不需要占用额外空间的，是内排序。</p><p>排序基本操作：比较和交换，执行次数是衡量排序性能的一个指标</p><h2 id="基本排序方法"><a href="#基本排序方法" class="headerlink" title="基本排序方法"></a>基本排序方法</h2><p>冒泡排序：每一次冒泡可以确保第K小的数移动到相应的位置，下一次冒泡只需比较K+1的位置。可以看成每次检索一个最大数，然后将其抽出。</p><p>插入排序：将元素一个个插入排序好的序列，仍然需要进行连续的比较。</p><p>折半插入排序：采用二分查找法确定插入时的位置，但不能保证最差情况，所以复杂度仍然是O(n^2)</p><p>希尔排序：先确定一种子序列排序方法，如直接插入排序。然后对n间隔依次到1间隔进行排序。这里的n间隔指关键字间隔n个。实验表明希尔排序平均移动次数大概是O(n^1.25)</p><p>直接选择排序：每次检索最大数或最小数</p><h2 id="高级排序方法"><a href="#高级排序方法" class="headerlink" title="高级排序方法"></a>高级排序方法</h2><p><strong>快速排序</strong></p><p>思路：任意指定一个数（通常是最末位），然后将其放在正确的位置上：左右指针向中间靠近，使得左右满足左侧小于该数，右侧大于该数，这样指针最后就能找到该数的正确位置。然后对左右侧分别进行操作即可。</p><p>性能：平均来看，可以将快排每次确定的阈值都看作中位数，每次至多对N个元素进行操作，总共有logN层，所以性能为O(NlogN)</p><p><strong>归并排序</strong></p><p>自底而上方法：将N个数看成N个长度为1的序列，然后两两归并（归并指将2个序列合成一个有序的新序列，复杂度O(n)），这样也是自底而上，归并logN层，每层元素有N个，复杂度O(NlogN)</p><p>自顶而下方法：也就是实现从顶部划定了归并调用的结构，然后自底而上归并。</p><p><strong>堆排序</strong></p><p>参考堆的笔记。堆可以做到O(logN)的删除最大值操作。重复抽出N个最大值就得到有序序列。</p><h2 id="特殊情况下线性复杂度排序"><a href="#特殊情况下线性复杂度排序" class="headerlink" title="特殊情况下线性复杂度排序"></a>特殊情况下线性复杂度排序</h2><p><strong>关键字计数排序</strong></p><p>条件：关键字是整数或可与整数关系建立双向映射、取值范围有限</p><p>累计计数：利用整数排列的唯一性，只要映射数的存在性即可得到排列。显然数的存在性是可以在线性时间内获取的。</p><p>推广：只要待排序关键字取值可能数量有限，且关键字之间的比较满足传递关系，那么就将所有可能性预先排序，然后考察存在性即可。如果关键字有附带信息，可以用链表形式存储地址，并且维护一个当前关键字下重复个数</p><p>复杂度计算：假设整数个数为K，空间复杂度O(N+K)，第一次对每个元素检查，O（N），然后从K数组中读取排序后结果, 无附加信息时同关键字不需要分辨，O(K)，总时间复杂度O(N+K)</p><p><strong>桶排序</strong></p><p>假设已知数据的分布情况，给定一个数据，就可以估计其大概在什么位置，于是对所有数据，将其放置在表示大概位置的桶内，再对桶内的数据用其他方法排序。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【算法】拟合与插值+OJ10</title>
    <link href="/2021/01/12/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8B%9F%E5%90%88%E4%B8%8E%E6%8F%92%E5%80%BC+OJ10/"/>
    <url>/2021/01/12/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8B%9F%E5%90%88%E4%B8%8E%E6%8F%92%E5%80%BC+OJ10/</url>
    
    <content type="html"><![CDATA[<h2 id="拟合与插值"><a href="#拟合与插值" class="headerlink" title="拟合与插值"></a>拟合与插值</h2><p><strong>超定方程组</strong></p><p>超定方程组是多次观测得到的结果，无法直接解出，需要拟合。</p><p><strong>线性拟合</strong></p><p>方程组的每一行看作一个数据点，每一列的数据是多项式的项，如x^2+x+1，第一列就是x^2,第2列就是x，第三列是1</p><p>写成如上形式后，就不关注拟合表达式的结构，而全都看作线性拟合（使得每一行的误差满足最小二乘下的最优）</p><p>解的存在性：如果列向量线性无关（即不出现Ax+Bx这种情况），就必定有唯一解</p><p><strong>正规方程法</strong></p><p>正规方程的A’A就是将A（m*n，看作n个m维向量）投影为n个n维向量，其中投影的方式满足m维向量到n维超平面的欧氏距离最短。</p><p>Cholesky分解：就是对A’A有特殊的LU分解，其中U=L’，所以分解后得到的是LL’</p><p>正规方程法得到A’A矩阵相乘复杂度O((mn^2)/2),Cholesky分解复杂度O(n^3/6)</p><p>线性拟合问题的敏感性：</p><p><strong>QR分解</strong></p><h2 id="OJ10"><a href="#OJ10" class="headerlink" title="OJ10"></a>OJ10</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>假设有N个标志，每个标志置0或1，那么最多有2^N个状态，当N较小时，即使M较大，BFS最多搜索的状态数是2^N，多余的状态可以通过减枝删去（状态存储算法？）</p><p>假设有M个塔，就是M个未知量，高斯消元法每次是O(M^3)的。当M较小时，即使N很大，也可以将多余的塔全部置0减少计算量。</p><p>当M和N都较大时，指数增长远大于三次方增长，此时先用高斯消元法，找到真正可变的一组塔，然后以此缩小状态范围，再用BFS搜索得到解。</p><p>若N&lt;9，且M&gt;10时，用BFS。其他情况用高斯消元法。</p><p><strong>BFS</strong></p><p>数据结构是一个struct，三个int，分别存储上一状态的序号、当前标志状态。先添加根节点到队列中。</p><p>每次更新时，从队列取出一个节点，在visited结构中搜索状态是否已经被考察过。若未展开过，分别计算M个相邻节点标志的变化，得到新节点。再对每个节点判断它的标志状态是否已经考察过了，若考察过了，则不再添加到队列中（第一次考察时一定把它的所有子节点展开过了），若未考察过，添加到队列中。最后在visited结构中添加这个取出的节点（所有节点都被访问过了，所以不再考虑它）</p><p>每次更新，更新开始方位的，再更新结尾方位的，最多的步数不超过M/2次（最短路径一定每个点至多踩1次）。结尾方位更新时，计算变化要用“减去”而不是“加上”</p><p><strong>高斯消元</strong></p><p>结构是一个N*(M+1)的矩阵A，其中A[m][n]的值等于第n个标志是否与第m个塔相连。然后解AX=B，其中B是目标状态，X是踩塔的解决方案。扩展M到M+1（把B包含进去），然后高斯消元，消元方式也是异或。</p><p>当存在多种可能性的时候，无法保证找到最优解。也就是当塔的数量大于标志的数量时，解不一定正确。</p><p><strong>改进后高斯消元</strong></p><p>假如在高斯消元后，统计主元列的数量和位置，就可以找到非确定的变量。在非确定变量较少的时候，可以用暴力搜索找到最优值。</p><p>检测点的非确定变量少于5个，搜索次数不会多余32次。可以比较顺利的实现。</p><p>要减枝也有方法：在代入的过程中判断当前的塔个数是否已经大于计算出的最小值。但是这次时间较宽裕，所以不需要。</p><p><strong>debug</strong></p><p>最后2个判例内存不足，而且都是N=M的情况。有4-5个非主元列，暴力搜索最多需要32次.</p><p><strong>小结</strong></p><p>OJ10的工作量和debug难度都不小。BFS方法写起来比较复杂，而且为了查询操作O(logN)的复杂度，需要维护一个动态更新的二叉树。debug方面，有几次是角标、序号等细节错误，<strong>这说明在更改的时候要用查询和替换，不要自己看着代码改</strong>。最后一次是高斯消元写的有问题，应该先对各部分测试。</p><h3 id="判例"><a href="#判例" class="headerlink" title="判例"></a>判例</h3><p>1<br>4 4 1<br>2 -1<br>1 3 4 -1<br>1 4 -1<br>1 2 4 -1<br>1 0 1 1</p><p>1<br>4 4 1<br>1 -1<br>2 -1<br>3 -1<br>4 -1<br>0 0 0 0<br>输出：1 \n 1 1 1 1 -1</p><p>1<br>4 4 1<br>2 4 -1<br>3 1 -1<br>2 4 -1<br>-1<br>0 0 0 0</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【算法】优化初步</title>
    <link href="/2021/01/12/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%BC%98%E5%8C%96%E5%88%9D%E6%AD%A5/"/>
    <url>/2021/01/12/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%BC%98%E5%8C%96%E5%88%9D%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="优化初步"><a href="#优化初步" class="headerlink" title="优化初步"></a>优化初步</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>优化问题</strong></p><p>优化问题就是在给定条件（等式，不等式）下寻找目标函数的最值点</p><p>例如：给定总面积，做一个容积最大的盒子、给定盒子容积，求如何做总面积最小</p><p>若条件和目标函数都是线性的，那么就是线性规划</p><p><strong>凸性</strong></p><p>当优化问题是“凸”的，也就是说：局部最优点=全局最优点（只有一个局部最优点），那么就可以用局部信息找到全局最优点。</p><p>强制：若函数在x极大或极小时都趋近正无穷，那么函数就是强制的。强制的函数在闭区间上一定存在最小值。</p><p><strong>优化条件</strong></p><p>如何判断一个点是局部最优点，也就是n维空间下的局部极小值。</p><p>取偏导数判断：海森矩阵（正定、不定）、拉格朗日函数求极小值</p><p>取所有可行方向：从最优点看，在所有方向上，最优点都是最低点（方向导数大于0）</p><h2 id="一维优化方法"><a href="#一维优化方法" class="headerlink" title="一维优化方法"></a>一维优化方法</h2><p><strong>黄金分割搜索</strong></p><p>对于单峰函数（左边下降，右边上升，只有一个最低点），对于一段a-b的f(x)，取黄金分割的两个点(tau和1-tau)，比较这两个点的大小，最小值只能在较小点所在的区间中（每次能排除一小半的x）</p><p>注意：必须要单峰函数才行。</p><p><strong>牛顿法</strong></p><p>用抛物线拟合一个点的函数值、一阶导和二阶导，然后预测底部，接着跳转底部继续预测。</p><p>好处：初始值比较近时，平方收敛。<br>坏处：可能找到极小值不是最小值</p><p><strong>保护法</strong></p><p>用黄金分割法得到合适的初值，用牛顿法快速收敛到解。</p><p>混合方法，收敛更快，但是也要注意适用于单峰函数。</p><h2 id="多维优化方法"><a href="#多维优化方法" class="headerlink" title="多维优化方法"></a>多维优化方法</h2><p><strong>最速下降法</strong></p><p>可微函数的负梯度总是指向下降最快的方向，所以每次迭代朝着负梯度前进寻找下一个点即可。</p><p><strong>多维牛顿法</strong></p><p>求解线性方程组（？？？）</p><p>缺点：牛顿法对初值相当敏感，</p><p><strong>KKT条件</strong></p><p>先求临界点，再筛选真正的极小值</p><p><strong>障碍法</strong></p><p>将约束条件转化为惩罚函数，使得可以在R^n上搜索结果（即使搜索到了可行域之外的，惩罚函数会使得成本充分大，让无约束问题的最优点等效于原问题）</p><p>会选取特定形式的惩罚函数，分为等式和不等式两种情况。</p><h2 id="凸优化"><a href="#凸优化" class="headerlink" title="凸优化"></a>凸优化</h2><p>凸集合：顾名思义</p><p>线性组合是凸的，非负线性组合是凸的，范数球也是凸集，</p><p>凸函数：全局最优=局部最优</p><h2 id="OJ8"><a href="#OJ8" class="headerlink" title="OJ8"></a>OJ8</h2><p><strong>一维情况</strong></p><p>假设一条路径是最优的，那么它每两个点之间的路径也是最优的。</p><p>对于最优路径上每一个点k，它在0-k范围内也是最优的。</p><p>假设每个点都存储了从0到该点的最优路径经过的点数目f(k)，那么在计算f(k+1)的时候，只要找到比自身位置低的点中f(x)最大的点m，就有f(k+1)=f(m)+1</p><p><strong>一维情况的思路</strong></p><p>先读取所有高度，连同顺序，即ind+H，读到数组A中，然后对A快排（nlogn），再遍历ind（n），得到顺序与高度位置的映射（给定一个顺序，找到高度所在位置），在高度顺序表基础上建完全二叉树，树的节点存储子节点f(m)的最大值，默认为0。</p><p>用顺序到高度的映射依次更新f(m)：每次更新，查找比自己小的高度的对应f(m)的最大值（最多找logn次），找到后即可更新自己的f(k)=max{f(m)}+1，因为其后添加的节点的f(m)都是0，所以不影响结果。</p><p>更新后，依次向上更新max{f(m)}, 最多logn次。单次更新是O(logn)量级，更新所有后，记录最大值。</p><p><strong>二维情况</strong></p><p>在计算f(k+1)的时候，只要找到x,y都不超过自己的点中f最大的点m，就有f(k+1)=f(m)+1</p><p>先用kd树对(sl,sr)区域进行划分，同时非叶子节点存储区域内的max{f(m)}，然后依然用ind-&gt;node映射来依次更新f(k)：</p><p>首先查找x,y都小于自身的区域的最大f(m)的值，不妨将2层合并，假设一次查找4个区域1234，当更新的节点落在不同区域时，要接着深入的区域也不同，但总的来说，一次查找平均能减少1/2的无效区域，同时节点落在每个区域的概率是随机的，所以总查找消耗应该不是n^2级别，但还没法具体计算时间复杂度。</p><p>这种查找方式应该与最近邻有一种形式的等效，可以直接看作sqrt(n)的复杂度？</p><p>在具体实现的时候，用了类似的思路，但是在每次对单层进行操作的时候，需要注意一些细节：在nth_element选择的时候，无法保证每次的中点是<strong>相等的x,y中最晚加入的点</strong>，于是无法保证当该点的值为分界线时，需要检测的点都在一边，所以这个地方的等号不能加。</p><p>如果结合两层判断，就需要在具体到节点的时候再保证一次有效性，但是相反地，在排序的时候就不需要再控制pos的关系。</p><p>实际测量了8次不同N的耗时，发现确实是符合n<em>sqrt(n)的，*</em>这种用数据量来检测时间复杂度的方法也可以用来debug：看自己是不是写出了符合条件的复杂度**</p><p><strong>性能优化</strong></p><p>这次OJ对性能要求非常苛刻，在复杂度O(n*sqrt(n))不变的情况下，对若干细节进行优化，使得最后在N=5E4的速度比最开始的速度快了4倍。</p><p>首先是优化kd树中获取子节点/父节点的函数，先是用数组序号代替引用，然后把多余的调用手动合并掉，再用arr2pow数组计算2的若干次方的结果，这些步骤把耗时从3000ms降到了1000ms</p><p>接着是进一步优化，虽然写了inline，但是速度依然受限，所以用位运算+宏的方式把函数原地展开，这一步把耗时从1000ms降到了800ms左右</p><p>再接着是把scanf用快读代替，这一步能优化几十毫秒，否则scanf会占到100-200ms，对结果影响很大。</p><p>再接着是对一些细节进行优化，比如count计数其实不需要，直接删除。除2和模2都用位运算代替；最后一层可以先判断isleaf，节省一次调用开销（整个创建期间，节省了N次调用开销）；查询的方法参数过多，而且都是bool量，将其合并在一个char里面，用位运算来读取和写入，节省了一些内存复制的开销。</p><p><strong>Debug</strong></p><p>这次OJ的debug也非常困难，具体地说，一是难以构建判例发现错误的逻辑，二是难以跟踪OJ的WA</p><p>有一次RTE是因为数组开的不够大，但是如果用constexpr的话，<strong>数组不够大并不会报RTE而是WA</strong>。理论上虽然完全二叉树只需要2N的空间，但是实际上logN是非整数，完全二叉树的最下一层是默认上面都填满了的，所以需要用2^17来计算而不是2N来计算。</p><p>debug的时候比较困难的是找判例，大多数简单判例并不能找到bug。<strong>这时候用大判例+数量级的判断</strong>就可发现一些问题，或者是<strong>自己随机写一些临界判例，有概率恰好碰到bug</strong>，但是最保守（做完后看来也是非常有效的）的方法<strong>是写一个复杂度劣化的版本，然后用随机数构造判例</strong></p><p><strong>判例</strong></p><p>test1的全部数据输入时，答案是81</p><p>1<br>10<br>18467 41<br>26500 6334<br>15724 19169<br>29358 11478<br>24464 26962<br>28145 5705<br>16827 23281<br>491 9961<br>11942 2995<br>5436 4827</p><p>1<br>5<br>100 100<br>10 10<br>20 20<br>30 10<br>10 50</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OJ优化指南</title>
    <link href="/2021/01/12/OJ%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/"/>
    <url>/2021/01/12/OJ%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="OJ优化指南"><a href="#OJ优化指南" class="headerlink" title="OJ优化指南"></a>OJ优化指南</h1><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><ol><li>scanf和printf代替cin和cout：在一些情况下，加了sync后者也会占用相当长的IO时间</li><li>需要用 #pragma warning(disable:4996) 避免报错</li><li>快读：快读旨在利用已知的输入格式避免读取数据时的逻辑判断（边界、有效值、其他可能情况）</li></ol><h2 id="样例估计"><a href="#样例估计" class="headerlink" title="样例估计"></a>样例估计</h2><ol><li>用assert估计样例规模（二分法），有助于判断一些因为规模太大而WA的情况</li><li>assert估计规模还可以查清实际的时间复杂度与空间复杂度限制（题面的范围有时不可能实现）</li><li>用assert分辨样例特征，可以针对某个样例设计参数，从而可以用不普适的方法AC</li><li>用assert进行预debug：在逻辑中针对某些不可能出现的分支设计assert，从而提高bug的侦测概率</li><li>用assert进行分支执行的检测：在需要检测是否执行了的分支上设置assert，验证猜想</li></ol><h2 id="内存利用"><a href="#内存利用" class="headerlink" title="内存利用"></a>内存利用</h2><ol><li>位段和设置字节对齐：牺牲一定的读取速度换取常数项的减少。</li><li>数组复用：当各阶段解耦时，可以用前一个方法的数组的空间来进行后面的计算</li><li>用组合的方式存储数据、指针实现动态扩容。</li></ol><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ol><li>i++写成++i避免一次返回操作</li><li>inline和register等C++内置的优化方法</li><li>尾递归到循环的优化</li></ol><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><ol><li>用#define来设置一个版本开关，使得改变一行就可直接把本地代码提交且不占运行时间</li><li>release版本可以删除debug版本中一些逻辑检测来优化运行用时。</li></ol><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><ol><li>写测试函数把中间过程输出，便于调试。</li></ol><h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><ol><li>先测试本地小样例，再用OJ结果测试</li><li>检查一个中等复杂样例的所有中间过程</li><li>排除法定位问题，再进行分支预测</li><li>用vs自带的运行分析来优化耗时较高部分</li><li>在多个复杂方法组合时debug, 先写一个劣化的简单方法，然后查看是否仍然WA</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【写作】沉默的大多数（王小波）分析与感想</title>
    <link href="/2021/01/12/%E3%80%90%E5%86%99%E4%BD%9C%E3%80%91%E6%B2%89%E9%BB%98%E7%9A%84%E5%A4%A7%E5%A4%9A%E6%95%B0%EF%BC%88%E7%8E%8B%E5%B0%8F%E6%B3%A2%EF%BC%89%E5%88%86%E6%9E%90%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    <url>/2021/01/12/%E3%80%90%E5%86%99%E4%BD%9C%E3%80%91%E6%B2%89%E9%BB%98%E7%9A%84%E5%A4%A7%E5%A4%9A%E6%95%B0%EF%BC%88%E7%8E%8B%E5%B0%8F%E6%B3%A2%EF%BC%89%E5%88%86%E6%9E%90%E4%B8%8E%E6%84%9F%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="沉默的大多数"><a href="#沉默的大多数" class="headerlink" title="沉默的大多数"></a>沉默的大多数</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个笔记有两个目的：第一是分析杂文的写作风格，包括逻辑、结构、情绪、用词等，是对文章的分析；第二是分析杂文的思想，与当今的现状进行对比，完成对思想的批判。</p><p>以下是写作风格的细分：</p><p><strong>结构</strong></p><p>精彩的开头、精彩的结尾</p><p><strong>逻辑</strong></p><p>如何给出定义、如何进行论证、如何巧妙的引导读者</p><p><strong>情绪</strong></p><p>如何调动读者情绪、如何避免与读者对立</p><p><strong>用词</strong></p><p>如何避免过于通俗的用词、如何避免过于书面化的用词</p><h2 id="《沉默的大多数》"><a href="#《沉默的大多数》" class="headerlink" title="《沉默的大多数》"></a>《沉默的大多数》</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><blockquote><p>人要永远做小孩子虽办不到，但想要保持沉默是能办到的。</p></blockquote><p>开头先讲故事，再类比推出主题，同时注意语序“XX是能办到的”，而不是“但是可以保持沉默”，就强调了这个动作的特殊性。</p><blockquote><p>往往有一种交流信息的独特方式，甚至是特有的语言，有一些独有的信息，文化可以传播，等等。这才能叫作文化</p></blockquote><p>为了解释沉有别于一般“动作”的特殊性，先定义了文化这个东西，采用的是反例修正的方式，即“满足XX才是”，<strong>避免了无效的名词解释</strong>。</p><blockquote><p>冲上阳台，朝全世界放声高呼：我们家吃大鱼大肉了！</p></blockquote><p>王小波的夸张体现在字词的选用上，<strong>用小主体搭配大动作，或者相反，体现戏剧效果或讽刺效果</strong></p><blockquote><p>据我所知，那个圈子里常常犯着贫乏症</p></blockquote><p>王小波在“说话-掌握话语权”和“沉默-学到人性”中站队后者，那自然要论述前者的不好。首先就是一个词的<strong>高度概括</strong>。好处是：<strong>简洁有力，而且吸引读者继续阅读，相当于把握了主场</strong></p><blockquote><p>我希望自己朴实无华，说起话来，不要这样绕嘴，这样古怪，这样让人害怕。</p></blockquote><p>让别人赞同自己的观点的时候，如果没有情感烘托，就不需要表现出自己抨击的猛烈性。相反，<strong>古怪，让人害怕</strong>这样的话可以更好地与读者共鸣（前面的就是一个“古怪”的故事）。</p><blockquote><p>中国人有句古话：敬惜字纸。这话有古今两种通俗变体：古代人们说，用印了字的纸擦屁股要瞎眼睛；现代有种近似科学的说法：用有油墨的纸擦屁股会生痔疮。其实，真正要敬惜的根本就不是纸，而是字。文字神圣。</p></blockquote><p>核心观点无疑是“文字神圣”，但是不能用敬惜字纸来直接论证，<strong>直接把别人的话当作自己观点的第一证据，显得没有主见，削弱了影响力</strong>。</p><p>两个古今的解释一定上论证了古话的科学性，然后以一种相似的方式，<strong>用一个角度的正确让人相信自己阐述的另一个角度也是科学正确的</strong></p><blockquote><p>我只敢说我厌恶自己说自己神圣，而且这也是实情</p></blockquote><p>作者举了爱人的例子来说明话语太过神圣，从而是反人性的。<strong>作者的目的是在这种假严肃假庄重的文学圈子里写一些反映真实人性的东西</strong></p><h3 id="余论"><a href="#余论" class="headerlink" title="余论"></a>余论</h3><p>王小波关于的话语权神圣性的讨论在现在大概难以引起共鸣了，但是话语圈和沉默的群体在现实中确实存在。话语和沉默产生于群体，又反过来控制群体，以至于便于交流的东西被贴上神圣的标签。一部分人因为别人的沉默而也放弃了自己的权力。</p><h2 id="《思维的乐趣》"><a href="#《思维的乐趣》" class="headerlink" title="《思维的乐趣》"></a>《思维的乐趣》</h2><blockquote><p>这正是因为在那些年代，有人想把中国人的思想搞得彻底无味</p></blockquote><p>大一统的官方思想落实不够科学，本来是强调革命精神，执行到底层就变成了杜绝其他精神</p><blockquote><p>假如一个人每天吃一样的饭，干一样的活，再加上把八个样板戏翻过来倒过去地看，看到听了上句知道下旬的程度，就值得我最大的同情。</p></blockquote><p><strong>避免卖惨式的叙述</strong>，这里采用假设的方式叙述自己的经历，更加委婉和有趣</p><blockquote><p>胡思乱想并不有趣，有趣是有道理而且新奇。</p></blockquote><p>反例修正，补充论点</p><blockquote><p>在这个名单的末尾是一些善良的军代表，他们想把一切从我头脑中驱除出去，只剩一本270页的小红书。</p></blockquote><p>善良在这里是讽刺，小红书是毛思想的具象化，也是刻板强力灌输的思想的象征。<strong>具象化的东西总要比抽象的生动</strong></p><blockquote><p>我认为脑子是感知至高幸福的器官，把功利的想法施加在它上面，是可疑之举</p></blockquote><p>用词很好，“可疑之举”既没有直接表达的弊端，也有一定的客观性。</p><blockquote><p>当然，如果有人乐意这样来对待自己的孩子，那不是我能管的事，我只是对孩子表示同情而已.</p></blockquote><p><strong>避免权力越界</strong>是写作需要注意的，<strong>作者只能通过文字影响读者，再让读者自己产生“应该”与“好坏”的价值观，如果直接灌输观点，就会引起读者的不适和反抗。</strong></p><blockquote><p>假如说，思想是人类生活的主要方面，那么，出于功利的动机去改变人的思想，正如为了某个人的幸福把他杀掉一样，言之不能成理。</p></blockquote><p>类比论证，推出显著的谬误</p><blockquote><p>倘若去掉一部分，我是谁就成了问题。</p></blockquote><p>没有采用“我就不是我了”这种简单的论断，<strong>而是倒换语序</strong>，让“问题”变成重点</p><blockquote><p>人既然活着，就有权保证他思想的连续性</p></blockquote><p>朴素的人权观念</p><blockquote><p>假如我全盘接受，无异于请那些善良的思想母鸡到我脑子里下蛋，而我总不肯相信，自己的脖子上方，原来是长了一座鸡窝</p></blockquote><p>用形象的比喻引导读者关注自身思想独立的权力，<strong>从受尊重权过度到思想独立权</strong></p><blockquote><p>所以这种脑移植带给我的不光是善良，还有愚蠢。</p></blockquote><p>被迫接收思想的危害性之三，之一是与其他思想隔绝，之二是丧失独立人格</p><blockquote><p>领导上硬要我去，我还得去，但是这以后挖坏了青山、造成了水土流失等等，就罪不在我</p></blockquote><blockquote><p>所以，质朴的人们假如能把自己理解不了的事情看作是与己无关的事，那就好了</p></blockquote><p><strong>讽刺是站在自己的视角进行观察的，而且要让读者接受，不能直接给出观点</strong>, 给出感受而不是批判，给出期望而不是指控。</p><h2 id="中国知识分子与中古遗风"><a href="#中国知识分子与中古遗风" class="headerlink" title="中国知识分子与中古遗风"></a>中国知识分子与中古遗风</h2><h3 id="摘要-1"><a href="#摘要-1" class="headerlink" title="摘要"></a>摘要</h3><blockquote><p>首先表现在受约束上</p></blockquote><p>同样地，先给出一个高度概括的词，然后分析。</p><blockquote><p>另一类是踩着地雷断了腿的同类</p></blockquote><p>这里用同类而不是知识分子，<strong>用批判对象冲突的特征来称呼对象，本身就是一种讽刺和批判</strong></p><blockquote><p>还有一个爱说的话题就是别人“格调低下”</p></blockquote><p>引出观点也要站在自己的观察者角度，<strong>“爱说”和“认为”前者是客观观察，后者是主观意志，作者不能反客为主，只能道出自己的感受</strong></p><blockquote><p>除了树立形象，还该树立个森严的道德体系，把大家都纳入体系，从道德上说事，就人人都能被说着了。</p></blockquote><p>群体价值观的建构与内部利益分配有关</p><blockquote><p>也不像现代欧美知识分子跨价值观的立论（价值中立）。最爱干的事是拿着已有的道德体系说别人</p></blockquote><p>批判中国知识分子的“中古遗风”，<strong>在论点句用通俗的语言，在其他无关紧要的地方用专业术语，倒置引起反差</strong></p><blockquote><p>，“脱裤子割尾巴”地混了这么多年，才混到工人阶级队伍里，可谓“心比天高，命比纸薄”！在这种情况下，我建议咱们把“士”的传统忘掉为好</p></blockquote><p>这里建议的手法很巧，<strong>首先站在批判对象的角度，给出反对的“代价”，然后给出建议，最后给出评价</strong>，这里的评价也很中肯，是“也未必见得不好”，双重否定增强委婉程度，“见得”强调大众角度，容易受大众支持。</p><h3 id="余论-1"><a href="#余论-1" class="headerlink" title="余论"></a>余论</h3><p>只给现象，对原因的分析较少。总的来说只有一个历史惯性。并且给出一个改革方案。</p><p>上地</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【算法】动态规划</title>
    <link href="/2020/12/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2020/12/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><p>对于一个问题，若满足如下3个条件，则可以用动态规划方法解决：</p><p><strong>具有最优子结构</strong>：任意找一个中间状态，若这个解要成为全局最优解，那么从该状态到末状态的决策必定是该状态下的最优解</p><p>注：若最优解能推导出从初始状态到中间状态的解也是最优的，那么就可以用贪心法。不需要DP</p><p><strong>无后效性</strong>：一个状态即包含后续决策所需的所有前置信息。过去决策无法直接影响未来决策，而必须通过当前状态传递信息。</p><p><strong>重复子问题</strong>：在求解时若用蛮力法会对相同问题重复求解，这也是DP能优化速度的原因所在。</p><p>用DP方法时，有如下步骤：</p><ol><li>定义阶段和各阶段下的最优值</li><li>从初始状态开始逐个计算最优值，每次计算时，遍历前阶段最优值</li></ol><p><strong>状态转移方程</strong>：在计算阶段K+1的时候，使用前K阶段的状态来计算得到K+1阶段的最优策略的方程</p><p><strong>多维动态规划</strong></p><p>动态规划一般会记录一个表，只要把这个表从小到大算一遍就能算出答案</p><p>二维动态规划就是填一个二维的表，适用于有2个独立的阶段约束的情况（一般来说，数据规模也是二维的）</p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><p>描述：给出N件物品，每件价值不同，重量不同，给定总重量W，求解总价值最大的装载方案。</p><p><strong>分析</strong></p><p>直观地，选定W为阶段数，总价值为最优值。状态即是当前装载的物品列表。</p><p>先考察最优子结构，对于最优的装载方案，给定中间的某个装载列表，则从剩余的物品中选择必定要选最优的组合，如果不选最优，可以用最优的替代，则原方案非全局最优方案。</p><p>再考察无后效性：给定一个装载列表即可知道剩余的物品，也可知道当前重量，于是包含了所有前置信息。对于重量为W的方案，需要考察重量小于W的方案，因此满足重复子问题</p><p>解决时，先从W=1开始，每次推导W+1阶段时，假设至多能添加一个新的物品（这个假设一定能覆盖到W+1的最优解的上一状态，且方便计算最优决策），遍历各个之前的状态，计算总和最大的一个状态。</p><h3 id="钢条切割问题"><a href="#钢条切割问题" class="headerlink" title="钢条切割问题"></a>钢条切割问题</h3><p>描述：给定不同长度钢条的价格，再给一段长L的钢条，求解总价值最大的切割方案</p><p><strong>分析</strong></p><p>直观地，L是阶段数，总价值是最优值。状态是已经切完的长度L_0（为什么与01背包不同，因为物品拿走了就不能再拿，具有全局性，而钢条可以随意切割）</p><p>最优子结构：假设前L_0的钢条已经切完了，那么从L_0到L的钢条必定也要切成最优方案。</p><p>无后效性：只要得知L_0的钢条切割完，后续L_0到L的切割方式就可以随意制定，与L_0是怎么切割的无关</p><p>解决时，先从L=1开始，每次假设只能多切一整段的钢条，所以L-L_0的部分直接卖出，而L_0的价格取之前计算的最优值。</p><p>这个假设还是可以验证：若L长度的钢条切割方案卖得最好，那它必定能分解成L_0和L-L_0的单独段钢条，至于L-L_0有多长无法得知，但是只要遍历所有的单独段钢条，就一定能覆盖到最优方案。</p><h3 id="股票交易（买卖股票最佳时机IV）"><a href="#股票交易（买卖股票最佳时机IV）" class="headerlink" title="股票交易（买卖股票最佳时机IV）"></a>股票交易（买卖股票最佳时机IV）</h3><img src="/2020/12/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2020-12-24-11-00-18.png" srcset="/img/loading.gif" class=""><p><strong>分析</strong></p><p>直观地，k是阶段数，总利润是最优值。</p><p>先作一些预处理：将股票价格写为2日之差的形式，买卖就等效为寻找最大和子序列。那么阶段就等效为当前可交易的日期的数据（总数据抛去交易中的数据）</p><p>最优子结构：假设已经进行了k_0笔交易，把剩下的天数抽出来重排，后续的交易在剩下的天数里必然也是能最大盈利的。</p><p>无后效性：只要得到可以交易的天数的数据，前面的k_0笔交易无影响。</p><p>注：假设一笔交易完全覆盖了之前的交易日期，也就是横跨了被截取的日期，那么之前的那笔交易就不是进行k_0笔交易时的最优交易，若横跨2个交易，也可以选择一次不交易。总之新的交易不会跨过之前交易的日期，进行日期合并是安全的。</p><p>解决时，先默认k-0时利润为0，然后从k=1开始，每次先加载前k_0项交易，然后对处理过的数组寻找最大子序列，这是个O(n)的操作。</p><p>附：最大和子序列问题：从第一个值累加，累加结果小于等于0时，舍去前面的结果。记录最大的累加结果就是最大和。</p>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】图搜索</title>
    <link href="/2020/12/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%BE%E6%90%9C%E7%B4%A2/"/>
    <url>/2020/12/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%BE%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="图搜索"><a href="#图搜索" class="headerlink" title="图搜索"></a>图搜索</h1><h2 id="组合优化"><a href="#组合优化" class="headerlink" title="组合优化"></a>组合优化</h2><p><strong>非数值优化问题</strong>：给出一些条件，选取一种最优的“状态”。每个状态之间是有关联的，所以可以用图或者树的方式将状态联系起来。</p><p>注：局部解就是一个不完全的解，类似于八皇后只给出4个皇后的位置</p><p><strong>回溯法</strong>：类似深度优先搜索，只要局部解有可行性就继续深入，直到解不可行再回溯到可能可行的局部解</p><p><strong>分支界限法</strong>：类似广度优先搜索，先计算出不可行的点的范围，再对可行的范围按照解最可能存在的顺序一一搜索。</p><h3 id="剪枝策略"><a href="#剪枝策略" class="headerlink" title="剪枝策略"></a>剪枝策略</h3><p>2种方法都需要剪枝。</p><p>对最优问题，先存储当前找到的全局最优解，只要局部解已经确定不优了，就不用搜索。</p><p>必要条件剪枝：不满足最优的必要条件的，一定不是最优，这种检测方法比较简单。</p><h3 id="任务分配问题"><a href="#任务分配问题" class="headerlink" title="任务分配问题"></a>任务分配问题</h3>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】随机算法</title>
    <link href="/2020/12/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    <url>/2020/12/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>随机性</strong>：算法中引入随机数，多次运行，结果可能不同。</p><p><strong>线性同余法</strong>：用于产生伪随机数，思路把上一个随机数变成ax+b，然后对M取余。要求M必须很大（这样分布才广），第一个数称为种子。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="计算圆周率、计算函数定积分"><a href="#计算圆周率、计算函数定积分" class="headerlink" title="计算圆周率、计算函数定积分"></a>计算圆周率、计算函数定积分</h3><p>随机算法相当于近似地取面积，对于精度要求不高的情况很合适。</p><h3 id="随机搜索非线性方程的解"><a href="#随机搜索非线性方程的解" class="headerlink" title="随机搜索非线性方程的解"></a>随机搜索非线性方程的解</h3><p>用满足正态分布或均匀分布的方式搜索。</p><h3 id="舍伍德算法"><a href="#舍伍德算法" class="headerlink" title="舍伍德算法"></a>舍伍德算法</h3><p>思想：随机化输入/中间取值，以避免不好的样例对复杂度的恶化。</p><p>舍伍德法优化快排：随机找一个元素作为划分元素，或随机找三个元素，取中间位置的元素作为划分元素。</p><p>优化二叉树：对待建树的元素进行随机洗牌。</p><p>注：随机洗牌Fisher–Yates算法：</p><blockquote><p>每次随机选取一个数，然后将该数与数组中最后(或最前)的元素相交换(如果随机选中的是最后/最前的元素，则相当于没有发生交换)；然后缩小选取数组的范围，去掉最后的元素,即之前随机抽取出的数。重复上面的过程，直到剩余数组的大小为1，即只有一个元素时结束。</p></blockquote><h3 id="拉斯维加斯算法"><a href="#拉斯维加斯算法" class="headerlink" title="拉斯维加斯算法"></a>拉斯维加斯算法</h3><p>思想：随机构建一部分答案，然后尝试解出符合要求的结果，若能解出就一定正确。随机构建的部分越多，就越容易进入无解的空间，随机构建越少，搜索解的范围就越广，速度就越慢。</p><p>n皇后问题：先随机摆放一部分皇后，然后求解另一部分</p><p>整数的质因数分解：构建随机数序列相邻2项之差，然后与n求最大公约数（公因数）</p><h3 id="蒙特卡洛方法"><a href="#蒙特卡洛方法" class="headerlink" title="蒙特卡洛方法"></a>蒙特卡洛方法</h3><p><strong>p正确</strong>：一个算法，若在所有情况下，单次运行得到正确解的概率是p，这个p大于0.5，就是p正确。p-0.5称为“优势”</p><p><strong>一致</strong>：若对同一个实例，算法若给出正确解就必定是唯一的解，那么这个算法是一致的（总是给出唯一正确的解）。</p><p><strong>偏真</strong>：对于判断问题，若给出真的时候一定正确，那么就是偏真的。</p><p>思路：若有一个一致的或偏真的算法，且是p正确的，多次调用就一定能减少出错的可能性<br>理解：对真假问题，连续判断为真实际为假的概率极小。对给出解的问题，若只有唯一的正解，运行若干次后正解一定占p的比例，剩下1-p的比例被若干错误解瓜分，显然连续给出同一个错误解的概率就更小了。</p><p><strong>应用：主元素问题</strong>：寻找序列中是否有出现次数大于序列长度的一半的元素，即主元素。显然可以随便选一个元素，然后扫描一遍，可以证明这个方法是有效的。</p><p><strong>应用：素数判定算法</strong>：用必要条件（费马小定理）检测，若检测多次依然正确，则大概率是素数。</p><h2 id="智能随机算法"><a href="#智能随机算法" class="headerlink" title="智能随机算法"></a>智能随机算法</h2><p>模拟退火算法（没展开讲）</p><h2 id="关于OJ1"><a href="#关于OJ1" class="headerlink" title="关于OJ1"></a>关于OJ1</h2><p>蒙特卡洛方法可以用于判断矩阵乘法是否正确，多次运行一个偏假的方法，用于有效简化复杂度。</p>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】算法优化策略</title>
    <link href="/2020/12/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/"/>
    <url>/2020/12/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="算法优化策略"><a href="#算法优化策略" class="headerlink" title="算法优化策略"></a>算法优化策略</h1><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>采用特定存储结构可能带来某一操作更优的性能（比如堆可以直接找到最值，线性表可直接按下标访问）</p><h2 id="时间空间复杂度互换"><a href="#时间空间复杂度互换" class="headerlink" title="时间空间复杂度互换"></a>时间空间复杂度互换</h2><p>若求解较大N时需要用到较小N的结论，则适合顺序求解。将逆序求解改为顺序求解可以极大减少重复计算次数。代价只是存储了多余的结论</p><p>散列，牺牲空间复杂度来换取接近理想的时间复杂度</p><h2 id="算法的组合"><a href="#算法的组合" class="headerlink" title="算法的组合"></a>算法的组合</h2><p>快排改进：当N较小时用插入排序，或者不排序而在最后用一次插入排序。</p><p>非线性方程的求解：大范围用二分法缩小解的范围，小范围用牛顿法、割线法获取更大收敛速度。通常用黄金分割搜索+反二次插值。</p><h2 id="问题预处理"><a href="#问题预处理" class="headerlink" title="问题预处理"></a>问题预处理</h2><p>用数学手段优化：直接给出表达式</p><p>计数排序、KMP算法</p><p><strong>Horspool模式匹配算法</strong></p><p>（有详细解释，待补充）</p>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】非线性方程组</title>
    <link href="/2020/11/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B/"/>
    <url>/2020/11/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="非线性方程组"><a href="#非线性方程组" class="headerlink" title="非线性方程组"></a>非线性方程组</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>病态问题：若函数在零点附近切线接近水平，则求根问题病态：切线y的变化会造成x的剧烈变动。</p><p>收敛速度：假设迭代进行很久以后，每一步迭代的误差都是上一步误差的r阶量，则称为r阶收敛（一阶=线性，二阶=平方，三阶以上=超线性）</p><p>判停：一般通过固定的迭代步数、每一步的误差变化、残差（？）</p><h2 id="非线性方程的解法"><a href="#非线性方程的解法" class="headerlink" title="非线性方程的解法"></a>非线性方程的解法</h2><p><strong>二分法</strong></p><p>条件：需要知道解的区间、方程连续（适用于介值定理）<br>思路：对区间用介值定理不断二分<br>性能：线性收敛，每次迭代增加一个二进制有效位，迭代步数与方程无关<br>缺陷：二分法截止采用两次迭代之差，但是若真值接近0，<strong>则迭代结果只保证绝对精度，无法保证有效数字</strong>，若采用相对误差，则可能会产生除0问题。</p><p><strong>试位法</strong></p><p>条件：与二分法一致<br>思路：将二分法的二分替换为线性拟合：当已知两点符号相反时，可知至少有一个根，然后认为方程就是过这两点的一条直线，计算出直线的零点，代入检验，若不对，则继续细分。<br>性能：因为计算零点时用到了函数的性质，当函数一部分平坦一部分陡峭的时候，收敛会变得非常缓慢</p><p><strong>不动点迭代</strong></p><p>不动点的唯一性：对g(x)=x的理解可以是：当g(x)斜率绝对值不超过1时，g(x)在y=x下面的点不可能跑到上面去，所以必定只有一个分界点。</p><p>不动点法的收敛性：在每一个点作切线，这个切线与y=x形成一个矩形，迭代下一个x只能在矩形内部，且g(x)把长映射到宽，也就是说每次迭代的矩形必定是嵌套的。嵌套有传递性，且嵌套的程度取决于g’(x)，当g’(x)绝对值不逼近1时，逼近每次都有个下界，所以必定能得到结果。</p><p>当|g’(x)|&lt;1不满足时，只能期望迭代后能够进入到满足条件的小矩形中。当g(x)=x不满足条件的区间不够长时（总有收敛区域承接，而不是在两个发散区域内“反射”），就不足以导致发散。</p><p>缺陷：不满足条件时不一定收敛。</p><p>不动点定理也可以用来求收敛性。</p><p><strong>牛顿法</strong></p><p>思路：一种理解是从切线角度理解，即每次迭代都将方程局部近似线性化。另一种是将其理解为规范化的不动点函数，即每次按照一定规则选取不动点函数</p><p>性能：如果收敛，则简单根至少平方收敛，重根线性收敛。不收敛可能有：振荡（两个点之间反复迭代），极小值发散。简单来说就是用不稳定性换收敛速度。</p><p>改进牛顿法：主要针对重根进行改进，构造零点相等的f(x)/f’(x)，将上下的m-1阶极小抵消，就能保证平方收敛。</p><p>改进牛顿法需要事先知道根的阶数。</p><p><strong>割线法</strong></p><p>思路：主要是在牛顿法上改进：将求切线转化为求前2步的点形成的割线，当前两步相差较小时，总能逼近切线。</p><p>性能：收敛阶数1.618，相比牛顿法，放弃了收敛速度换得计算复杂度</p><p><strong>反插法</strong></p><p>思路：在y-x平面上，先测三个点，然后认为非线性方程是三个点拟合出来的二次函数，接着求出交点，继续验证并拟合。为了确保预测的存在性，拟合函数为x=g(y)</p><p>性能：收敛阶数1.839</p><h2 id="解法小结"><a href="#解法小结" class="headerlink" title="解法小结"></a>解法小结</h2><p>所有解法都是利用局部性质或整体性质。当非线性方程连续的时候，它在零点局部有很好的性质，即局部可以线性化，在整体上也有很好的性质，就是介值定理。二分法和试位法是比较保守的思想，就是先确定解的范围，然后高效地“挨个”搜索。不动点迭代利用了函数的性质，在限定条件下适用的较激进解法。牛顿法完全利用局部性质，把局部性质完全套在整体性质上。所以不一定收敛，但是寻找的速度比较快。</p><p>利用局部性质预测，越接近零点预测越准（函数局部线性化），收敛速度就越快。利用整体性质预测，在远离零点的时候也能利用有效信息（符号），但是符号提供的信息有限，收敛速度只有一个整体下界。</p><h2 id="OJ8"><a href="#OJ8" class="headerlink" title="OJ8"></a>OJ8</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>根据文献，采用单隐藏层，300隐藏节点的多层感知机。预处理后可以得到1.6%的错误率。</p><h3 id="样例和通过记录"><a href="#样例和通过记录" class="headerlink" title="样例和通过记录"></a>样例和通过记录</h3><p>样例2，4，7，8，9的样本都小于1000<br>样例1，5，6样本大于1000但是小于3000<br>样例6样本大于1000小于2000<br>样例10样本N=3000<br>样例3样本大于3000</p><p>训练次数6000，能过234789样例，但6一直无法过<br>1，5，10在训练2000次时满足acc小于0.1，但是依然WA,可能是过拟合<br>1，5在训练1000次时通过，<br>样例6数据量在1000到2000之间，样例10<br>训练量2000的时候样例10能过</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>OJ8的主要问题是debug，首先MLP这个东西就充满了不确定性，在此基础之上，网络性能受到多个参数影响，还有潜在的代码错误问题。</p><p>在结构层面上，参考前人所写的结构，这就有了个准确度上限的参照。用MNIST可以忽视数据集的影响：避免样例的过拟合与欠拟合导致的WA。在参数设计上，若MNIST上跑出理想的模型，就只需要根据数据集进行特化的调整。</p><p>可以看出，在NN设计中，一套合理可靠的评价体系直接决定了参数的可靠性和网络的鲁棒性。同时也有一个思路，<strong>就是模仿样例的设计，先从二分类的简单情况开始测试，逐渐过度到多分类情况</strong></p><p>测试结果的图形化表示也是问题。图形化表示有助于找到数据的趋势，同时便于人手动优化参数。<strong>原则上，一切呈现给人的复杂数据都应当是图像化的</strong></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数值计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】线性方程组</title>
    <link href="/2020/11/18/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
    <url>/2020/11/18/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="解线性方程组"><a href="#解线性方程组" class="headerlink" title="解线性方程组"></a>解线性方程组</h1><h2 id="高斯消元法"><a href="#高斯消元法" class="headerlink" title="高斯消元法"></a>高斯消元法</h2><h2 id="OJ7"><a href="#OJ7" class="headerlink" title="OJ7"></a>OJ7</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>a^b=c可以推出a=b^c 由此将线性方程组的加法和减法都映射到异或运算</p><p>两个矩阵：一个点是否使用刷子（矩阵A）和一个点的颜色（矩阵B）</p><p>设前两行是否用刷子为未知量，可以递推求出所有点是否使用刷子的表达式。只要在前两行的每个点作十字，可以发现只有一个位置是不确定的，利用异或性质即可得到方程。</p><p>因为递推式根据前两行的“假设”推出A的所有点，每一行的假设都可以让向前第二行的假设符合实际，所以最后两行的假设应当根据实际情况验证。</p><p>因为总共2N个变量，恰好最后也是2N个点，而且用上了全部的数据，必定能得到满秩矩阵</p><p>推表达式时，每个点最多用2N+1个变量表示，需要存储全部节点，因为最后输出矩阵时需要用全部数据来计算</p><p>空间复杂度：O(10N^2), 100行数据大约需要10^5bit,也就是12KB</p><p>最后的表达式也是2N个方程，每个方程用一个2N+1大的数组存储，总空间复杂度在一个量级。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>创建了一个MatA，最后一列是常数列，这样就能直接算得结果</p><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p><strong>样例1</strong></p><p>5 5<br>0 0 1 0 0<br>0 0 1 0 0<br>1 1 1 1 1<br>0 0 1 0 0<br>0 0 1 0 0</p>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】数值计算</title>
    <link href="/2020/11/10/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"/>
    <url>/2020/11/10/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>适定/不适定问题：给定条件是否能求出唯一的、稳定的、连续依赖于条件的解</p><p>病态问题：条件的微小波动导致解的极大波动，就是病态的</p><p>有效数字：绝对误差小于0.05，则精确到小数点后1位，即0.1,有效数字是从0.1开始（包括0.1）向前的数字（开头0.00的部分不算）</p><p>截断误差：算法层面上，无限求和截断成有限求和，无限细分近似有限细分而产生的误差</p><p>舍入误差：计算层面上，无限精度小数舍入为有限精度得到的误差</p><p><strong>截断误差与舍入误差相互制约</strong>：在求导这种上下取极限的操作上，差分间隔h越细，理论上算法的精度就越接近真实的结果，截断误差就越小，但是差分间隔越细，上下的数就越小，小数点N位后细微的舍入误差的占比就越大，所以结果由舍入误差带来的偏差就越大。</p><p>向后误差：f(x)相等时x的误差；向前误差：x相等时f(x)的误差</p><p>条件数：用向前误差和向后误差估计得到解对初值的敏感程度</p><p>舍入原则：就近舍入和最近舍入，是两种用浮点数表示一个真实数的近似策略</p><h2 id="机器计算的误差分析"><a href="#机器计算的误差分析" class="headerlink" title="机器计算的误差分析"></a>机器计算的误差分析</h2><p><strong>抵消：大数相减</strong></p><p>大数相减，尾数的有效数字就减少。只能避免这种情况的发生</p><p><strong>大数加减小数，完全丢失</strong></p><p>浮点数加减过程中，要先统一指数部分，这就会让小数的有效数字几乎全部丢失</p><hr>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数值计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】单源最短路径dijkstra算法</title>
    <link href="/2020/11/08/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84dijkstra%E7%AE%97%E6%B3%95/"/>
    <url>/2020/11/08/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84dijkstra%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="dijkstra算法以及第七周OJ"><a href="#dijkstra算法以及第七周OJ" class="headerlink" title="dijkstra算法以及第七周OJ"></a>dijkstra算法以及第七周OJ</h1><h2 id="dijkstra算法理解"><a href="#dijkstra算法理解" class="headerlink" title="dijkstra算法理解"></a>dijkstra算法理解</h2><h3 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h3><p>运行一次dijkstra算法只能求出给定点到图中所有点的最短距离以及最短路径。</p><p>假设一个顶点数为n、边数为e的图，需要两张表：第一张表大小为n，<strong>记录给定点到图中所有点的最短路径</strong>，这张表在过程中会不断更新；第二张表是最短路径树SPT，在单源情况下，这个树只是从起点到n个节点的二层带权n叉树，被添加的最短路径都是确定的路径，不会被更改。</p><p>首先更新最短路径表，只将起点的邻接点更新到表中，其余置INF(无穷大)。</p><p>每一步开始时，先考察最短路径表中还没确定的点，也就是SPT以外的点，访问其中最短距离对应的点B，<strong>这个点是不确定点中最短的一条，对所有路径，它们只能从A出发，而表中至少包含A所有的邻接点的路径，任何从A到B的点的路径都至少有一段被包含在表中，也就是任何可能路径都不会比表中最短路径还要短</strong>，我们找的这个B恰好能利用这个信息：全图任何从A到B的可能路径，都不会比表中最短路径（一个从A到B的路径）短，那么表中的最短路径就是全图上的最短路径。</p><p>每一步结束时，总能得到一个B，将这个B添加到SPT中。然后要用B更新最短路径表：因为B已经被加在了SPT中，所以必须添加新的备选最短路径使得最短路径表中总能找到新的最短路径，而这个添加过程就引入了所有与B相关的路径：</p><p>假设其他路径都不是最短路径，那么B更新了邻接点后，必然会更新到最短路径：<strong>这是因为，假设路径表中有一条n+1步的路径，那么它包含的n步的路径必定是最短路径，否则它不会被更新到。当所有与SPT的邻接点都被更新到最短路径表中时，假设一个路径是到达邻接点的最短路径，那么它后退一步的路径必然是最短路径，我们已知这样的路径的所有邻接点都被更新，那么这个路径必然被包含在表中</strong></p><p>每次更新可能更新多个最短路径，但是每次只接收一个。</p><h3 id="优化策略：配对堆"><a href="#优化策略：配对堆" class="headerlink" title="优化策略：配对堆"></a>优化策略：配对堆</h3><p>见堆相关blog</p><p><strong>顶点查找</strong></p><p>利用dijkstra算法运行中不会扩增线性表的特点，构建堆的时候，只改变每个节点的指针，不改变节点存储的位置。也就是依然可以用下标搜索到特定node，然后搜索到其邻接表.虽然node不存储自身位置，但是可以取地址相减获得序号</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><strong>时间复杂度</strong></p><p>因为每次SPT只增加一个点，所以必定要迭代n次，每次迭代的耗时分析：</p><ol><li>要找到路径表中除了SPT以外的点的最短路径</li><li>将其添加到SPT中，并更新路径表中邻接节点的路径<br>如果我们用配对堆维护最小路径，每次取出堆顶是O(logn)的耗时，但每次更新路径是O(1)的操作，所以总耗时是O(nlogn + e)<br>对于稀疏图，用邻接表存储，查找邻接节点就是O(1)，总共需要O(e)次，不影响复杂度</li></ol><p><strong>空间复杂度</strong></p><p>SPT需要空间为n，建堆空间为n，最短路径表的空间为n（单源）</p><h2 id="OJ分析"><a href="#OJ分析" class="headerlink" title="OJ分析"></a>OJ分析</h2><p>OJ的问题主要在于：找所有最小路径数和空白区域划分。</p><h3 id="路径记录"><a href="#路径记录" class="headerlink" title="路径记录"></a>路径记录</h3><p><strong>根据最短路径的各个子路径也一定是最短路径</strong>的原理，只需要记录每个点到A点的最短路径的前一个点即可，在更新路径的时候，如果待更新路径与原路径相等，那么就同时记录两个点，所需空间复杂度就是邻接表的复杂度，即O(e)</p><h3 id="零权重分布"><a href="#零权重分布" class="headerlink" title="零权重分布"></a>零权重分布</h3><p>一个思路：例如给定10个置0权重，就构建10层的图，每层图都一样，但是层之间的路径是单向的：<strong>第一层的A节点用有向的0权重连接到第二层的A的邻接点</strong>，也就是说，算法可以选择在第一层到达终点，也可以选择通过0权重到达第二层，但是每次上升就无法下降，<strong>将二维图扩展到3维，就覆盖了所有可能的置0路线</strong></p><p>但是也有不严谨的地方：如果路径长度比置0数还要短，最短路径就是0，此时这个长度就没有用上。</p><h3 id="零权重复杂度分析"><a href="#零权重复杂度分析" class="headerlink" title="零权重复杂度分析"></a>零权重复杂度分析</h3><p>将倍数代入复杂度，log(aN)被线性化，而ae也是线性增长的，因此整个时间复杂度增长速度近似线性增长。</p><p>因为每层图都是一样的，0权重连接也可以通过邻接表查询到，所以权重存储空间与a无关。最短路径表和SPT会增长到aN，在第一次检测后，将最短距离减去最大权重依然大于当前最短距离的点看作不存在，当需要检测A层时，只需要存储可能经过的点的位置。</p><p>也可以同时以起点和终点进行2次最短路径检测，然后对每一条边进行比对，就可以得到经过某条边到达终点的路径长度，如果大于最小路径减去最大权重的a倍，就删掉该条边（一定不会经过这条边），然后再删除孤立点</p><h3 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h3><p><strong>样例1</strong><br>8 8 1<br>1 2 1<br>1 3 1<br>2 4 1<br>3 4 1<br>4 5 1<br>4 6 1<br>6 7 1<br>5 7 1<br>1 7</p><p>输出 3 16</p><p><strong>样例2</strong></p><p>8 9 0<br>0 1 1<br>1 3 2<br>1 5 1<br>1 2 1<br>3 4 3<br>4 2 0<br>2 5 1<br>4 5 1<br>0 3 1<br>3 2</p><p><strong>样例3</strong></p><p>8 8 0<br>1 2 1<br>1 3 1<br>2 4 1<br>3 4 1<br>4 5 1<br>4 6 1<br>6 7 1<br>5 7 1<br>1 7</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>马恩选集笔记：社会主义从空想到科学的发展</title>
    <link href="/2020/11/08/%E9%A9%AC%E6%81%A9%E9%80%89%E9%9B%86%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E4%BB%8E%E7%A9%BA%E6%83%B3%E5%88%B0%E7%A7%91%E5%AD%A6%E7%9A%84%E5%8F%91%E5%B1%95/"/>
    <url>/2020/11/08/%E9%A9%AC%E6%81%A9%E9%80%89%E9%9B%86%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E4%BB%8E%E7%A9%BA%E6%83%B3%E5%88%B0%E7%A7%91%E5%AD%A6%E7%9A%84%E5%8F%91%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="社会主义从空想到科学的发展"><a href="#社会主义从空想到科学的发展" class="headerlink" title="社会主义从空想到科学的发展"></a>社会主义从空想到科学的发展</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><blockquote><p>不能把思想同思维着的物质分开</p></blockquote><p>人可以假定上帝存在、思想存在，但是思想和上帝都是观测不到实体的，那么思想是否可以独立于肉体存在呢？诚然我们有抽象的思想概念，但它只存在于“人”的印象中，而不能被科学地观测到。同命运、上帝一样，不可知的东西是不能在其上构建理论的。</p><blockquote><p>不可知论断言人的认识能力不能超出感觉经验或现象的范围，不能认识事物的本质及发展规律。</p></blockquote><p>不可知论本身论述的证明或证伪都可以用其循环的逻辑解释，核心在于“XX是否是事物的本质及发展规律”这个命题无法证实或证伪，这就与科学有根本的区别。</p><p>当然可以继续对“科学”这种概念进行质疑，这样质疑下去可以对所有概念是否有意义提出怀疑，甚至可以对“无法证实且无法证伪”这一论断进行怀疑。在这个问题上，<strong>需要一些无理由也不需要理由的假设</strong>，这里假设值得研究的范围仅限于与人所感受的现实相关的东西，也就是：</p><blockquote><p>可是，如果我们达到了我们的目的，发现事物符合我们关于该事物的观念，并产生我们所预期的效果，这就肯定地证明，在这一范围内，我们对事物及其特性的知觉符合存在于我们之外的现实</p></blockquote><p>所谓“经世济用”并不排斥抽象物，而是排斥不能证明也不能证否的、与其他物没有关联的抽象物。再此基础上利用推理、验证等手段可以证明一些感知是否正确，也就可以认为认识到了事物的“客观本性”</p><blockquote><p>这种观点认为，一切重要历史事件的终极原因和伟大动力是社会的经济发展，是生产方式和交换方式的改变，是由此产生的社会之划分为不同的阶级，是这些阶级彼此之间的斗争。</p></blockquote><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><blockquote><p>在形而上学者看来，事物及其在思想上的反映即概念，是孤立 的、应当逐个地和分别地加以考察的、固定的、僵硬的、一成不变的研究对象。</p></blockquote><p>静止不光是运动的一部分，实际上绝对的静止是不存在的，这就和运动有相当大的区别：绝对的静止并不存在，所以以静止为前提研究得出的结论就可能带有一些“未可知”的成分。</p><blockquote><p>辩证法在考察事物及其在观念上的反映时，本质上是从它们的联系、它们的联结、它们的运动、它们的产生和消逝方面去考察的。</p></blockquote><p>这类似于黑箱的概念，事物的联系也就是人接触事物的途径，如果两个事物在人所能观察到的范围内都是一致的，那么这两个事物应当被看作同一事物。而人赋予的名字等都是符号，没有额外的内涵。</p><p><strong>唯心主义</strong></p><blockquote><p>客观唯心主义认为，在现实世界之外独立存在着一种客观精神，它是世界的本源，世界万物是由它产生（派生）出来的。其著名代表人物，有中国的朱熹、古希腊的柏拉图和德国的黑格尔等。</p></blockquote><blockquote><p>主观唯心主义是把人的主观精神（意识、观念等）作为认识世界的出发点，存在主观精神之中的是认知上的世界，是主观精神的产物，而并非真正客观上的世界。主要代表人物，有中国的陆九渊和王守仁，和德国的费希特等。</p></blockquote><p>极端唯心主义可以称为唯我主义。唯心和唯物的根本分歧在于物质和精神哪个是第一性质，哪个是第二性质。</p><p>从唯物主义角度解释精神，可以解释为一种局部混沌、整体却有规律的大脑活动。不同于机械决定论的观点，脑的活动是无法预知的，但这和不可知论者的观点又有区别：脑的活动尽管无法预知，但是精神实在地影响了客观世界，精神的存在是可以验证的，又因为不在不可知的领域构建理论，这里应当排除第一性的精神，于是唯物主义与唯心主义的对立就成立了。</p><h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><blockquote><p>以往的全部历史，除原始状态外，都是阶级斗争的历史；这些 互相斗争的社会阶级在任何时候都是生产关系和交换关系的产 物，一句话，都是自己时代的经济关系的产物。</p></blockquote><p>阶级当然存在于历史中，但是不能这样就论断是“阶级斗争的历史”。在研究历史发展的规律的时候，历史中的各个事件是不等权的，这种权重变化是人赋予历史的而不是历史自身的属性。从客观上来讲，一场雨和一场革命没有区别，只是前者充满偶然性，后者暗含历史必然规律。</p><p>这里我倾向于认为：阶级斗争在历史发展中有其必然规律，因此从实用的角度，可以解释为“阶级斗争的历史”。</p><h2 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h2><blockquote><p>唯物主义历史观从下述原理出发：生产以及随生产而来的产品交换是一切社会制度的基础；在每个历史地出现的社会中，产品分配以及和它相伴随的社会之划分为阶级或等级，是由生产什么、怎样生产以及怎样交换产品来决定的。</p></blockquote><p>历史规律必然要排除偶然性，即研究群体性的东西。可以假定每个时代的“人”作为一种生物是基本不变的，古代人放到现代社会经过现代化教育也与现代人无差异。那么个体的因素不变，个体差异又被抹去，只剩下个体之间的联系，即群体性的东西。</p><p>先承认一种稳定性假设：大多数人没有足够的时间和精力在一生中同时从事很多层面的工作。在货币发挥作用的时代，生产和交换确实是社会制度的分类依据，但是如果没有货币呢？</p><p>可以假设人们不需要衡量不同物品间的价值，也不能用一个物品与另一个物品交换。可一定要面对物质需求不能满足人们需要的情况，这就要求物质需求极大满足。或者是在赛博空间中得以实现。</p><blockquote><p>一部分人的过度劳动成了另一部分人失业的前提</p></blockquote><p>推理过程如下：机器生产让劳动力多出来，但是机器生产的东西却需要所有人都消费，于是这些人就变成了“后备军”，此时生产对劳动力的需求大于市场对消费者的需求，劳动力永远是过剩的，而消费者永远是欠缺的。这就导致两个情况：劳动力互相挤压工资，也就是内卷化，和商品滞销，也就是市场经济萎靡。</p><blockquote><p>我们已经看到，现代机器的已经达到极高程度的改进的可能 性，怎样由于社会中的生产无政府状态而变成一种迫使各个工业 资本家不断改进自己的机器、不断提高机器的生产能力的强制性 命令。</p></blockquote><p>在买方市场下，生产产品质量越好、规模越大越能盈利，从而越能提升机器效能。通过交易的形式，资本环境下的优胜劣汰完全由盈利决定，于是发展到最终的企业一定是盈利效果最好的企业：对于劳动力市场，必须提高员工可替代性，让每个员工成为“螺丝钉”，从而最大化利用劳动力市场压低劳动力价格；其次，对于消费者市场，必须对市场进行垄断从而让消费者只能购买其产品。企业的扩大生产只是加剧了整个周期的进行速度。</p><blockquote><p>在危机中，社会化生产和资本主义占有之间的矛盾剧烈地爆发出来。商品流通暂时停顿下来；流通手段即货币成为流通的障碍；商品生产和商品流通的一切规律都颠倒过来了。经济的冲突达到了顶点：<strong>生产方式起来反对交换方式</strong>。</p></blockquote><p>生产方式指工厂机器生产，交换方式指商品交换。机器生产使得少部分人获得大部分利润，交换方式使得大部分人需要提供大部分的消费，显然两者是冲突的。</p><blockquote><p>支配商品生产的规律日益显露出来，它们的作用日益加强。竞争不可遏止。个别工厂中的社会化组织和整个生产中的社会无政府状态相矛盾</p></blockquote><blockquote><p>机构和交通机构起初由股份公司占有，后来由托拉斯占有，然后又由国家占有。资产阶级表明自己已成为多余的阶级；它的全部社会职能现在由领工薪的职员来执行了</p></blockquote><blockquote><p>无产阶级将取得公共权力，并且利用这个权力把脱离资产阶级掌握的社会化生产资料变为公共财产。</p></blockquote><p>这是恩格斯总结的历史发展规律，但是无产阶级取得公共权力的过程说的不是很清楚：从股份公司发展到托拉斯这一步可以在完全竞争的理想化市场下实现，如互联网公司的兼并最终形成少数“大厂”，从托拉斯到国家的这一步就不是很明显。改革开放的原因就是要促进经济活力，如果大公司集体转编制，宏观上的体现就是回归计划经济时代，人人大锅饭使得每个人劳作意愿下降。</p><p>应当看到国家与个人之间平衡是在各层次权力的博弈中达到稳定的。如果阶级对立消失，<strong>个人与社会的矛盾是否会代替阶级之间的矛盾成为新的社会冲突点？</strong>。如果结团体的利益高于保持个体的利益，社会会朝着阶级化的方向前进。反之，社会关系会逐渐原子化，回归到个体与个体间的关系。</p><p>如果人人都能“不劳而获”，那么势必大多数人都不会劳动，拿低保度日。下面是关于北欧高福利制度的介绍</p><p><strong>北欧高福利制度的支撑</strong></p><p>来源：<a href="https://www.zhihu.com/question/58173613/answer/676810895" target="_blank" rel="noopener">https://www.zhihu.com/question/58173613/answer/676810895</a></p><blockquote><p>聚焦高附加值，低发展速度产业</p></blockquote><p>这一条是基本的：高附加值理论上可以带来高社会福利，低发展速度代表可以“吃老本”而不用担心996.<strong>丹麦发展畜牧业、生物制药、基础材料、艺术设计</strong></p><blockquote><p>他们得以保持竞争力的，往往已经不是难以逾越的“绝对技术壁垒”，而是以用“低市场增长”（而且大部分行业市场也不大）+“较高技术门槛”成的一圈“黑域”</p></blockquote><p>市场太小决定了北欧的高福利制度是不可大范围推广的，这种高技术门槛、低市场增长的产业不会太大，就比如圆珠笔芯这个产业。之所以没有后来者愿意跟进，是因为这些产业拥有十足的<strong>先发者优势</strong>，先积累的排斥后积累的，加上自身获利实在不多，因此得以保全。</p><blockquote><p>只要社会总劳动所提供的产品除了满足社会全体成员最起码的生活需要以外只有少量剩余，就是说，只要劳动还占去社会大多数成员的全部或几乎全部时间，这个社会就必然划分为阶级。</p></blockquote><p>劳动时间与生产力发展在现阶段不一定有直接联系：互联网行业是先进生产力，但是员工依然996。在现在生产力比较发达的时代，为了维持金融体系稳定，大量时间被用于偿还过去的借债。比如说房地产行业，大量卖地资金由百姓承担，相当于政府向人民借钱发展经济，而且地价提升带来买房刚性需求受阻，大多数人被迫为了房贷工作。</p><p>当人民无法享受到生产力发展带来的物质丰富时，劳动时间也就无法随着生产力发展而下降。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【算法】堆</title>
    <link href="/2020/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%A0%86/"/>
    <url>/2020/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="堆的分类"><a href="#堆的分类" class="headerlink" title="堆的分类"></a>堆的分类</h2><p>大根堆指堆顶是最大元素，小根堆指堆顶是最小元素。但是两者都要求数据以有序的结构存储、读取，这个结构就是根节点与子节点的大小关系一致。</p><h2 id="自底而上建立堆"><a href="#自底而上建立堆" class="headerlink" title="自底而上建立堆"></a>自底而上建立堆</h2><p>首先将存储数据的一维数组看作一个完全二叉树，然后从右向左，从叶子节点开始遍历，<strong>因为完全二叉树的存储位置都是固定的，所以每次排序可以O(1)地搜索到位置</strong>，同时因为每次排序时都将数组后面的元素调整到前面，所以只需一次遍历即可构建堆，复杂度O(n)</p><h1 id="配对堆"><a href="#配对堆" class="headerlink" title="配对堆"></a>配对堆</h1><h2 id="原理简述"><a href="#原理简述" class="headerlink" title="原理简述"></a>原理简述</h2><p>配对堆用指针的方式将一个复杂结构线性化存储到内存中。一个节点包含3个指针，一个指向第一个孩子，一个指向左侧兄弟（最左侧的指向父亲），一个指向右侧兄弟。</p><h2 id="操作简述"><a href="#操作简述" class="headerlink" title="操作简述"></a>操作简述</h2><p><strong>查找最小值</strong></p><p>对于小根堆，返回堆顶即可，复杂度O(1)</p><p><strong>合并两个堆</strong></p><p>合并到根节点，对于小根堆，将较小的根作为合并后的根，只需要拉一根线（指针）即可，复杂度O(1)</p><p><strong>插入</strong></p><p>插入也是插入到根节点，同理，O(1)</p><p><strong>decrease-key（修改节点并重新调整）</strong></p><p>decrease指的是修改一般是往堆顶的方向修改，即只会增大/减小。修改方法是将其与父节点的连接断开，然后将其作为新节点添加到根节点处。</p><p><strong>删除堆顶</strong></p><p>删除堆顶是为了取出最小值，这也是堆的限制：只能从堆顶删除，从而便于单一地维护堆结构。为了重新构建新堆，删除后会剩下若干子堆，将它们先两个两个合并，然后再对合并后的堆进行合并，直到所有节点都合并到根节点为止。</p><p>合并的总次数可能会退化到O(n)，但如果配对堆的结构保持住，就是O(logn)的复杂度</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>删除堆顶的操作平摊复杂度是O(logn)，修改节点操作认为是O(loglogn)，在n不很大的时候都可以看作常数。</p><h2 id="实现简述"><a href="#实现简述" class="headerlink" title="实现简述"></a>实现简述</h2><p>自底而上构建堆即采用完全二叉树的方式，此时数据是顺序存储的，但是多叉树必定是乱序的，因此需要用3个指针，确保同层兄弟互相指向，同父节点至少一个指向父亲，且父亲指向第一个儿子。</p><p>在修改节点的时候，源数据的位置并不会变，只是指针会变。<strong>这就要求源数据在第一次建堆以后不能添加新值，只能修改和删除</strong></p><p>在修改节点时，若删除的是第一个儿子，就需要同时修改父亲处的指针，因为第一个儿子与父亲是双向连接的，所以容易修改。若修改非第一个儿子，则需要将左右兄弟连接，这也是O(1)的。</p>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】递归与递归消去</title>
    <link href="/2020/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E5%BD%92%E6%B6%88%E5%8E%BB/"/>
    <url>/2020/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E5%BD%92%E6%B6%88%E5%8E%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="递归与递归消去"><a href="#递归与递归消去" class="headerlink" title="递归与递归消去"></a>递归与递归消去</h1><h2 id="递归的复杂度"><a href="#递归的复杂度" class="headerlink" title="递归的复杂度"></a>递归的复杂度</h2><p> 当调用栈较多时，对栈空间的影响较大，同时调用栈也有时间花销。</p><p> 当重复计算某些问题时（菲波纳契数列），递归不能利用已知的问题的解，时间复杂度与非递归算法有本质上的差异。</p><h2 id="消除递归"><a href="#消除递归" class="headerlink" title="消除递归"></a>消除递归</h2><p> 尾递归可以直接用循环代替，减小栈空间开销。</p><p> 对非尾递归的情况，可以显性模拟一个递归调用栈，然后进行结构上的优化。</p>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】线性表</title>
    <link href="/2020/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2020/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="分类和概念介绍"><a href="#分类和概念介绍" class="headerlink" title="分类和概念介绍"></a>分类和概念介绍</h2><p>队列分为顺序队列、循环队列、链式队列，没有本质区别。两者都实现的是：<strong>存储了入队操作顺序，实现先进先出</strong>，结构上，队列有个头指针和尾指针，有入队和出队操作，为了在有限的空间上实现不限次的入队出队操作，必须使得队列元素前后顺序与存储顺序无关，所以引入循环队列（虚拟一个循环的空间）和链式队列（在存储位置上离散化）。</p><p><strong>优先级队列</strong></p><p>优先级队列给每个点定义一个优先级，入队没有变化，优先级高的先出队。<strong>因为线性存储结构只能存放局部信息，所以无法实现全局范围内优先级的自动查找</strong>，无论用有序/无序、链表/顺序表，都至少在一个操作上有O(N)的复杂度。</p><h1 id="线性表的应用"><a href="#线性表的应用" class="headerlink" title="线性表的应用"></a>线性表的应用</h1><h2 id="栈实现自然表达式运算"><a href="#栈实现自然表达式运算" class="headerlink" title="栈实现自然表达式运算"></a>栈实现自然表达式运算</h2><p>由两个栈组成：一个符号栈，一个操作数栈。</p><p>实现原理：<strong>从左往右检测，当后一个运算符比前一个运算符等级低的时候，必定可以先对前面计算</strong></p><p>为了确保每一个高优先级运算符都能检测到一个低优先级运算符，将结尾加一个符号<code>;</code>来通知截止。</p><p>所有运算表达式都存在一个第一个计算的位置，这个位置有如下规律：操作数优先级一定不低于右边，否则右边先计算；操作数优先级一定高于左边，否则左边先计算。</p><p>在运算表达式中，只要先计算这样的位置，就一定能符合运算顺序。因此入栈时先比对进入的是否高于左边，高于左边才入栈，否则当前元素就满足栈顶元素的“右边”，栈顶先计算。</p><p>另外，括号的表达式应当尽量低，这是因为括号给定了一个局部最低优先级，使得其内部的数只能先计算再与括号计算。括号本身的计算就是消去，对结果无影响，其低优先级的特性才对运算顺序有影响。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>线性表反映的是一种时间复杂度和空间复杂度交换的技术。当我们预设一种存储方式，就在其中包含了一维的存储信息。用链表的方式实现O(1)的相邻信息存储；用顺序表的方式实现O(1)的随机读取；用队列实现先进先出的顺序；用栈实现后进先出的顺序。</p>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】字符串查找KMP算法</title>
    <link href="/2020/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BEKMP%E7%AE%97%E6%B3%95/"/>
    <url>/2020/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BEKMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><p>为了解决重复配对问题，KMP算法的思路就是<strong>利用子串的信息，每次匹配让子串移动最大的距离</strong>。</p><p>这就涉及到如何不重复：<strong>先找出模式串（用来比对的子串）每个位置上往前读的最长相等后缀，这个相等是与从一开始往后读的进行比较</strong>, 那么比对第一位就失败，就移动一位；如果比对K位的时候失败，就找K位前的字符串是否能作为开头，预处理已经对每一位这样的情况进行了分析，现在用的时候就不需要重复比对，节省了时间。</p><p>预处理中，记开头比对的地方为i，对于j位的匹配，它前面j-1位的匹配最长长度已经知道了，只要将i往后移一位就可以知道j位是否还匹配。如果匹配就继续移，如果不匹配，那么检查一下前面可能匹配的点，注意此时i不动，i前面的串和j前面的一致，而j前面的串又和j-1的最大匹配串一致，所以去找前面还有没有可能匹配上的，如果没有，就迅速跳转到第一位，重新开始比对。</p><p><strong>解释2</strong></p><p>1.next函数：开始的n[i]的值就是匹配的最大长度，所以一定是准确的。遇到j处失配的时候，j前面的匹配串一定都被计算完了，且j-1处还是与i-1处匹配，j-1处最大匹配长度是nxt[j-1]，而nxt[j-1]也是相等的字符串在开头的结束位置，所以要跳转到nxt[j-1]，就是跳转到下一个可能相同的匹配点，再去看能不能作为i处的匹配点。当跳转到j=0的时候依然找不到，就只能认为i处无法匹配，所以n[i++]=0，注意i++是先返回再加1<br>2.KMP函数：j是子串P的比对点，i是父串T的比对点，当j失配时，j前面的都没失配，所以找到nxt[j-1]的位置，这个位置是j能左移的最大位置：满足左移后仍然有nxt[j-1]个点匹配，然后继续检测i。如果j移到0处依然不能匹配，就说明i处无法匹配了，只能从i+1处继续从头比对。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>比对一次，失配，子串滑过一段距离，下一次比对如果再失配，子串已经把最大可“滑”距离用完了，无法再移动，就只能换下一个位置比对，所以每个点最多比对2次。预处理中，检查匹配只需要检查一次，如果不行就从开头比对，每个点最多比对2次，因此复杂度是2m,总时间复杂度为O(m+n)</p>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>马恩选集笔记：关于费尔巴哈的提纲</title>
    <link href="/2020/10/05/%E9%A9%AC%E6%81%A9%E9%80%89%E9%9B%86%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%85%B3%E4%BA%8E%E8%B4%B9%E5%B0%94%E5%B7%B4%E5%93%88%E7%9A%84%E6%8F%90%E7%BA%B2/"/>
    <url>/2020/10/05/%E9%A9%AC%E6%81%A9%E9%80%89%E9%9B%86%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%85%B3%E4%BA%8E%E8%B4%B9%E5%B0%94%E5%B7%B4%E5%93%88%E7%9A%84%E6%8F%90%E7%BA%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="关于费尔巴哈的提纲"><a href="#关于费尔巴哈的提纲" class="headerlink" title="关于费尔巴哈的提纲"></a>关于费尔巴哈的提纲</h1><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><blockquote><p>人的思维是否具有客观的真理性，这不是一个理论的问题，而是一个实践的问题</p></blockquote><p>这个论述强调的核心是基于现实而非理念上的唯物主义。从现实来说，讨论“理想”的人是没有意义的，因为理论的东西无法干涉现实。相反，<strong>讨论现实中人的思维是否具有理想的真理性是有意义的</strong>，因为这个基础是现实的人，也就有了现实的作用。因此这个问题是实践的，也就是需要在现实中寻找答案的。</p><blockquote><p>关于环境和教育起改变作用的唯物主义学说忘记了：环境是由人来改变的，而教育者本人一定是受教育的。因此，这种学说必然会把社会分成两部分，其中一部分凌驾于社会之上。</p></blockquote><p>这是在其理论中剥离出“理念”的部分。不存在脱离于现实的环境和教育，也就不存在理想化的、理念的环境与教育，这势必造成环境和教育与人互相作用，甚至不能把它单独看作一个独立于人的客体来研究。</p><blockquote><p>他(费尔巴哈)做的工作是把宗教世界归结于它的世俗基础。</p></blockquote><p>马克思否认宗教世界理念的存在性，这个和费尔巴哈是一致的，但是马克思又认为宗教世界是世俗基础自身的异化，也可以说是世俗世界选择的分裂。因此宗教世界也不是和世俗世界并列的东西，而是被包括在内的。</p><blockquote><p>他把感性不是看做实践的、人的感性的活动。</p></blockquote><p>感性的意思大概是人的感知，这是被自然地包括在实践中去了，而不是单独地抽象出一个过程。</p><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><p>实践本质论虽然有进步意义，但是依然有缺陷：在实践之前，世界就没有本质了吗？为了建立宏观的结构体系，我们必须做出很多基本的、无需认证的假设，比如说一个理论必须逻辑自恰等，否则就会陷入虚无主义而无法开展研究。我认为所有理论应当有一个“经世济用”的假设，也就是说，不包含任何不可知的、形而上的东西，且不做出任何从概念到概念的论证，因为这些论证都是对实践无帮助的。相反，可以做出从概念到概念的总结，与论证不同，总结能让人更加深入地把握一个理论，具有实用的价值。</p><p>对于实践本质论，我提出几个问题：实践的定义是什么？本质是否是永恒不变的？实践本质论是可知的吗？</p><p>第一个问题涉及到语言的模糊性，一个例子是特修斯之船，深究下去，“实践”的范围是不清楚的，这就意味着一部分行为是处于模糊状态，而这部分行为是否是本质呢？本质也是没有明确标准的。事实上，所有试图在现实世界中寻找标准，也就是永恒真理的尝试，都不可能取得成功。<strong>人处在现实之内，不可能触摸到脱离现实的任何东西、概念、形体，那么因果、标准、逻辑、道德是否存在，对人而言都是可以随意假设的。</strong></p><p>关键在于，人所研究的理论应当是经世济用的理论，这个动力是先验的、无理由的。在此基础上提出认识世界的逻辑：</p><p>首先肯定客观世界的存在，否则无法将诸多规律独立于主体之外，规律也就失去效用。然后承认逻辑自恰的标准，这也是规律能够存在的条件之一。最后将若干规律视为“公理”，即无法验证真伪，但是又在当前视角下符合现实情况的规律。这些规律是不需要理由证明的，也是无法证明的。</p><p><strong>此时可以归纳地说：实践是本质的</strong>，这个结论建立在上述不需要理由的假设上，本身是上述结论的总结，不能作为其他结论的理由，也不应该作为其他结论的理由。</p><p>实践的本质性在于，所有公理依靠实践检验，一旦没有经世济用的作用，公理就失去意义。只要承认经世济用的前提，公理本身不应被人作为独立于客观世界的存在，此时公理就脱离了实践。</p><p>此时再来看“实践”和“本质”定义的模糊性：这两个词是总结性的，但是不能作为原因，这个结论存在的前提是这种解释能够达成特定的效用，也就是它所总结的规律是有效的，而就其本身的范围，实践的范围当然包括很多模糊的东西，但这并不影响它的正确性：<strong>不存在某个真理要求一个结论必须是逻辑自恰的，对于总结性的结论，只要它能单向地包括所指的性质（或者只是大部分性质），就可以说它拥有了实践上的意义</strong></p>]]></content>
    
    
    <categories>
      
      <category>哲学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>马克思</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【读书笔记】算法导论</title>
    <link href="/2020/10/04/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    <url>/2020/10/04/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="算法导论-读书笔记"><a href="#算法导论-读书笔记" class="headerlink" title="算法导论-读书笔记"></a>算法导论-读书笔记</h1><h2 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h2><p>在写OJ的时候发现自己对算法的理解相当不足，遂产生系统地学习算法的想法。这本书相当厚，在第一遍看的时候一定没法做到每道题都写完并且AC。我试想在阅读的过程中总结那些新的、巧妙的设计思想，也就是脱离编程语言的、脱离具体问题的一些普适性的算法设计和优化思路。所以在记录的时候也不会具体到某一道题，<strong>而是着重分析算法对现实世界的抽象原则以及优化思路</strong>，当然一些典型问题会记下用于解释说明。</p><p>因为不涉及具体的解题实践，这种练习被移到OJ中完成。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>一般来说，对于四则运算、数据移动、条件判断、方法调用这些指令，都是需要常量时间完成的。如果涉及内存数据的存储，那么存储花费的时间可能远多余计算所用时间。</p><p>一些指令在特定条件下会被简化：如幂乘运算在用移位法乘2的n次方的时候只需要常量时间。</p><p>一般只分析最坏情况，因为最坏情况通常和平均情况相差不大，且有时候经常出现最坏情况（数据库查找不存在的数据）</p><h2 id="分冶法：将大规模问题拆分成小规模问题"><a href="#分冶法：将大规模问题拆分成小规模问题" class="headerlink" title="分冶法：将大规模问题拆分成小规模问题"></a>分冶法：将大规模问题拆分成小规模问题</h2><h3 id="分解，解决，合并"><a href="#分解，解决，合并" class="headerlink" title="分解，解决，合并"></a>分解，解决，合并</h3><p>分冶法使用有些条件：</p><ol><li>所拆分的问题必须是独立的，互相不能依赖</li><li>子问题和母问题之间是线性组合的关系，这样能在O(N)的时间内从子问题的解得到母问题的解。</li><li>子问题和母问题必须能用同一形式表述，可以用统一的方法解决。</li></ol><p>需要处理的有两种情况：递归情况和基本情况，分别对应递归方法的继续递归选择和返回值选择。</p><h3 id="主方法求递归式的时间复杂度"><a href="#主方法求递归式的时间复杂度" class="headerlink" title="主方法求递归式的时间复杂度"></a>主方法求递归式的时间复杂度</h3><h3 id="矩阵乘法的Strassen算法"><a href="#矩阵乘法的Strassen算法" class="headerlink" title="矩阵乘法的Strassen算法"></a>矩阵乘法的Strassen算法</h3><h2 id="贪心法："><a href="#贪心法：" class="headerlink" title="贪心法："></a>贪心法：</h2><h3 id="最大子数组问题"><a href="#最大子数组问题" class="headerlink" title="最大子数组问题"></a>最大子数组问题</h3><p>最大子数组问题：在一个数的序列里面，寻找一个序列和最大的连续序列。</p><p>这个问题可以找出一个具有全局性质的指标：假设<code>a_i</code>是最大子数组左侧角标，那与<code>a_i</code>相连的任意左侧子数组都不可能有正和，任意右侧子数组都不可能有负和（在右侧角标左边的数组），于是对于左侧角标，它能被贪心算法命中一次，且此时全局最优解一定能被遍历一次，然后用擂台法就可以得到结果了。</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>opencv基础学习</title>
    <link href="/2020/08/10/opencv%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/08/10/opencv%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="opencv基础学习笔记"><a href="#opencv基础学习笔记" class="headerlink" title="opencv基础学习笔记"></a>opencv基础学习笔记</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在硬设开发的期间需要用到图像识别的功能，于是安装了opencv试图利用现成的库来实现。虽然只是调库，但是基本的概念还是得弄清楚，否则在其之上的修改就没法做了。这篇笔记主要记录opencv的基础概念，参照的是官方的tutorial，做的是一个总结式的笔记。和之前的笔记一样，也是重思想不重细节。</p><h3 id="Mat-图像的C-类抽象"><a href="#Mat-图像的C-类抽象" class="headerlink" title="Mat 图像的C++类抽象"></a>Mat 图像的C++类抽象</h3><p>mat组成就是一个代表灰度的矩阵+header,其中header存储矩阵大小、内存位置等信息。但是图像抽象并非如此简单：mat考虑到了内存管理问题，引入了counting system，并且对cv程序中的常用场景（图像传递）进行优化，减少大量复制带来的性能损耗。</p><p><strong>counting system</strong></p><p>多处引用带来一个问题：谁来释放这片内存？在reference counting mechanism的机制下，<strong>当程序中没有任何指针指向这片内存时，就代表它可以被释放了</strong>，没有指针指向内存，代表程序在这个时候是看不见这片内存的，也就无法利用其中的信息。reference counting并非要记录最后剩下的是“哪个”引用，因为哪一个都是无所谓的。这就像游乐园进场的数数一样，每进去一个就数一个数，在数到满员的时候让下一个游客等待下一轮再进去。</p><p><strong>color space</strong></p><p>不同色域的区别有两个：储存在矩阵中数值的范围和各层间的呈色方式。影响矩阵的只有前者，但是这也代表指定mat的时候就要指定颜色的分解方式。</p><p>另外，mat也提供了对图像的一个部分引用，或者是对图像中的颜色进行整体替换的功能。</p><h3 id="Feature-Matching-图像特征匹配"><a href="#Feature-Matching-图像特征匹配" class="headerlink" title="Feature Matching 图像特征匹配"></a>Feature Matching 图像特征匹配</h3><p>突然跳到这里是因为目前需要先理解这部分的内容。</p><p><strong>Matcher</strong></p><p>特征匹配简单地来说，就是选取图像的一部分计算出一个“特征”，这个特征进入到特定的数学空间中，此空间可以具有抗旋转、抗缩放、抗亮度变化等特性，也就是说这些变换并不会使同一个特征偏离太远。这个“距离”也是由数学空间所定义的。</p><p>Matcher操作的元素是Descriptor，也就是描述符，测量的量是两者的距离，操作的方式是逐一测量，并选出最接近的两个描述符（Brute-Force Matcher），距离的描述方式不一，可以是L1范数，也可以是L2范数。</p><p>一个DMatch Object抽象的是一对匹配的特征符，存储了特征符的序号、距离、图像序号。</p><p><strong>Descriptor</strong></p><p>matcher本身并不包含技术性的东西，特征符的选取和其在数学空间的位置都是由算法决定的，这个算法就是SIFT, ORB等。不同算法的选取方式不同，但不同的descriptor都在线性空间中，这就为Descriptor和matcher的解藕提供了基础。</p><p>descriptor在opencv中表现为一个高维向量，descriptor和key point共用一个序号来代表一个特征点的性质</p><p><strong>Key point</strong></p><p>关键点包括3个内容：位置、尺度、方向。位置指关键点在图像上的位置，这里的图像是经过尺度变换得到的。方向是关键点具有旋转不变性的原因：同一组关键点的方向应该是一致的，因此统计出整个图像的方向后，就可以还原出图像被旋转的角度（如果整个图像方向为0，那就类似圆形）。</p><p>Test: origin to scale_up:<br>– Max dist : 0.614476<br>– Min dist : 0.023140<br>normalized delta x=0.0046309<br>normalized delta y=0.0441643<br>normalized center=-0.0114116<br>Test: origin to left:<br>– Max dist : 0.593219<br>– Min dist : 0.025086<br>normalized delta x=-0.187185<br>normalized delta y=-0.0130463<br>normalized center=0.0207472<br>Test: origin to right:<br>– Max dist : 0.628698<br>– Min dist : 0.021708<br>normalized delta x=0.141781<br>normalized delta y=-0.0297364<br>normalized center=-0.0214759<br>Test: origin to up:<br>– Max dist : 0.679967<br>– Min dist : 0.036778<br>normalized delta x=-0.037491<br>normalized delta y=-0.216021<br>normalized center=0.0254128<br>Test: origin to down:<br>– Max dist : 0.537027<br>– Min dist : 0.024740<br>normalized delta x=0.00706097<br>normalized delta y=0.0883386<br>normalized center=0.0443451</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自平衡小车开发笔记</title>
    <link href="/2020/07/26/%E8%87%AA%E5%B9%B3%E8%A1%A1%E5%B0%8F%E8%BD%A6%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/07/26/%E8%87%AA%E5%B9%B3%E8%A1%A1%E5%B0%8F%E8%BD%A6%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="陀螺仪模块"><a href="#陀螺仪模块" class="headerlink" title="陀螺仪模块"></a>陀螺仪模块</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>MPU6050是一个陀螺仪模块，最近在做单片机的时候需要用到姿态估计，但是这个东西内部机理比较复杂，而且搜了一圈没有找到详细的教程，这个笔记包括硬件接口的解读和信号处理，因为做的项目是平衡车，所以会牺牲刷新率和角度范围来尽量提高精度。</p><h3 id="加速度计"><a href="#加速度计" class="headerlink" title="加速度计"></a>加速度计</h3><p>首先要明确加速度计测的是什么：加速度计的等效模型是一个铁球在正方体盒子中达到与正方体保持相对静止时与各个面的压力（规定正方向，一对面的压力就有了符号），这也就是说，铁球加速度时刻等于盒子加速度（不然他俩无法保持相对静止），铁球被封闭在盒子内，接触力只有压力，非接触力有重力、磁力等，但是在实际的加速度计中，是没有铁球的，也就没有磁力。</p><p>那么，可以推出：</p><p><strong>传感器加速度=测量加速度+重力加速度</strong></p><p>这里的三个加速度要转换到同一坐标系</p><img src="/2020/07/26/%E8%87%AA%E5%B9%B3%E8%A1%A1%E5%B0%8F%E8%BD%A6%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/2020-07-26-20-14-32.png" srcset="/img/loading.gif" class=""><p>我们需要用测量加速度得到传感器姿态，也就是传感器坐标系到地面坐标系（重力加速度所在坐标系，也是人观察的坐标系）的映射规律，3个已知量解出3个未知量，这就要求传感器加速度已知。这个要求是加速度计自身办不到的，需要借助其他模块。</p><p>但是，平衡车这一例子上，可以借助结构带来的额外条件用加速度额外解出角度。</p><p>当加速度计被绑定在平衡车上时，我们假设在短时间内平衡车车轮制动，那么整个车体相当于一个木杆，加速度只能有一个方向：与杆垂直的方向。我们将传感器的总加速度加上重力加速度，也就得到测量加速度。<strong>这个加速度在Z轴上的投影大小等于重力加速度在Z轴上投影的大小</strong>，用反余弦直接就可以解出角度。</p><p>为此，需要的条件是：短时间内维持车轮制动，在短时间达到近似静止或匀速运动，并对传感器高速采样，得到足够精确的结果。</p><h3 id="角速度计"><a href="#角速度计" class="headerlink" title="角速度计"></a>角速度计</h3><p>在非平衡状态时，加速度计就不可用（其实也可以作核算），这时对角度的计算就用角速度的积分。</p><h1 id="电机控制"><a href="#电机控制" class="headerlink" title="电机控制"></a>电机控制</h1><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>步进电机在调试后暴露出的缺点是：速度太快，加速减速算法太复杂，而且静止状态会过热。改进的方法是选用A4988，并采用16细分模式。利用A4988的最大电流控制，将静止电流设置在0.7A左右，这样基本就不会发热。剩下的技术难点就是pwm调频进行速度控制。</p><h3 id="pwm底层调频"><a href="#pwm底层调频" class="headerlink" title="pwm底层调频"></a>pwm底层调频</h3><p>步进角1.8度，16细分后一圈是3200步。uno主频16MHz, 预除数1，8，64，256，1024，timer1支持计数器到65535, timer2支持到256, 两者最低pwm频率分别是0.23Hz和61Hz。</p><p>轮子直径5cm, 换算成线速度，timer2支持的最小线速度是0.31cm/s，在不改变scale的时候最大线速度是80cm/s左右，完全支持所有使用情景。</p><p>得出公式：c = (5000 * pi * d) / (p *s); 其中c是比较器上限(0-255)，d是轮子半径，p是preScale大小，s是轮子线速度。d和s的长度单位统一，时间单位是秒。默认16细分。</p><p>如果只计算赫兹数的话，c = 16 * 10^6 / (p * f); 其中f是输出频率。</p><p>为了让速度的离散分布尽量均匀，我们预先对不同速度进行分区。先作出不同预除数的可能</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>这里记一下位运算的结果：</p><pre><code class="hljs plain">   &#x2F;&#x2F; turn on CTC modeTCCR1B |&#x3D; (1 &lt;&lt; WGM12);&#x2F;&#x2F; Set CS10 and CS12 bits for 1024 prescalerTCCR1B |&#x3D; (1 &lt;&lt; CS12) | (1 &lt;&lt; CS10);</code></pre><p><code>a &lt;&lt; b</code> 表示a左移b个bit，假设这里WGM12=3,那么右移运算就是1000，而TCCR1B被初始设定为0，或操作以后就直接把WGM12寄存器的值赋为1。所以这里用麻烦的宏定义的原因就是便于直接读出寄存器的值。相应地多个寄存器的操作用或来连接（因为都是0，所以或操作不会覆盖什么东西）</p><p>至于寄存器的值对应pwm的状态，参考芯片的datasheet，注意这里设置的都是fast pwm模式。</p><img src="/2020/07/26/%E8%87%AA%E5%B9%B3%E8%A1%A1%E5%B0%8F%E8%BD%A6%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/2020-08-01-23-03-51.png" srcset="/img/loading.gif" class=""><p>因为频率和寄存器中阈值的反比关系，线速度的分布是不均匀的。可以实时对预除数进行调整，从而保证在一个相当大角速度范围内近似均匀的pwm输出</p><h1 id="控制算法"><a href="#控制算法" class="headerlink" title="控制算法"></a>控制算法</h1><p>采用的是PID双环控制：速度环和距离环，前者维持小车平衡，后者维持小车位移不变。开发过程中也有一些问题，这里列举出来：</p><h3 id="控制量的符号关系"><a href="#控制量的符号关系" class="headerlink" title="控制量的符号关系"></a>控制量的符号关系</h3><p>假设角度、加速度、电机速度三者的正方向在初始点是一致的，PID输入、输出、目标点关系已知，那么在小车运用中需要额外改变符号：</p><p>假设小车前倾，角度为正，角度输入速度环，得到负的速度输出：这里的负号指PID算法试图让小车角度回正，那么对应电机速度应该是正向，因此需要加一个负号。</p><p>假设小车前倾，角度为正，速度环输出为正（已修正），电机速度为正，但是小车行驶了一段距离，偏离原点，此时距离环接受速度环的输出为正，距离输出为负，对角度影响为负，不需要变号。</p><h3 id="PID参数解析"><a href="#PID参数解析" class="headerlink" title="PID参数解析"></a>PID参数解析</h3><p>速度环确保小车不会倒下（稳定在某个角度），将车轮速度看作“修正力”，而将角度看作“目标”的话，角度受到重力加速度分量影响，也就是存在一个“阻力”，P参数代表原始的修正力，角度越大，修正力越大。I参数代表抗衡重力加速度分量的一个力，在I参数影响下，小车受到的等效重力减小了许多，落入了能被P参数修正的区间内（如果单纯地调大P参数，会使P的作用力累积导致结果发散）。D参数用角速度控制速度，对角度的周期性震荡进行衰减，但数值太大会造成调控力度不够，收敛时间延长。</p><p>距离环其实输入的是距离微分（速度乘以时间间隔），输出是角度。I参数用距离控制倾斜角度，这当然会将系统引向不稳定状态，I较大的时候距离调整更迅速，但是I依赖于速度环的控制能力，而且I太大会引起周期震荡。考虑到采样的间隔还是比较均匀的，P参数可以看作用速度控制倾斜角度，也就是对周期性震荡进行衰减，但是P太大也会引起周期震荡，这个参数的确定与重力加速度有关。D参数用加速度调整角度，也是让运行更加平稳。</p><p>偏移时，距离信息存储在距离环的I参数中，当小车在另一个位置稳定时，I参数可以引导小车回到原地，因此距离环具有调整距离的作用。</p><h3 id="抗干扰"><a href="#抗干扰" class="headerlink" title="抗干扰"></a>抗干扰</h3><p>角度零漂等效于小车放在斜坡上：速度环的I参数对抗恒定阻力，所以没有问题，仿真中去掉I参数后小车确实以恒定速度向前移动了。</p><h1 id="GUI设计"><a href="#GUI设计" class="headerlink" title="GUI设计"></a>GUI设计</h1><h3 id="bug汇总"><a href="#bug汇总" class="headerlink" title="bug汇总"></a>bug汇总</h3><p>这里记录一些开发过程中遇到的bug，都是比较玄学的东西。</p><blockquote><p>__acrt_first_block == header</p></blockquote><p>这是DLL和exe没有共用一个栈导致的，原因是vs项目设置里没有设置动态链接dll模式（MDd），改过去以后就OK。</p><blockquote><p>esp32上传的代码时好时坏</p></blockquote><p>串口使用前要println，上传时要选no IDE，不能用arduino IDE，也是一个非常玄学的问题。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>硬设算是结束了，但是很多技术细节都没有记下来，留待以后慢慢补充。这里先总结一些需要改进的地方（包括技术、展示、软硬件设计等）</p><h3 id="缺乏合适的测试环境，测试周期过长"><a href="#缺乏合适的测试环境，测试周期过长" class="headerlink" title="缺乏合适的测试环境，测试周期过长"></a>缺乏合适的测试环境，测试周期过长</h3><p>测试环境是一个软硬结合的环境。因为自平衡小车的特殊性，测试过程中需要大量的调试。尽管我已经在设计上对小车的软硬件进行解耦，但是后期出现的转向问题、指令过渡问题等都是需要大量测试来debug的，更不用说PID调参。</p><p>理想情况下，应当有一个尽可能快速的测试周期：</p><ol><li>小车的平衡检测可以只做一次，时间可以缩短；</li><li>完善debug输出指令，可以指定输出内容；</li><li>在小车最大电流和输出功率间找到平衡点，尽量降低耗电；</li><li>寻找一个宽敞的测试环境，事先用水平仪测量保证排除地面平整度因素</li><li>前期基础性测试中对各种异常现象汇总，有意设置异常情况（放置角度不水平、任意时刻外加扰动），避免多层次bug互相影响</li><li>仿真协助测试：先给出原理可行性，再进行实际调参</li><li>每个模块都有单元测试和集成测试，不能同时对几个模块进行测试。</li></ol><h3 id="时间分配不合理，功能展示不够灵活"><a href="#时间分配不合理，功能展示不够灵活" class="headerlink" title="时间分配不合理，功能展示不够灵活"></a>时间分配不合理，功能展示不够灵活</h3><p>这主要是针对展示环节提出的，展示时双方分工没有安排好，启动时间比较长，而且触摸模块鲁棒性太差，好几次启动失败。功能展示的时候没有体现出显著性，没有方便的展示样例，导致图像识别部分也没有对应实例，拿不出可信的东西。出bug的时候也没有优先进行接下来的展示，总体来说，前期缺乏磨合训练，临场发挥不够灵活。</p><h3 id="debug没有遵照原则，浪费了大量时间"><a href="#debug没有遵照原则，浪费了大量时间" class="headerlink" title="debug没有遵照原则，浪费了大量时间"></a>debug没有遵照原则，浪费了大量时间</h3><p>debug的时候思考不够冷静，只想用自己推断来快速找到原因，但很多情况都没有思路，反而在浪费时间。</p><p>另外，一些调试手段过于繁杂，缺乏自动化设计，进而在大量测试时不可避免地引入偶然误差，同时分散了人的精力。</p><p>debug的一些经验：</p><ol><li>发现bug的时候先进行复现，进而确定出错的情景范围。</li><li>屏蔽掉若干无关模块，特别是未测试过的模块</li><li>对可复现的bug逐步排查无关变量，从而确定最核心的出错情景</li><li>添加若干调试输出，缩小排查范围</li><li>找到最核心的出错位置，初步确定几个可能性</li><li>先做出简单的改动，检验思路是否正确</li><li>最后锁定一个思路，设置关键性的调试输出，或者进行一些特定操作来复现</li><li>每一次复现时都尽可能保持测试环境的一致性。</li><li>尽量采用自动化设计。</li></ol><h3 id="代码素养不够好"><a href="#代码素养不够好" class="headerlink" title="代码素养不够好"></a>代码素养不够好</h3><p>这是两方面的：一方面指自身应当写出良好的代码，另一方面指不能让极差的代码进入项目中来。至少应当对其进行最起码的修复。</p><p>GUI编写上，这次比较成功地用MVC思想进行前后端分离，但是也出现了后端单个类过于庞大的问题。在写实时位置显示时，没有想清楚具体的控制和显示关系，导致写出来的东西有很多逻辑自相矛盾的地方。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>软硬结合的作品最核心的瓶颈就是调试，如何在有限次调试中尽量确保作品鲁棒性强，这就要求有高自动化的测试步骤、详细的数据记录、尽量可靠的原理性仿真和一些工程上的冗余。通过引入分层设计的思想，能够快速定位bug的发生位置。统一且可靠的代码风格能够避免很多潜在的bug。</p><p>另外，这次硬设的一个经验是：任何自己没想清楚的环节，到最后都会成为问题。从初创到成品的过程本身就是一个不断细化的过程，任何设想最终都落实在代码上，一些小小的意料外因素最后也会成为一个障碍，因此最好在最开始的时候就追问所有的细节：<strong>这个细节该如何实现？是否具有工程可行性？</strong>，以此来督促自己摆脱空想、面对现实。</p>]]></content>
    
    
    <categories>
      
      <category>硬件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>arduino</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【读书笔记】QT5.9C++开发指南</title>
    <link href="/2020/07/25/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91QT5.9C++%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    <url>/2020/07/25/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91QT5.9C++%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="QT学习笔记"><a href="#QT学习笔记" class="headerlink" title="QT学习笔记"></a>QT学习笔记</h1><p><strong>前言</strong></p><p>最近写了Blog自动上传的脚本…对VS CODE的了解也更丰富了, 尽可能地避开图形界面的弊端, 提高工作效率. 这篇文章只记录我在学习QT中遇到的优秀的设计思想, 而并不关心QT框架的语法细节或者是使用经验.</p><h2 id="Signal-Slots-信号与槽"><a href="#Signal-Slots-信号与槽" class="headerlink" title="Signal/Slots 信号与槽"></a>Signal/Slots 信号与槽</h2><p>这可以说是QT第一个也是最重要的一个设计思想, 在MVC框架下, 解决组件的互相通信以及Model和Components之间的互相通信问题. </p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>QT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【读书笔记】精通Cocos2d-x游戏开发(基础卷)：程序设计思想札记</title>
    <link href="/2020/07/24/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E7%B2%BE%E9%80%9ACocos2d-x%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91(%E5%9F%BA%E7%A1%80%E5%8D%B7)%EF%BC%9A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E6%9C%AD%E8%AE%B0/"/>
    <url>/2020/07/24/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E7%B2%BE%E9%80%9ACocos2d-x%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91(%E5%9F%BA%E7%A1%80%E5%8D%B7)%EF%BC%9A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E6%9C%AD%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="【读书笔记】精通Cocos2d-x游戏开发-基础卷-：程序设计思想札记"><a href="#【读书笔记】精通Cocos2d-x游戏开发-基础卷-：程序设计思想札记" class="headerlink" title="【读书笔记】精通Cocos2d-x游戏开发(基础卷)：程序设计思想札记"></a>【读书笔记】精通Cocos2d-x游戏开发(基础卷)：程序设计思想札记</h1><h1 id="程序设计思想札记"><a href="#程序设计思想札记" class="headerlink" title="程序设计思想札记"></a>程序设计思想札记</h1><p>这本书是我从2020-6-16开始学习的，目的大概是为了完成小学期的作业吧，书中有一句话启发了我，大概意思是“编程学习的是思想，而不是记忆代码。”我觉得很有道理，于是打算用这篇札记记录自己学到的程序设计<strong>思想</strong>，尽量用脱离具体实现的方式将优劣势讲清楚，便于以后独立设计一个系统时来参考。但一些总结性的东西会具体写出来。</p><p>这篇笔记可以看作读书笔记，也可以看作大作业的心得总结，当然详细的总结会放在技术文档和开发日志里，这里只是写一些闲言碎语吧。</p><hr><h3 id="可读性和可维护性：C-变量命名规则"><a href="#可读性和可维护性：C-变量命名规则" class="headerlink" title="可读性和可维护性：C++变量命名规则"></a>可读性和可维护性：C++变量命名规则</h3><p>变量命名指南：</p><ul><li>不在变量名中写变量类型：减少重复和低效</li><li>减少容易混淆的词：英语中很多词无法从部分推出整体词义，那么应当用构词法描述一个变量</li><li>尽可能具体，方法命名要一目了然</li><li>用稍长的变量名代替简短变量名+单行注释：减少阅读者的记忆负担</li><li>不要用类似val/value/result/temp/count/str这种无意义变量名</li><li>正确使用惯用语：i,j,k,n,e</li><li>生命周期比较短的变量，命名也相对要短：长命名的潜台词是“这是值得注意的变量，需要被记住”</li><li>合理使用一次性变量：并列式长代码需要拆分，嵌套式短代码需要合并<br>驼峰命名法相比于下划线，占地小，紧凑性更好，有些时候区分类和变量时，类用大写驼峰，变量用小写驼峰。但也有自己的缺点，比如HTTP，ID这种缩写词，而且在查找变量的时候必须加上大小写通配。</li></ul><p>还有一些技巧；</p><ul><li>变量、类用名词，方法和函数用动词</li><li>控件命名保留匈牙利命名法，如button-btn, label-lbl等</li><li>对容易用错的变量（比如指针和对象、全局变量），可以保留匈牙利命名法：</li></ul><ol><li>指针加p：避免-&gt;和.用错</li><li>全局变量加g_, 静态变量加s_：这些都是容易出bug的</li><li>成员变量加m_：避免和外部变量重叠<br>总地来说，变量命名需要考虑阅读效率、阅读无歧义、写作效率、写作无歧义、搜索效率、规避潜在风险、规则的简化等，是需要语言学与心理学还有编程经验三者深度融合后才能进行改进的。这次的工程也会采用这些规则来规范编写。</li></ol><h3 id="引擎与顶层逻辑的交互：回调、封装"><a href="#引擎与顶层逻辑的交互：回调、封装" class="headerlink" title="引擎与顶层逻辑的交互：回调、封装"></a>引擎与顶层逻辑的交互：回调、封装</h3><p>对于一个节点来说，加入节点树后，引擎会自动在某些时刻调用方法：初始化，添加进场景时，删除时。对于一些节点，需要每帧进行检测，那么就需要自定义回调函数，并且向引擎“注册”。有时引擎接受到外部输入时，需要将其反馈给节点，那么节点需要事先指定一个回调函数用于接收。</p><p>将外部输入和渲染看作一极，顶层逻辑看作另一极，那么游戏引擎就是连接两极的纽带，为了进行有效的沟通，诞生了消息传递和update等机制。</p><h3 id="内存泄漏与日志统计"><a href="#内存泄漏与日志统计" class="headerlink" title="内存泄漏与日志统计"></a>内存泄漏与日志统计</h3><p>内存泄漏指的是：在堆中创建对象后，没有在结束前进行回收。这个问题非常隐蔽：</p><blockquote><p>…他在维护这份代码的过程中，向其中添加了一些错误判断，如果发生错误，返回什么…但他在添加代码时，所有的返回语句都忘记把这块内存删掉了</p><p>任何一个系统的维护都是长效性的，内存泄漏也是。一种解决方法就是，将构造函数与析构函数的执行次数输出到日志中，这样程序结束后统计日志，就可以发现潜在问题了。</p></blockquote><h3 id="C-11的lambda表达式"><a href="#C-11的lambda表达式" class="headerlink" title="C++11的lambda表达式"></a>C++11的lambda表达式</h3><p>当我们需要在函数内部临时建立一个函数处理一些灵活的工作时，可以构建一个lambda函数：</p><blockquote><p>std::function&lt;return type()&gt; func1 = [capture list] (params list) mutable exception-&gt; return type { function body }</p></blockquote><p>lambda函数func1像变量一样被创建出来，被储存为std::function类型。capture list规定了func1能够利用的外部变量（范围是func1被创建时所能操作的变量），然后params list规定了调用func1时额外传入的参数，mutable修饰符表示函数可以改变捕获的变量（临时改变供自己使用？），exception抛出异常（允许函数体内部用throw()抛出异常）</p><p>但是需要注意，lambda的capture list中的变量是在<strong>创建时就定下来的</strong>，如果是引用捕获&amp;，捕获的是一个引用，func1创建后的修改会有影响，而如果是值捕获=，就只有当时的值，此时对捕获变量的修改都是没有意义的。</p><h3 id="template与可变参数模版"><a href="#template与可变参数模版" class="headerlink" title="template与可变参数模版"></a>template与可变参数模版</h3><p>这篇文章介绍了模版的应用：<a href="https://blog.csdn.net/lianhunqianr1/article/details/79966911" target="_blank" rel="noopener">https://blog.csdn.net/lianhunqianr1/article/details/79966911</a></p><blockquote><p>C++标准委员会采用一套类似函数式语言的语法来设计C++模板，而且设计成图灵完备 (Turing-complete)（详见参考），我们可以把C++模板看成是一种新的语言，而且可以看成是函数式编程语言，只是设计依附在(借助于）C++其他基础语法上（类和函数）。</p></blockquote><p>模版有其复杂的使用方法，但是这里只记录它的思想。首先是“简化”思想，运用模版编程后，不需要对每个类型单独设计一套规则，这就将相似的东西合并起来，大大简化了代码量。第二点是“灵活”，有时候程序员不知道也不需要知道一个类的确切形象，只要知道可供操作的一部分就行了，这时候只有用模版才能开发出具有普适功能的算法和容器。第三点是“动态生成代码”，模版的工作是在编译期和运行期进行的，一些典型场景中（比如用if进行类型判断），一部分花销可以从运行期迁移到编译期，这样就减小了运行开销。</p><p>模版是泛型的基础，泛型中一个思想就是<strong>“Substitution failure is not an error”</strong>，意思是对类型的适配有多次尝试，编译器会自动推导可行的方案（比如对不同参数的函数调用，自行适配合适的参数），然而一次尝试的失败并不是程序错误，只有所有尝试失败才是错误。也就是说，编写者需要设计出任何情况下至少有一种方案能够被执行的代码。自然，智能化的代码需要更加更加智能化的编写者。</p><p>可变参数模版的关键在于参数调用，这里的思想是<strong>匹配调用</strong>或者<strong>递归调用</strong>，后者是前者的延伸。匹配调用也就是：既然不知道参数长度，那么就准备多个函数，逐一匹配合适的函数即可。而递归调用将承接可变长参数的函数func1与解析的函数func2合二为一，将参数列表设为前n个固定参数与最后的可变参数，然后递归调用自身，这样就逐一解出所有参数，但是注意取值为n时，需要准备n-1个函数用来处理递归最后的“余数”，这一点是模版元编程需要考虑“全体情况”的表现。</p><h3 id="变量的四个属性：数值、类型、const、右值（C-11）"><a href="#变量的四个属性：数值、类型、const、右值（C-11）" class="headerlink" title="变量的四个属性：数值、类型、const、右值（C++11）"></a>变量的四个属性：数值、类型、const、右值（C++11）</h3><blockquote><p>通过是否可取地址操作符，以及是否有名字，可以判断是否为右值。右值是指表达式结束后就不存在的临时对象。</p></blockquote><p>在模版变成时，当然需要处理右值的函数，然而在模版的嵌套、转发中，右值可能变成左值（也就是本来赋值完就销毁的变量却拥有了自己的地址和名字）。这时用C++11提供的引用<code>T&amp;&amp;</code>就可以同时保留变量的四个属性，做到“完美转发”</p><h3 id="虚函数与多态特性"><a href="#虚函数与多态特性" class="headerlink" title="虚函数与多态特性"></a>虚函数与多态特性</h3><p>这里参考这篇文章：<a href="https://blog.csdn.net/hackbuteer1/article/details/7558868" target="_blank" rel="noopener">虚函数与纯虚函数的区别</a></p><p>虚函数蕴含的思想是<strong>多态</strong>，整个代码的执行情况对于编译器来说并不是单一的（虽然从结果上，它只能是唯一的，但编译器不需要知道整个情况）。因此，虚函数调用不取决于类型，而取决于实际初始化的类型，就如下面的代码：</p><pre><code class="hljs plain">int main(void)&#123;    A *a &#x3D; new B();    a-&gt;foo();   &#x2F;&#x2F; 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!    return 0;&#125;</code></pre><p>但是，基类定义了虚函数，子类才能继承并重载，这时候我们依然可以用基类生成一个对象，而这样的对象是不合理的：基类本该是抽象的东西，却可以被实例化。因此，纯虚函数<code>virtual void funtion1()=0</code>，规定了其必须被重写，而且这样的基类不可以被继承。</p><p>可以看出，虚函数和纯虚函数的引入是将现实中的抽象和具象关系体现在代码上，让代码更加安全，同时把“抽象”作为内嵌在语言的特性推广为所有开发者的共识，降低代码理解难度。</p><h3 id="节点继承与回调方法：Cocos2dx引擎与顶层的交互接口"><a href="#节点继承与回调方法：Cocos2dx引擎与顶层的交互接口" class="headerlink" title="节点继承与回调方法：Cocos2dx引擎与顶层的交互接口"></a>节点继承与回调方法：Cocos2dx引擎与顶层的交互接口</h3><p>在处理游戏内容的可拓展性上，cocos2d采用的思想是<strong>继承和回调</strong>，通过对节点类Node的继承，实现游戏内容的多样性和统一性。而事先规定好特定的回调函数，在约定的时刻由引擎调用，就实现了游戏逻辑的可拓展性。</p><p>回调函数：</p><ul><li>init初始化节点时调用</li><li>onEnter被添加进场景中调用（这里是二次初始化）</li><li>onExit节点从场景删除</li><li>update与时间相关，比如每一帧的逻辑、定时逻辑<br>可以认为继承是引擎为内容维度提供的接口，回调是引擎为逻辑维度提供的接口，游戏顶层设计在这两个维度上与引擎进行交互。</li></ul><h3 id="内存池设计"><a href="#内存池设计" class="headerlink" title="内存池设计"></a>内存池设计</h3><p>内存池的思想是将大大小小的内存申请需求统一，以此来<strong>用额外的内存空间为代价换取低频的内存扩展请求</strong>。这是由于技术的发展，使得内存不再需要节约使用，而更需要低频使用。</p><p>内存池的基本功能：</p><ul><li>接管原本代码中的new和delete/free功能，先申请一大块内存空间，再自行决定分配。同时释放的时候也可以暂时不delete，减少频率</li><li>内存池本身申请内存时，做到连续，低频，且尽量占用少（这三者其实是互相矛盾的）</li><li>内存空闲太多时，需要释放一部分内存。<br>PS：这一部分就实现了自主选题中的内存管理需求</li></ul><h3 id="cocos2d-x运行机制解释"><a href="#cocos2d-x运行机制解释" class="headerlink" title="cocos2d-x运行机制解释"></a>cocos2d-x运行机制解释</h3><p><strong>与windows系统关联的启动机制</strong></p><ol><li><code>_tWinMain</code> 作为入口，初始化实例AppDelegate</li><li>调用Application::getInstance()-&gt;run(); 回调applicationDidFinishLaunching，完成制作者自定的初始化</li><li>windows下的OpenGL进行底层交互处理（键盘，窗口最小化等），GLFW直接与Director等进行信息传递</li></ol><p><strong>引擎内部的运行机制</strong></p><ol><li><p>全局初始化：AppDelegate中的applicationDidFinishLaunching，可添加开发者自己的初始化代码</p></li><li><p>进入DisplayLinkDirector的mainloop（），其中的drawScene()对每一帧进行场景渲染和逻辑执行：</p></li><li><p>执行schedule的update进行逻辑更新：schedule作为调度器驱动action更新，并且执行每一帧的游戏逻辑和关于时间的逻辑</p></li><li><p>Director直接控制游戏的暂停、恢复、结束、场景切换（但判断逻辑并不在这里）</p></li><li><p>场景渲染</p><h3 id="消息、逻辑、调度交互"><a href="#消息、逻辑、调度交互" class="headerlink" title="消息、逻辑、调度交互"></a>消息、逻辑、调度交互</h3></li></ol><p><strong>消息的观察者模式：包括注册、触发、处理、注销四个步骤</strong></p><hr><p>这里首先介绍一些C++11的bind机制：</p><pre><code class="hljs plain">void TestFunc(int a, char c, float f);auto bindFunc1 &#x3D; bind(TestFunc, std::placeholders::_1, &#39;A&#39;, 100.1);bindFunc1(10);</code></pre><p>bindFunc1将一个3个参数的函数变成1个参数，2个“定量”的函数，bind第一个参数对应目标函数，后面的placeholder就对应使用时需要传入的东西。需要注意的是，预先设定的参数都是按值传递的。</p><hr><p>这里来总结观察者模式：</p><p><code>auto listener = EventListenerKeyboard::create();</code>：创建监听器，申请得到一个实例</p><p><code>listener-&gt;onKeyPressed = CC_CALLBACK_2(HelloWorld::fighterMoveCallback, this);</code>：指定监听器的哪个事件会触发哪个实例的哪个成员函数，本质上是对listener的成员指针指定要一个bind()，这里的this指当前场景的实例</p><p><code>_eventDispatcher-&gt;addEventListenerWithSceneGraphPriority(listener, this);</code>：向Director注册（_eventDispatcher其实是封装了向Director相关函数），监听器本身是绑定在节点（这里是Scene）上的，而监听器本身也拥有一个指向回调函数的指针。</p><p>触发由引擎和底层负责，这里只需要实现HelloWorld::fighterMoveCallback方法即可。</p><p><strong>调度器：Schedule</strong></p><p>Scheduler是一个全局调度器，可以从Director中获取指向它的指针，调度的本质就是<strong>在规定的时间由引擎调用某个实例的成员函数</strong>，所以需要3个元素：指向调度器的指针，指向实例的指针，实例的成员函数。</p><p>一般来说，调度器的指针是很容易获得的，实例的指针用this即可实现，所以调度一般定义在该实例对应的类中。</p><p>回调按类型分为update回调（每一帧执行的回调），对象回调和函数回调，脚本回调，执行回调。对象回调其实也是调用函数，只不过这个函数是事先约定的形式：</p><p><code>typedef void (CCObject::*SEL_SCHEDULE)(float)</code>：这里规定了一种类型叫SEL_SCHEDULE，它被定义成一个指针，指向一个CCObject类或派生类的成员函数，而这个成员函数的参数必须是float，返回类型必须是void。</p><p>调度器注册时机：</p><ul><li>Node回调函数中，如onEnter或onExit，会在下一帧开始计时</li><li>单击回调，会在当前帧立刻计时</li><li>计时回调内嵌套回调：难以控制时间<h3 id="cocos2d-x顶层逻辑设计"><a href="#cocos2d-x顶层逻辑设计" class="headerlink" title="cocos2d-x顶层逻辑设计"></a>cocos2d-x顶层逻辑设计</h3></li></ul><p>今天终于是把书差不多啃完了……以现在的预期来看，UI界面只能靠手画，同时分辨率固定，这些暂时没法解决。其他的主要在顶层规划，这也是相当考验能力的环节。</p><p>从内容上来看的话，我将游戏设计拆分成以scene为主的“内容切片”</p><ul><li>scene内加载要考虑耦合度，可能会复用的加载模式不可以在单个scene做</li><li>游戏UI独立于画面，设置继承Node的UINode，游戏UI不写在场景加载里，以便重复调用</li><li>各scene间进行解耦，每个继承的scene间的数据传输用约定的方法进行通信，尽量将数据传输大的scene进行整合</li><li>游戏逻辑去中心化，但是约定用tag进行全局的自由通信，游戏与固定的非组件部分存储指针通信</li><li>对于动态产生的节点，不存储指针，每次访问时调用方法获取实时数据。</li><li>对于复杂的逻辑控制，抽象出一个逻辑节点来做。<h3 id="debug-类之间的互相包含"><a href="#debug-类之间的互相包含" class="headerlink" title="debug:类之间的互相包含"></a>debug:类之间的互相包含</h3></li></ul><p>今天debug的时候遇到了这个问题，两个类的定义互相包含，这时候要用前置申明，而且不能写继承关系。</p><h3 id="关卡设计中的序列模式与难度设置"><a href="#关卡设计中的序列模式与难度设置" class="headerlink" title="关卡设计中的序列模式与难度设置"></a>关卡设计中的序列模式与难度设置</h3><p>首先要解决两个问题：在阶段BOSS和最终BOSS被击落前不能开启下一个阶段；每个阶段是一条时间轴，这里我想设计成既可以从外部读取又可以自动生成的机制。</p><p>一般来说玩游戏是为了有爽快感，随着玩家自身操作水平和装备的提升，固定的游戏难度难以让玩家得到充分的满足。因此，游戏难度应该参考玩家飞机的DPS（这决定了是否能理论上通关）、玩家历史战绩（这体现了玩家的水平）、时间难度（这让游戏更加丰富，也带有一些随机性）、关卡难度系数（让游戏从前到后难度有变化）。</p><h3 id="碰撞判定机制的设计"><a href="#碰撞判定机制的设计" class="headerlink" title="碰撞判定机制的设计"></a>碰撞判定机制的设计</h3><p>碰撞判定也是这个游戏的一大难点：全像素化碰撞太耗性能，直接用boundingBox碰撞又不能避免透明像素的干扰。那么在解决碰撞问题时，我的方案是用一个根据booundingbox自动伸缩的“细长”区域判定。</p><p>2D游戏有设计的优势：绝大多数情况子弹都要穿过敌机的横截面，而穿过纵截面的情况极少发生，这是因为敌机的速度一般都垂直于横截面方向。所以这样就极大方便了碰撞判定。同时对于不同类型的问题，我搭建了scene到各元素的双向通信机制，理论上这个机制可以用动态类型转换+Node-&gt;name进行区分，但这种操作有运行风险不说，性能消耗也比较大。我采用的方式是scene持有多个vector，各节点在加载时分别向scene注册自身的指针到指定vector中，各节点退出时也向scene注册销毁自身的指针，然后每一帧调用scene的碰撞判定，分组进行判定，减小内存消耗。</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏开发</tag>
      
      <tag>读书笔记</tag>
      
      <tag>cocos2d</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【读书笔记】Pragmatic_Programmer_札记</title>
    <link href="/2020/07/24/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Pragmatic_Programmer_%E6%9C%AD%E8%AE%B0/"/>
    <url>/2020/07/24/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Pragmatic_Programmer_%E6%9C%AD%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="【读书笔记】Pragmatic-Programmer-札记"><a href="#【读书笔记】Pragmatic-Programmer-札记" class="headerlink" title="【读书笔记】Pragmatic Programmer 札记"></a>【读书笔记】Pragmatic Programmer 札记</h1><h3 id="前言和概要"><a href="#前言和概要" class="headerlink" title="前言和概要"></a>前言和概要</h3><p>这本书是在七月份读的, 有差不多300页, 考虑到英文书算是比较容易理解, 应该一两周能读完.(PS: 实际从10号读到16号)</p><p>重点处会用黑体标注. 主要还是根据书中一些精华的句子写感想.</p><blockquote><p>Your background stems from an understanding of the basic principles of computer science, and your experience comes from a wide range of practical projects.</p></blockquote><p>这是一个关于学习编程知识的建议, 有最基础的计算机知识, 然后在不同领域积累许多经验. 所以语言没什么限制, 思想才是有价值的东西.</p><blockquote><p>There are other factors that can contribute to software rot, and we’ll touch on some of them elsewhere, but neglect accelerates the rot faster than any other factor.</p></blockquote><p>软件工程中的”熵增理论”或”破窗理论”, 书中建议将<strong>及时重构, 修复那些不好的设计</strong>放在第一位, 如果实在没有时间, 也要将其标注起来, 构建以一个围栏, 阻止一块不好的代码继续扩散. 这个建议是基于软件开发中的混乱度提出的, 软件在开发过程中, 总是不可避免地走向混乱, <strong>软件开发的过程也就是与混乱抗争的过程</strong>, 那么尽量保护自己的代码, 让它们简洁高效, 是延续抗争意志的很好的手段.</p><blockquote><p>If you find yourself working on a project with quite a few broken windows, it’s all too easy to slip into the mindset of “All the rest of this code is crap, I’ll just follow suit.”</p></blockquote><p>这个是破窗理论的延伸, <strong>一块不好的代码不仅会让开发者更易于添加糟糕的代码, 还会让开发者认为其他代码也是不好的.</strong>, 我注意到的是这种情形<strong>不仅适用于代码, 还适用于开发计划/开发文档等</strong>, 第一天进行开发的时候应当设计一个简洁的框架, 然后每隔一段时间适量地作出计划, 保证整体的准确性和指导功能. 计划不能太过详细, 不然后续修改需求时就会被看作一块”破窗”, 计划也不能太抽象或者没有, 不然过几天去看当时写的代码的时候就会觉得是写出来的东西难以阅读, 也找不到定位. 总之好的设计一定是精简又可扩展的, 使得每一天都能及时踏在开发的进度上, 而不至于迷失方向或疲于修改计划.</p><blockquote><p>Once you’ve got it, show people, and let them marvel. Then say “of course, it would be better if we added….”</p><p>People find it easier to join an ongoing success.</p></blockquote><p>不仅是对团队而言, 对独立开发者也是这样. <strong>让一个项目时时刻刻处于即将成功的状态, 会让它更加有吸引力</strong>, 最初的开发要做的是写出一个最精简的可行的框架, 给人眼前一亮的感觉, 然后依照这个最初的创意不断的添加功能. 对独立开发者来说, 也就是时时刻刻让项目富有吸引力, 从而让自己能坚持开发下去.</p><blockquote><p>If you give your users something to play with early, their feedback will often lead you to a better eventual solution</p></blockquote><p>这也是迭代开发的好处, 能够迅速地将开发工作转换成可见的成果</p><h3 id="Duplication-重复"><a href="#Duplication-重复" class="headerlink" title="Duplication 重复"></a>Duplication 重复</h3><blockquote><p>The alternative is to have the same thing expressed in two or more places. If you change one, you have to remember to change the others, or, like the alien computers, your program will be brought to its knees by a contradiction. It isn’t a question of whether you’ll remember:<strong>it’s a question of when you’ll forget</strong>.</p><p>The DRY principle tells us to keep the <strong>low-level</strong> knowledge in the code, where it belongs, and reserve the comments for other, <strong>high-level</strong> explanations. Otherwise, we’re duplicating knowledge, and every change means changing both the code and the comments.</p></blockquote><p>这是第一个重要的概念: <strong>在任何地方都尽量不要出现重复的知识</strong></p><p>我在过去的经验里也有这种现象: 在许多地方写上一些相似的代码, 但是修改的时候又忘记修改其他地方的东西, 或者修改了代码却没有修改注释. 现在来看看文章中给的解决方法:</p><ol><li><p>用code generator在每一次更改的时候同步代码. 这也可以使用于代码和文档之间(doxygen), 其核心理念就是<strong>在更改时同步</strong>. 用到的技术有metadata/preprocessor等</p><blockquote><p>To ensure that the tests accurately reflected the specification, the team generated them programmatically from the document itself.</p></blockquote></li><li><p>在注释中用<strong>更高级的逻辑概括代码的内容</strong>, 通常是代码的目的或作用, 这样在更改代码的时候也就不会需要同时修改注释了</p></li><li><p>为了避免头文件和实现中的注释重复, 在头文件中存放<strong>与接口相关的信息</strong>, 而在实现中写一些<strong>被封装起来的但是很重要的细节</strong></p><blockquote><p>Use the header files to document interface issues, and the implementation files to document the nitty-gritty details that users of your code don’t need to know.</p></blockquote></li><li><p>避免违背事实的抽象关系和重复的抽象关系.</p></li></ol><p>这一点书中给了一个实例: 一个运送路线包含卡车, 司机, 和路线, 而卡车中又包含号码牌, 司机和卡车类型. 而当司机生病需要替换时, 问题就来了: 有两个重复的司机. 另外, 卡车其实并不包含司机, 如果一定要包含的话, 那么这个卡车是正在运送货物的卡车. 而不是普通意义的卡车. <strong>在设计抽象的时候时常会出现重复或是违背事实的抽象关系, 从而让实际设计的类不是我们想要的类</strong>, 解决这个问题, 当然是尽量避免重复, 我想到的, 在设计时应该这样询问自己:</p><ul><li>我是否能从这个类中的某几个类成员直接得到另一个类成员? (避免相互包含的重复)</li><li>在这个类需要应用的情况中, 这个类是否都包含它的成员属性?是否有没考虑到的成员属性? (避免违反事实的包含关系)</li><li>在这个类需要应用的情况中, 类成员的是否满足所需的性质? 如可修改性, 唯一性, 可比较性(浮点数带来的精度问题), )可独立存在性(指针指向的独立内存空间)</li><li>在这个类需要应用的情况中, 类成员是否具有不能具备的性质? 如可访问性(public的滥用), 可修改性(const), 过大的取值范围(约束限制)等</li></ul><ol><li>尽量用访问函数获取类的属性<blockquote><p>Where possible, always use accessor functions to read and write the attributes of objects</p><p>有两个例子, 一个是文中给的: 一个line类有两个成员start和end, 当需要获取长度时, 为了不违背重复性的规则, 要用两个点计算这一长度, 但是这一计算通常是昂贵的, 于是设置一个distance, 在获取长度时, 先看起点和终点是否修改过了, 如果修改了就更新distance, 再传出.</p></blockquote></li></ol><p>另一个例子是getInstance()的作用, 用来得到静态指针指向的实例, 也是唯一的实例. 这两个例子都说明<strong>用访问函数存取属性可以做更多逻辑上的封装, 让类的设计更加合理</strong></p><ol><li>设计良好的可重复利用的生态环境<blockquote><p>What you’re trying to do is foster an environment where it’s easier to find and reuse existing stuff than to write it yourself.</p></blockquote></li></ol><p>这其实有分成两点: 对个人而言和对软件/语言生态而言.</p><p><strong>对个人而言, 尽量提高代码的可重复利用性</strong>, 这不仅是提高效率, 也是集中修改. 例如用一个utils类统一管理各种需要用到的静态方法, 或者用宏定义将多个数值定义统一.</p><p><strong>对生态环境而言, 简化调包方法, 降低调包风险.</strong></p><p>这是我结合语言更新来思考的, C++的调包并没有像python那么方便, 往往是直接copy别人的代码, 还要手动搜索接口说明. 复杂的复用方法让整个软件生态面临重复性的风险, 这直接带来<strong>性能不确定的第三方库</strong>, 然后导致开发者趋向于自己造轮子, 又带来了<strong>开发的复杂度上升和沟通成本的增加</strong>, 论坛的活跃度降低, 对新手而言也很不友好. 这些都会导致整个语言生态环境的没落.</p><h3 id="Orthogonality-正交性-解耦合"><a href="#Orthogonality-正交性-解耦合" class="headerlink" title="Orthogonality 正交性/解耦合"></a>Orthogonality 正交性/解耦合</h3><blockquote><p>You get two major benefits if you write orthogonal systems: increased productivity and reduced risk.</p></blockquote><p>正交性也就是解耦合, 书中总结了一些好处, 这里列出比较有新意的点:</p><ol><li>将问题局限化: 一个结构出问题以后整个错误只会在这个结构内, 这样就可以减少思考范围, 提高debug速度</li><li>避免对第三方库的依赖: 与第三方库解耦后, 只要接口合适, 可以任意更换成另一个库, 减少依赖性.<blockquote><p>Every change needs a meeting of the entire team, because any one of them might be affected</p></blockquote></li></ol><p>这是一个很有趣的点, <strong>对一个团队的解耦可以减小沟通成本</strong>, 也就是管理的时候, 将整个程序拆解成细分的几个子部件, 然后指名各个小团队制作, 这样确保每个级别只有较少的人参与研发, 沟通也富有效率, 然后部件与部件之间正交化, 一个团队的延误不影响其他团队的工作.</p><p>满足正交性以后, <strong>用模块化和层次化的思想构建一个系统</strong></p><img src="/2020/07/24/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Pragmatic_Programmer_%E6%9C%AD%E8%AE%B0/056f9a574fe47828a21074cf7e239d0d.png" srcset="/img/loading.gif" class=""><p>如图, 交互界面内部是模块化的, 而交互界面和数据库之间是层次化的. 层次化的东西下部只需向上提供接口, 同时模块化的东西, 各模块直接也只需提供接口. 这就保证了整个系统是可靠高效的.</p><blockquote><p><strong>Don’t rely on the properties of things you can’t control.</strong></p></blockquote><p>这一句话的例子是: 不要用电话号码去分辨每一个客户. 同样, 也不能用地区/姓名等区分每一个客户, 虽然在客户数量少的情况下这样做很有效. 但是最本质的是区分<strong>一个抽象的类和从属于类的成员的区别</strong>, 前者的独立性不可由后者的独立性保障, 也比如说, 一个对象的同一性判断不可以用内存中的位置来决定, 这是因为这个位置是对象的一个属性, 虽然这个位置对于一个对象是唯一的, 但很多情况下, 开发者所要的唯一性是脱离于对象生命周期的, 那么在这种时候就应该用别的方法去识别唯一性.</p><blockquote><p>If an object persistence scheme is transparent, then it’s orthogonal. If it requires you to create or access objects in a special way, then it’s not. Keeping such details isolated from your code has the added benefit of making it easier to change vendors in the future.</p></blockquote><p><strong>引入第三方库通常是增强耦合度的</strong>, 例如stl库, 从database到GUI都要调用其中的方法, 那么一旦修改其中的某个定义, 就一定会波及多个层. 在此基础上, 要么对引入的库谨慎判断, 要么自己封装一层接口, 不直接在代码中使用第三方库, 而是集中在接口使用.</p><p>对第三方库的可替代性也有判断标准, 就如这句话所说的, 如果第三方库的使用比较奇特, 那么就尽量不要引入. 最好的第三方库是transparent的</p><blockquote><p>With AOP, you implement logging orthogonally to the things being logged. Using the Java version of AOP, you could write a log message when entering any method of class Fred by coding the aspect:</p></blockquote><p>这下面是一个例子, 意思是说AOP让log不是由每个方法独自发出的, 而是在每个方法被调用时统一发出的, 这就避免了重复调用log, 而且AOP在你编写的时候就自然而然地适用, 不需要去对源代码进行任何改动.</p><p>以后在开发的时候, 可以用一个基类实现这些功能,</p><blockquote><p>In fact, we suggest that every module have its own unit test built into its code, and that these tests be performed automatically as part of the regular build process</p></blockquote><p>这是一个关于<strong>自动化测试</strong>的建议, 也就是每个组件自身有内部的测试, 组件自身包括功能和测试两部分, 一方面可以很方便地进行调用, 另一方面减小耦合度, 节省了编译的时间.</p><blockquote><p>With truly orthogonal documentation, you should be able to change the appearance dramatically without changing the content. Modern word processors provide style sheets and macros that help</p></blockquote><p><strong>文档的解耦</strong>, 也就是自动编写目录, 将格式与内容分离, 以及格式的统一控制等等.</p><h3 id="Reversibility-可逆性"><a href="#Reversibility-可逆性" class="headerlink" title="Reversibility 可逆性"></a>Reversibility 可逆性</h3><blockquote><p>If you keep decisions soft and pliable, it won’t be hard at all. If you have poor encapsulation, high coupling, and hard-coded logic or parameters in the code, it might be impossible.</p></blockquote><p>可逆性指<strong>面对未来需求的不确定性时, 如何编写出易于改动的软件系统</strong>, 书中提到的观点有两个:</p><ol><li>系统上, 为可能的改动预留空间</li><li>利用接口, 将第三方库封装在接口里面<br>注重系统的可逆性当然是有必要的, 可我觉得这里只提了这个趋势但是没有提到如何权衡: 假设第三方库要更换, 那么就要封装一层接口; 假设系统要更换, 就要设计可更改的模式. 可逆性越大的软件也越臃肿, 这样毫无疑问会降低开发效率. 那如何保持简洁又兼顾可逆性? 这里思考的应当不是哪些需求可能会改动, 而是哪些需求不会改动.</li></ol><p><strong>在确定的需求基础上, 编写出最独立,最小化的软件</strong></p><p>所以在刚开始的时候, 应当尽量确定一些不会改变的东西, 比如软件的功能, 软件使用的平台, 是否依赖网络, 软件的最大性能需求等等. 确定以后再思考可能会改动的部分, 比如软件的GUI界面, 软件的额外功能等. 在编写的时候应当尽量不包含会改动的部分, 比如尽量不引入第三方库(除非确定这个库拥有满足需求的性能), 对长期维护的项目, 要考虑第三方库的维护状态. 也要考虑代码的易读性.</p><h3 id="Tracer-Bullets-技术验证与原型构建"><a href="#Tracer-Bullets-技术验证与原型构建" class="headerlink" title="Tracer Bullets: 技术验证与原型构建"></a>Tracer Bullets: 技术验证与原型构建</h3><p>书中的tracer bullets来源于曳光弹的形象比喻, 它是一个用来验证技术是否可行的原型机, 并且这个原型机成为后续大规模开发的骨架, 其他功能陆续被添加到这个原型机上, 逐步改装, 最终完成.</p><p>与tracer bullets对应的conventional alternative是一次性集成, 或者是单向地设计-实现-集成这个模式. 单向化有两个弊端, 第一是<strong>在测试前无法得知技术的有效性, 风险大</strong>, 这也是我之前碰见的一个问题. 我在设计动态星球生成器的时候, 没有考虑到放大后的模糊效果和性能损耗, 最终开发出的东西无法运用在实际场景中. 另外一个弊端是<strong>模块化开发, 一次性集成的方法缺少实时激励, 无论是对开发者还是用户</strong>. 激励在软件开发中很有必要, 越复杂的系统越需要心理上拉出”战线”.</p><blockquote><p>A small body of code has low inertia—it is easy and quick to change.</p></blockquote><p>这是tracer bullets的另一个好处: <strong>技术验证的代码体量小, 易于修改</strong>.</p><blockquote><p>Prototyping generates disposable code. Tracer code is lean but complete, and forms part of the skeleton of the final system.</p></blockquote><p>这里强调了Tracer bullets和prototype的区别, 前者是一个<strong>完整的骨架加上小部分的实现</strong>, 后者是一个不完整的骨架加上完全的实现, tracer bullets是可以保留到最后的, 而且这个骨架就是实际应用的东西, 而不是一个供参考的原型机. 这样能确保tracer bullets工作在实际的情况中, 而且避免了最开始的重构工作.</p><blockquote><p>What sorts of things might you choose to investigate with a prototype? Anything that carries risk. Anything that hasn’t been tried before, or that is absolutely critical to the final system. Anything unproven, experimental, or doubtful. Anything you aren’t comfortable with.</p></blockquote><p>这里需要注意的是<strong>每一次尝试新事物的时候都最好做原型验证</strong>, 这样能有效避免风险. 在开发的时候无论时间是否充裕, 都应该采用最有效的开发方式, 在这种开发中技术失败的风险也会被考虑进去.</p><blockquote><p>It’s easy to become misled by the apparent completeness of a demonstrated prototype, and project sponsors or management may insist on deploying the prototype (or its progeny) if you don’t set the right expectations.</p></blockquote><p>prototype注意的是<strong>验证某个技术是否可行, 只需要一部分代码是正确的</strong>, 而tracer bullets不同, 它需要<strong>写出能完整运行的最小的正确代码, 不需要完整, 但是需要正确和能运行</strong>, 这就导致prototype必然被推翻重来.</p><blockquote><p>By coding at a higher level of abstraction, you are free to concentrate on solving domain problems, and can ignore petty implementation details.</p></blockquote><p>这是说<strong>在最初的时候不要考虑语言的具体细节, 只需要用一种伪代码描述出业务逻辑即可</strong>, 确实在思考问题的时候我默认都会从语言的角度思考可行性, 但是这是不对的, 因为理清业务逻辑不需要理清语言细节, 一个逻辑可以有很多实现, 而我在构建框架的时候并不需要去寻找最合适的实现, 甚至不需要关注是否能实现, 这些东西都是在实现的过程中考虑的.</p><blockquote><p>But with a mini-launguage, you would instead be able to issue an error message using the vocabulary of the domain.</p></blockquote><p>这也是站在业务逻辑思考的好处, 一些错误提示是基于语言或计算机系统本身的, 但这种提示是脱离<strong>业务语言</strong>的, 在业务语言中, 仅有业务本身的选择, 而将所有语法错误和执行错误都重新阐释为业务逻辑的错误.</p><blockquote><p>Given that most applications exceed their expected lifetimes, you’re probably better off biting the bullet and adopting the more complex and readable language up front</p></blockquote><p>软件是无生命的, 但是在使用的时候依然要考虑它的<strong>生命周期</strong>, 我的思考是, 在代码能够被理解的时候, 它是有活力的, 而当没有人能理解一段代码的时候, 代码就失去了活力, 而失去活力的代码会失去其价值.</p><p>开发和管理存在一个平衡: 富有活力的代码通常难以创造, 而管理没有活力的代码也非常困难. 所以这取决于这段代码的生命周期有多长: 生命周期为一天或几天的代码, 不需要开发文档, 只需要内部的注释. 而生命周期为半个月到一个月的代码, 需要开发文档, 但不需要对第三方库的维护. 而生命周期为一年到几年的代码, 则需要编写完善的开发文档, 并且尽量对第三方库封装接口, 从而让第三方库可以根据维护性更换.</p><p>生命周期应该看作代码本身的一个属性.</p><blockquote><p>We find that often the only way to determine the timetable for a project is by gaining experience on that same project.</p></blockquote><p>依据最开始的决定对整个项目的时间作规定是很不可靠的, 预估一个程序的开发时间最好的方法就是直接取开发这个程序. <strong>在开发过程中逐步确定剩余的时间, 并依照这个时间作决策</strong></p><p>也就是说, 整个开发计划是随着开发进程而变化的.</p><h3 id="ToolBox拥有自己的工具箱"><a href="#ToolBox拥有自己的工具箱" class="headerlink" title="ToolBox拥有自己的工具箱"></a>ToolBox拥有自己的工具箱</h3><blockquote><p>Many new programmers make the mistake of adopting a single power tool, such as a particular integrated development environment (IDE), and never leave its cozy interface.</p></blockquote><p><strong>每一种工具都有自身的优缺点, 没有哪个是完美的</strong>, 这也说明开发者应当掌握不同的工具来处理不同的情况, 用自身的经验加上合理调度来达成最优效率.</p><p>当然, 在一个开发进程中使用过多的工具也代表着很难被别人理解.</p><blockquote><p>As Pragmatic Programmers, our base material isn’t wood or iron, it’s knowledge.</p></blockquote><p>这一句话只是单纯看着很有哲学意味…</p><p><strong>Plain text</strong></p><p>可以翻译作”朴素的文本形式”, 书中对平面文本比较推崇, 它的优点是可以被人理解, <strong>对于一些在使用时需要被理解的东西, 通常以文本的形式保存</strong></p><p>但也有缺点, plain text占空间大, 同时在读取和写入的时候比较昂贵. 一些其他的缺点其实并不是plain text的锅, 例如易读性. 二进制的东西读取并不困难, 同时plain text也可以通过加密形式存储.</p><p><strong>Using Unix Tools Under Windows</strong></p><blockquote><p>But if you do all your work using GUIs, you are missing out on the full capabilities of your environment. You won’t be able to automate common tasks, or use the full power of the tools available to you. And you won’t be able to combine your tools to create customized macro tools.</p></blockquote><p>确实GUI在自动化处理上有些问题, 但是我觉得并不需要强行在GUI和命令行之间作划分, 有时候<strong>简单的操作由GUI完成, 自动化的东西交给命令行</strong>, 这样应该能保持效率的最大化?</p><p><strong>Use a single editor well</strong></p><p>最好选择一个编辑器来熟悉, 然后充分利用它的快捷键提高效率.</p><p>好的编辑器有以下特征:</p><ol><li>可配置, 可以自行配置让编辑器符合自己的喜好</li><li>可拓展, 可以添加新的内容</li><li>可编程, 可以自己设计复杂的组合操作</li></ol><p><strong>Always Use Source Code Control</strong></p><blockquote><p>There is a tremendous hidden benefit in having an entire project under the umbrella of a source code control system: you can have product builds that are automatic and repeatable.</p></blockquote><p>书中的观点是: 源代码管理不仅可以适用于代码, 更适用于任何自己编写的东西, 比如脚本, 管理文档等. 这样可以随时退回到之前的操作, 非常方便.</p><p>所以对于任何可以被管理的文件, 尽量把他们应用在源代码管理中</p><h3 id="Debugging-调试"><a href="#Debugging-调试" class="headerlink" title="Debugging 调试"></a>Debugging 调试</h3><p>书中总结了几条调试的规则, 这里简要列出:</p><ol><li>bug复现</li><li>数据可视化</li><li>程序运行追踪</li><li>先假设自己的代码有问题, 再思考第三方代码是否有问题</li><li>不要假设哪些代码是必定正确运行的, 而是去证明它</li><li>在找到代码之后, 反思如何避免它<h3 id="Text-Manipulation-文本操作"><a href="#Text-Manipulation-文本操作" class="headerlink" title="Text Manipulation 文本操作"></a>Text Manipulation 文本操作</h3></li></ol><p>文本操作的一些功能:(以Perl为例)</p><ol><li>建立数据库</li><li>自动方法生成</li><li>测试数据生成</li><li>抽取声明和接口</li><li>生成文档<blockquote><p>Write Code That Writes Code.</p></blockquote></li></ol><p>这句话解释了自动处理的重要性. 建立一个代码生成器是很有必要的, 这里是一些功能:</p><ol><li>创建新的文件, 并应用模版</li><li>执行自动的格式转换操作</li><li>执行预处理操作</li><li>执行给定的同步操作或一致性检查</li><li>手动处理一些源代码中的可变片段(结构体等)<h3 id="Pragmatic-Paranoia-偏执心理"><a href="#Pragmatic-Paranoia-偏执心理" class="headerlink" title="Pragmatic Paranoia 偏执心理"></a>Pragmatic Paranoia 偏执心理</h3></li></ol><blockquote><p>You Can’t Write Perfect Software</p></blockquote><p>这句话也是我感触比较深的, 在写程序的时候当然要追求效率, 但是不要追求完美. 因为完美的程序一般都会花费远远大于预定的时间来开发, 在绝大多数时候我只需要一个简单够用的程序.</p><p><strong>Design by Contract</strong></p><p>这是确保程序在正确性和完美之间的找到平衡的一个方法, 简单来说, 就是在给定条件下, 一个方法能确保结果中的一部分被正确呈现, 而一些模糊的部分会怎么样, 并没有被规定.</p><p>DBC包含三个部分: 调用者必定凑齐的条件, 依照条件返回结果的方法, 和检查条件与结果是否正确的class</p><blockquote><p>Subclasses must be usable through the base class interface without the need for the user to know the difference.</p></blockquote><p>这是继承的一个原则: <strong>继承类必须在调用基类接口的时候表现得和基类一样</strong>, 不然继承的原则就会被破坏, 这里的表现得一样不是指一样的输出, 而是输入范围至少要和基类的范围一样. 也就是说在用户使用继承类的基类接口的时候, 用户可以当做基类来使用而不会产生错误.</p><p>DBC在C++中有预处理器来保证, 如<strong>Nana</strong>, 在JAVA中有<strong>iContrast</strong></p><blockquote><p>With enough components and agents that can negotiate their own contracts among themselves to achieve a goal, we might just solve the software productivity crisis by letting software solve it for us.</p></blockquote><p>有时候面对输入不一样的情况, 并不总是将其当作<strong>错误</strong>, 而对于特殊情况, 依然能返回正确的结果, 那么程序本身在扩展的时候就自动地找出复杂范围的可行方案(例如类型推断)</p><p><strong>crash earlier</strong></p><blockquote><p>when your code discovers that something that was supposed to be impossible just happened, your program is no longer viable.</p></blockquote><p><strong>在程序最开始出错的地方停止</strong>, 一方面是避免后续的报错影响debug思路, 另一方面是避免重要的数据被错误地覆盖.</p><p>另外, 为了尽早检测出错误, 在每一个模块都应当设置<strong>检测运行状态合理性的代码</strong>, 也是为以后的debug留下线索</p><blockquote><p>If It Can’t Happen, Use Assertions to Ensure That It Won’t</p></blockquote><p>很多时候在编程中会默认加上一些条件, 然后根据这些假设编程, 但是<strong>对正确性的检测不能因为主观的假设而偏颇</strong>, 此时使用Assertion来显式表达自己的假设.</p><p>但是要注意, 断言中不能存放任何业务逻辑的代码, 因为断言可能在编译时被关闭.</p><blockquote><p>First, they assume that testing finds all the bugs. Second, the optimists are forgetting that your program runs in a dangerous world.</p></blockquote><p>这是<strong>Assertion不仅用于debug</strong>的原因, 因为断言针对的是所有潜在bug和不正确的输入</p><blockquote><p>For example, if your code tries to open a file for reading and that file does not exist, should an exception be raised?</p></blockquote><p>这就涉及到exception的意义: <strong>exception用在处理设计者意想不到的状况, 不能参与正常的业务逻辑处理</strong></p><p>同时, 大量的异常处理会打乱整个代码的逻辑, 我们在debug的时候用exception<strong>只需要知道大概的范围, 但不需要精确到每一步</strong>,因此抛出异常的也只是一个try块, 最好不要是每一行代码都检测.</p><p>以我之前的经验, 在捕获异常的时候, 最好直接用<strong>方法+功能来定位</strong>, 这样设计者既可以直接找到出错的地方, 也可以知道运行的宏观逻辑.</p><blockquote><p>An error handler is a routine that is called when an error is detected.</p></blockquote><p>可以设计一个专门用来处理异常信息的接口, 便于异常的管理和查找</p><blockquote><p>Finish What You Start</p></blockquote><p>尽量在同一个方法内完成打开和关闭操作, 否则很容易出现多次打开或不正确的打开时机等问题</p><p>也可以利用语言内部的对称性, 将资源的打开关闭放在构造和析构函数里. <strong>用一个类实例作为资源的抽象</strong>, 同样的, 这种方式也能避免在throw exception的时候没有释放资源, 因为资源会随着C++的特性自动释放</p><p><strong>deallocate structure</strong></p><p>书中给了三种方式:</p><ol><li>父结构自行负责子结构资源的分配和释放</li><li>父结构不管子结构, 每个结构独立管理资源的分配和释放</li><li>如果父结构还有子结构的资源, 则拒绝释放.(外部管理)<h3 id="flexible-适应性强的代码"><a href="#flexible-适应性强的代码" class="headerlink" title="flexible 适应性强的代码"></a>flexible 适应性强的代码</h3></li></ol><blockquote><p>A good way to stay flexible is to write less code.</p></blockquote><p>这个建议很简单, 只要不写代码, 就能降低代码的修改难度. <strong>保持代码的简洁性也是增强适应性的一个方式</strong></p><blockquote><p>Rather than digging though a hierarchy yourself, just ask for what you need directly.</p></blockquote><p>在一个类中对另一个类的接口调用<strong>尽量只调用浅层的方法</strong>, 因为如果一连串地调用, 就减少了封装的程度, 增加了耦合度.</p><p><strong>The Law of Demeter for Functions</strong></p><p>任何方法只能调用:</p><ol><li>自身的方法</li><li>传入参数的方法</li><li>方法定义域中生成的实例的方法.<blockquote><p>First, we want to make our systems highly configurable. Not just things such as screen colors and prompt text, but deeply ingrained items such as the choice of algorithms, database products, middleware technology, and user-interface style.</p></blockquote></li></ol><p>从<strong>外部定制</strong>来说, 可定制的远远不止用户的flavor, 更包含开发者的可选项. <strong>用文件来定制被每次都修改源代码更加优美</strong></p><p>可定制的有很多, 比如运行路径, 用户界面, 平台等.</p><blockquote><p>Our goal is to think declaratively (specifying what is to be done, not how) and create highly dynamic and adaptable programs. We do this by adopting a general rule: program for the general case, and put the specifics somewhere else—outside the compiled code base.</p></blockquote><p>这一段写的非常出乎我意料. *<em>我们写出的程序是一次性编译的, 那么就不应该存在特定的目的. *</em></p><p>最理想的状态是用metadata描述程序的功能, 然后整个程序是一个引擎, 对描述进行解析, 并按照预想的方式运行. 这样, 程序的功能部分用人类语言描述出来, 保留了大部分业务逻辑的信息. 然后引擎本身也是高度解耦的, 可以较大程度覆盖可能的业务逻辑.</p><p>在工作场景里, 写一个程序不仅要覆盖给定的需求, 更要在拓展潜在需求上尽量做到健壮, 灵活. 这种写程序的目标是整个可能性的组合, 而不是一个单一的目的.</p><h3 id="workflow-用户的操作空间"><a href="#workflow-用户的操作空间" class="headerlink" title="workflow 用户的操作空间"></a>workflow 用户的操作空间</h3><blockquote><p>It can be eye-opening to see where the dependencies really exist.</p></blockquote><p>workflow用在这种地方: 用户可以执行不同的操作, 但是一些操作需要在另一些操作执行完以后才能执行. 那么如何设计程序? 这就是<strong>用图形表达出用户可能的所有操作, 即一个操作空间</strong></p><p>基于操作空间, 可以设计前端的结构:</p><blockquote><p>In a hungry consumer model, you replace the central scheduler with a number of independent consumer tasks and a centralized work queue.</p></blockquote><p>序列化, 也就是将用户的操作拆分成<strong>去中心化的动作, 然后放在中心化的序列中</strong>, 这种设置比用很多flag表示要有效得多.</p><p>同时, 可以将多个序列进行拆分重组, 进而达到多线程的目的. 上述的workflow检测依赖性, 然后将满足解耦条件的动作从序列中抽出. 也可以合并多个序列, 只要检测能否互相并存即可. 这种情况下, <strong>所有的依赖性都可以通过检测序列来实现</strong></p><h3 id="concurrency-同时性"><a href="#concurrency-同时性" class="headerlink" title="concurrency 同时性"></a>concurrency 同时性</h3><blockquote><p>Because things can now happen at the “same time,” you may suddenly see some time-based dependencies.</p></blockquote><p>多线程并不是”麻烦”的技术, 相反, 多线程给代码设置更高的要求, 让一些低劣的代码不能正常运行, 这促使开发者提高编程水平.</p><h3 id="Publish-Subscribe消息机制"><a href="#Publish-Subscribe消息机制" class="headerlink" title="Publish/Subscribe消息机制"></a>Publish/Subscribe消息机制</h3><blockquote><p>Objects should be able to register to receive only the events they need, and should never be sent events they don’t need.</p></blockquote><p>这个消息通知机制就是cocos2d里用到的机制: <strong>接受者向发送者注册, 然后发送者每回发送的时候, 都向注册了的组件发出通知</strong></p><p>这里我有一些启发: 对于可以通信的东西, 它们交流代码媒介是什么呢? 既然消息是去中心化的, 那么交流一定要有一个共同语言. 而<strong>共同的基类就是组件间交流的语言</strong>, 当组件都有相同的基类的时候, 组件间的交流就可以基于这个语言, 当然也只能限于这个语言.</p><h3 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h3><p><a href="https://baike.baidu.com/item/MVC%E6%A1%86%E6%9E%B6/9241230?fromtitle=MVC%E6%A8%A1%E5%BC%8F&fromid=713147&fr=aladdin" target="_blank" rel="noopener">MVC设计模式</a></p><blockquote><p>separating the model from both the GUI that represents it and the controls that manage the view</p></blockquote><p>这是MVC的设计思想:<strong>数据被封装成一个model, 读取和写入都是单向的</strong>,</p><p>MVC的设计思想不仅用在GUI的设计中, 只要是涉及数据+交互的, 都可以用MVC进行解耦.</p><h3 id="Blackboard-匿名论坛设计模式"><a href="#Blackboard-匿名论坛设计模式" class="headerlink" title="Blackboard 匿名论坛设计模式"></a>Blackboard 匿名论坛设计模式</h3><blockquote><p>A blackboard system lets us decouple our objects from each other completely, providing a forum where knowledge consumers and producers can exchange data anonymously and asynchronously.</p></blockquote><p>黑板设计模式的意义在于<strong>黑板本身仅是一个容器, 而业务逻辑被分散到各个组件中去</strong>, 这是去中心化的. 去中心化有它的好处, 对于非常复杂的规则, 如果编写一个中心化的东西(可以参考桌游的gm), 那么对所有情况进行组合是非常困难的. 但是现实中很多逻辑本身就是去中心化的, 比如人与人的交流活动, 而将去中心化的东西用程序实现, 就涉及到一个”论坛”, 论坛中的讨论者是去中心化的, 但是论坛本身是中心化的, 这样就可以做到组件的充分解耦.</p><p>我也想把这个模式叫做<strong>匿名论坛模式</strong></p><h3 id="Programming-by-Coincidence"><a href="#Programming-by-Coincidence" class="headerlink" title="Programming by Coincidence"></a>Programming by Coincidence</h3><blockquote><p>As developers, we also work in minefields.</p></blockquote><p>要避免coding中的一些潜在问题, 我摘选了几点比较好的建议:</p><ol><li>在运用新技术时一定要先作技术验证, 避免产生歧义.</li><li>不要依赖潜在的东西, 比如语言, 平台, 和测试的特定接口</li><li>在测试的时候, 不仅确保结果正确, 也确保过程和预想的一样.</li><li>不要为了兼容而兼容, 在适当的时候就要果断进行重构<h3 id="optimizing-性能优化"><a href="#optimizing-性能优化" class="headerlink" title="optimizing 性能优化"></a>optimizing 性能优化</h3></li></ol><p>这部分还是关于时间复杂度的, 但是程序整体的性能瓶颈并不一定是算法, 也可能是读写速度, 存储空间等</p><h3 id="refactor-重构"><a href="#refactor-重构" class="headerlink" title="refactor 重构"></a>refactor 重构</h3><p>四个重构的场景:</p><ol><li>代码有重复性(DRY)</li><li>代码耦合度高</li><li>代码中应用的assumption过于陈旧</li><li>有性能瓶颈<blockquote><p>Don’t try to refactor and add functionality at the same time.</p></blockquote></li></ol><p>重构的理念是<strong>小步重构, 大量测试</strong>, 也就是不要在重构的时候无意间改变了原先的业务逻辑.</p><h3 id="test-测试"><a href="#test-测试" class="headerlink" title="test 测试"></a>test 测试</h3><blockquote><p>In C++ you can achieve the same effect (at compile time) by using #ifdef to compile unit test code selectively.</p></blockquote><p>之前有提到说每一个模块都应该带有对自身的测试代码, 那么这些测试代码就可以放在宏定义里面. 当然, <strong>测试的逻辑一定要和业务逻辑的代码解耦</strong></p><blockquote><p>A test harness can handle common operations such as logging status, analyzing output for expected results, and selecting and running the tests.</p></blockquote><p>我认为每个系统的测试都是不一样的, 很难做到同一个测试系统用于不同的代码, 但是在log中对error和warning由专门的分类比直接用string写字符串要好很多.</p><p>我认为一个良好的log应该是包含<strong>可视化, 分级, 折叠, 自动保存信息</strong>等功能, 用不同的颜色输出error和warning, 然后每次输出后都保存到文档中, 以便下次调试时比较. 对于比较复杂的系统, 将次要的输出信息折叠起来, 只保留主要部分.</p><p>但与其对一段不良的代码做许多测试, 还不如<strong>尽量编写没有bug的代码</strong>,通过改良编程习惯, 加深对底层的理解,做到防患于未然</p><blockquote><p>The wizard code is not factored out behind a tidy interface—it is interwoven line by line with functionality that Joe writes.</p></blockquote><p>这里的wizard指的是自动代码生成器, 就像自动类框架生成这种东西. 但是使用的条件是开发者必须完全熟悉wizard生成的代码, 因为这些代码是全面地和开发者的代码混合的.</p><h3 id="The-Requirements-Pit-充分理解需求"><a href="#The-Requirements-Pit-充分理解需求" class="headerlink" title="The Requirements Pit 充分理解需求"></a>The Requirements Pit 充分理解需求</h3><blockquote><p>Requirements rarely lie on the surface. Normally, they’re buried deep beneath layers of assumptions, misconceptions, and politics.</p></blockquote><p>寻找<strong>真正的需求</strong>确实是比较困难的, 有时候难以想象完全整个交互场景, 有时候没有真正拆解需求的组合, 导致设计的框架过于复杂.</p><blockquote><p>It’s important to discover the underlying reason why users do a particular thing, rather than just the way they currently do it.</p></blockquote><p>真正的需求可能连用户自己都不清楚, 因为<strong>一个单一的需求无法决定整个程序框架, 可能的需求和潜在的变动一同组成的需求域才能决定程序哪方面需要flexible</strong></p><p>另一个了解需求的方法是: 假设自己是用户. 也就是站在用户的角度思考自己计划的设计是否足够强大, 且足够方便.</p><blockquote><p>Don’t be a slave to any notation; use whatever method best communicates the requirements with your audience.</p></blockquote><p>在理解并记录需求的时候需要的是最符合业务逻辑的语言, <strong>业务逻辑的语言并不局限于任何一种图表或记号</strong></p><h3 id="Maintain-a-Glossary-制作术语表"><a href="#Maintain-a-Glossary-制作术语表" class="headerlink" title="Maintain a Glossary 制作术语表"></a>Maintain a Glossary 制作术语表</h3><p>这也是一个<strong>标准化</strong>的东西, 对文档中的描述给定一个准确的定义, 当然这主要用在大型项目中. 从共同的语言中特异化一些东西来描述业务逻辑, 可以说是一种”业务语言”</p><h3 id="while-in-coding"><a href="#while-in-coding" class="headerlink" title="while in coding"></a>while in coding</h3><p>这一节实际上是之前的小节的汇总, 包含一些我觉得很有用的观点.</p><ol><li>在开始项目之前做技术验证和原型建模</li><li>在开始项目之前先扫除直觉上的担忧</li><li>不要写太多太详细的技术文档, 要拥有较强的灵活性<blockquote><p>Often, it is only during coding that certain options become apparent.</p></blockquote></li></ol><p>我也有类似的经验, 写着写着才发现有的地方可以用很巧妙的方式实现, 或者以另一个方式拓展. 但是否要遵循这种方向? 我觉得应该要看这个拓展性是不是符合项目需求或潜在需求的.</p><blockquote><p>Never underestimate the cost of adopting new tools and methods.</p></blockquote><p>这是建议不要在正式项目中<strong>过多使用不熟悉的技术</strong>, 同样地, 框架设计应该在满足需求的同时尽可能简洁, 而不是在没有必要的地方留下拓展接口.</p><blockquote><p>Test Early. Test Often. Test Automatically.</p></blockquote><p>在集成化测试前作单元测试是很有必要的, 因为越是复杂的不可靠系统越难找到真正的bug, 最好在每次build时都自动地进行测试</p><h3 id="comments-注释"><a href="#comments-注释" class="headerlink" title="comments 注释"></a>comments 注释</h3><blockquote><p>In general, comments should discuss why something is done, its purpose and its goal.</p></blockquote><p>注释是另一个维度的东西, 注释补全了代码中人的意图和业务逻辑, <strong>注释和代码是互补的, 是高层次的逻辑抽象, 而不是代码的翻译</strong></p><p>与doxygen相反地, 可以把<strong>设计文档的一部分通过自动生成器同步到代码注释中去</strong>, 也可以将代码注释和技术文档各自独立, 并单向集成到API Reference中</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>读完真是身心俱疲…</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>编程思想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程设开发总结</title>
    <link href="/2020/07/24/%E7%A8%8B%E8%AE%BE%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <url>/2020/07/24/%E7%A8%8B%E8%AE%BE%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="2020年7月程设开发总结"><a href="#2020年7月程设开发总结" class="headerlink" title="2020年7月程设开发总结"></a>2020年7月程设开发总结</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今年6月上旬到七月初的这二十多天大概是我人生中第一次写一个3K-5K量级的项目, 从第一天对游戏引擎完全不了解, 到自己用一下午去设计一个UI界面, 甚至去分析飞船的结构特点, 最终用稍微超过预期的时间完成了一个勉强满意的”模具”, 虽然离理想中的游戏差距很多, 但是提供了一个可以完善的平台, 让我有信心继续做下去. 中间着实有不少困难, 甚至让最初企划时的兴奋感都消散殆尽, 但是能做出一个能代表自己风格的作品, 确实是一件有意义的事, 甚至可以说没有什么比自我实现这种事更有意义了.</p><p>当然, 在这种量级的开发中, 尽管已经提前设想过一些解决方案, 但还是遇到了意料之外的情况. 设计的理念也有待改进. 这篇文章就是总结这些琐碎的东西的.</p><h3 id="健壮性和复杂性-应当考虑不变的是什么-而不是可变的是什么"><a href="#健壮性和复杂性-应当考虑不变的是什么-而不是可变的是什么" class="headerlink" title="健壮性和复杂性: 应当考虑不变的是什么, 而不是可变的是什么."></a>健壮性和复杂性: 应当考虑不变的是什么, 而不是可变的是什么.</h3><p>在写这个游戏的最开始, 我的构想还不是很成熟, 于是最初的目标就是: 尽可能保证底层设计的健壮性, 这样以后再变动设计时就能尽量减小重构次数. 依照这个方案, 前期对底层的处理确实比较模块化, 同时避免了后面的许多问题. 但是这样也使得整个设计非常复杂, 在处理<strong>类的相互包含问题</strong>的时候, 我之前设计的复杂的相互引用机制让debug变得异常困难. 如果舍弃这个机制, 整个底层都要重构, 好在最后尽量避免了相互引用, 然后<strong>把独立的方法集成到一个工具类中</strong>, 这样就确定了一个不循环的结构关系, 当然<strong>如何设计一个自顶而下又可以互相通信的机制</strong>也是我没考虑过的问题. 所以这里我先提出一点想法:</p><p><strong>在设计的时候先考虑哪些需求是不会改变的, 再以此设计一个最精简的系统</strong></p><p>就例如游戏中的各个scene, 整个游戏流程只需要提供一个实例, 那么scene只需要一个静态成员存放instance就可以了, 然后用getInstance()方法, 完全可以避免成员需要拿指针的问题. DataLoader也是, 同一时间只能加载一个存放的内容, 不同存档不需要交换信息, 而且DataLoader的类型也是确定的: 加载游戏配置数据和玩家存档里的数据, 这样就只要设定两个静态成员就可以了.</p><h3 id="对内部细节的封装"><a href="#对内部细节的封装" class="headerlink" title="对内部细节的封装"></a>对内部细节的封装</h3><p>一开始我对飞机的定义很不明确, 武器是否可更换? 飞机是否可更换? 飞机型号是否有特殊技能? 是否有特定的增益? 但在设计的时候应该始终把飞机看作一个”黑箱”, 对战斗scene来说, 只要能获取飞机的位置/血量等数据就可以, 而不需要关注内部的东西, 同样整个level生产的也无外乎飞机/子弹/掉落物/特效等, 设计的时候就设计几个基类供level调用即可.</p><h3 id="代码的可维护性"><a href="#代码的可维护性" class="headerlink" title="代码的可维护性"></a>代码的可维护性</h3><p>写到后面的时候时常会犯一些低级错误: 重载函数写错了参数列表, if语句中==少打了一个=, 还有各种约定的规则没有被遵守. coding的过程也是<strong>不断制定规则的过程</strong>, 但是这些规则在编写的时候制定下来, 又如何保证一定能被遵守呢? <strong>任何程序员自行编写的规则都尽量要做到强制被遵守</strong>, 例如两个函数调用前后的顺序, 就用isLoaded来检测, 在没有遵守的时候抛出异常, 又如Reflection这个类的机制, 这是个反例, 所有的飞机都需要在创建的时候手动向反射表注册, 这样并不符合上面所说的理念. 这个改进的方案还没想好(也许没有?), 但是像这种规则即使不能避免, 也要及时整理在技术文档里.</p><p>save里的数据也缺乏维护性, 这是因为最初的时候对<strong>飞机/子弹的实例和模版概念没有分清</strong>导致的, 按理说save里只能存放实例, 也就是一些具有特异性的东西, 但是<strong>属性本身就是有变和不变两个性质的</strong>, 属性的数量/类别/作用都是不变的, 但属性的数值却是可变的, 所以一个武器的属性表就应该同时存放在gameData和save里, 同时这里实例的概念是什么? 是拥有相同属性, 相同的类模版, 但属性数值可以不同的一些飞船. 一个实例并不代表游戏里的一个飞船, 事实上<strong>实例本身仅有数值特意化的功能, 实际生成的数量是由程序控制的, 每个游戏内实体的区分也仅靠内存地址的不同</strong>, storage里存放的实例都是不同的, 因为给玩家相同参数的东西没有意义, 所以每个物品对应一个实例, 但level里的实例是可复用的, 因为生成的飞机基本都是一样的外观, 方便动态控制生成的数量. 这也限制了按照实例查找个体的范围, 这个范围是不能包括可复用实例的区域的.</p><p>像这种唯一性的确定规则, 应当在设计的时候就想好. 后期更改会带来很大的麻烦</p><h3 id="开发进度的可视化-amp-迭代开发"><a href="#开发进度的可视化-amp-迭代开发" class="headerlink" title="开发进度的可视化&amp;迭代开发"></a>开发进度的可视化&amp;迭代开发</h3><p>整个开发过程最艰难的大概就是做UI和写行星生成器的时候, 这里我的开发流程并不合理, 首先行星生成器我花了3天时间研究, 但是结果上这一个东西因为性能原因不能产生大面积的可动背景, 而这三天里, 我并没有做任何推动开发进度的东西, 导致写完以后一度丧失了进行下去的信心. <strong>对一个独立开发者而言, 如何规定开发计划, 让整个开发进度可视化, 并得到充分的反馈, 是开发能否进行下去的关键</strong>, 在做行星生成器的时候, 我把整个游戏背景设计/UI设计完全押注在这一个技术的实现上, 然而这种是很危险的. 对一个最精简框架所必须的UI, 背景图片而言, 他们虽然要遵循一个统一的视觉形象, 但是不能依赖一个未知能否实现的技术.</p><p>在规划的时候也应该从最精简的框架入手, 先<strong>搭建出一个能用的东西, 再去思考怎样让它变得更好</strong>. 过度追求完美是很危险的, 就像我在写行星生成器的时候, 过度想让它完美呈现, 却因此破坏了整个游戏的开发进程, 也破坏了迭代开发的原则. 以后的设计中要避免各个技术的相互耦合, 对于难度高的技术, 尽量先写一个可用的版本, 再去完善它.</p><h3 id="文档规范化-amp-注释规范化"><a href="#文档规范化-amp-注释规范化" class="headerlink" title="文档规范化&amp;注释规范化"></a>文档规范化&amp;注释规范化</h3><p>这次没有用doxygen生成文档, 虽然写了许多注释, 但回看的时候效果都很差: <strong>太少注释让人无法理解运行原理, 太多注释让人花费大量的时间在浏览无用信息上</strong>, 后期修改一个源文件的时候, 经常在十几个方法里面寻找, 但是在中途就忘记了自己要找什么东西. 同时满足注释的详细程度和检索遍历程度, 听起来是矛盾的, 但其实也有方法: <strong>一些注释是只需要全局检索的, 例如TODO, 那么只要有可检索的关键字就行了</strong>, 而需要让人了解”这个方法是干什么的”这些注释, 不能写得太过琐碎, 最好写出<strong>一整块注释, 大致说明代码的功能, 需要特别注意的地方在所在行添加注释</strong>, 这样就不必在繁多的注释行中不断阅读.</p><p>doxygen也是比较方便的, 但是我还没有关注过注释的可维护性, 在对程序进行修改的时候, 注释很难进行同步修改, 这也是我写大量功能性注释的弊端:<strong>注释太多反而加大了修改的工作量, 也增添了额外的规则</strong>, 而最好是在一段代码通过稳定测试以后再写一个总结性质的注释.</p><h3 id="过程中的奇异bug们与一些零碎经验"><a href="#过程中的奇异bug们与一些零碎经验" class="headerlink" title="过程中的奇异bug们与一些零碎经验"></a>过程中的奇异bug们与一些零碎经验</h3><p>开发过程中也遇上了一些奇怪的bug:</p><ol><li><p>枚举的size{small,medium,large}中的small与cocos2d命名空间的一个宏定义重名(所以<strong>一般在cpp里用using namespace而不要在头文件里用</strong>)</p></li><li><p>设置rotation后再设置anchorPoint总是显示错位, 后来发现是因为旋转后锚点的位置也会在坐标系中改变</p></li><li><p>提示nullptr, 是因为垃圾自动回收机制导致的</p></li><li><p>用removeChildByName的时候, 对参数理解不到位, 导致后来一些奇奇怪怪的报错(以后要多看reference)<br>也有一些零碎的东西需要改进</p></li><li><p>cocos2d::ui这个命名空间太长了, 最好用 <code>namespace vlns = very::long::namespace</code> 削短</p></li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
      <category>游戏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏开发</tag>
      
      <tag>cocos2d</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020SummerGame：美工设计笔记</title>
    <link href="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="2020SummerGame：美工设计笔记"><a href="#2020SummerGame：美工设计笔记" class="headerlink" title="2020SummerGame：美工设计笔记"></a>2020SummerGame：美工设计笔记</h1><h2 id="美工设计笔记——飞船设计P"><a href="#美工设计笔记——飞船设计P" class="headerlink" title="美工设计笔记——飞船设计P"></a>美工设计笔记——飞船设计P</h2><p>因为假期时间很充裕，这次游戏的美工打算自己画，也是积累一些美术方面的经验。整个学习过程就是：观看优秀的美工设计-总结各自的优缺点和风格特异性-尝试转移到自己的设计上。而关于理论方面，我打算先自己看完优秀案例再学习理论基础，以便能随时与实践联系起来。</p><p>初步来说，整体的美工设计包括飞船设计、武器设计、子弹/激光等特效设计，爆炸效果设计，游戏背景设计，UI设计，宝石设计。当然整体的风格要统一。</p><h3 id="Star-sector飞船拆解：涂装、外壳纹理、外壳结构、内部器件、功能模块"><a href="#Star-sector飞船拆解：涂装、外壳纹理、外壳结构、内部器件、功能模块" class="headerlink" title="Star sector飞船拆解：涂装、外壳纹理、外壳结构、内部器件、功能模块"></a>Star sector飞船拆解：涂装、外壳纹理、外壳结构、内部器件、功能模块</h3><p>Star sector的飞船设计很明显的特点就是：各方阵容特色鲜明，整体造型统一，同时与UI搭配和谐。整体拆解如上所说，但是部分结构还是需要细分：首先关注一下打光，star sector的飞船打光大都是<strong>从上向下的点光源或线光源</strong>，打光区分<strong>球面</strong>和<strong>圆盘</strong>，同时根据反光度的不同，区分<strong>外壳</strong>和内部<strong>器件</strong>，同时根据光和阴影的分布，可以将飞船的曲面表示出来，许多飞船<strong>中间亮两边暗</strong>，整体呈现半球形的曲面分布。</p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/b9a5e2688026aea33132a83487f68bbb.png" srcset="/img/loading.gif" class=""><p>（打光下的球体，注意两个小球的光点并不在中间，这种对应的物理结构我还没搞清楚）</p><p>不同阵营的涂装、外壳结构、外壳纹理是不同的。<strong>外壳覆盖范围</strong>有全覆盖型（看起来很坚固，但是速度缓慢）、半覆盖型、贴边覆盖型（只有贴边的平行装甲，中间部分都是露出的）、无覆盖型（找不到光滑面，都是内部器件）。按照<strong>对称性</strong>划分可以有对称型和不规则型，其中不规则型大多采用圆滑设计，来保持整体美观。同样，根据势力范围不同，飞船的<strong>基本图案</strong>也是不同的，分为以平行四边形为基础和以圆形为基础。但是，在各个阵营的飞船中也能找到共同的东西，比如<strong>统一为白色的舰桥</strong>：</p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/71532e57a67ac4f036ba59f9177281ef.png" srcset="/img/loading.gif" class=""><p>当外壳结构确定好后，外壳纹理起到细化的作用。<strong>拼装式外壳纹理</strong>经常在以圆形为基础的飞船上看见，此时飞船表面像是被设计好的几块外壳拼装出来一样：</p><p><strong>搭建式外壳纹理</strong>在以平行四边形为基础的飞船上看见，此时飞船表面各部件有实际的层次。这是因为拼装出的类似球状在光的渲染下比较好看，而如果平行四边形采用拼装式，那么只能得到一块平面，如果平行四边形在3维空间采用曲面设计的话，就其二维特征不统一了，反而会破坏飞船的美感。</p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/6a8b6a51709adf96539ca7cf85bc9ecf.png" srcset="/img/loading.gif" class=""><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/1e18c10bef9b8a3e85fc039c0db29d29.png" srcset="/img/loading.gif" class=""><p>再来看下涂装，starsector飞船有涂装的很少，但是涂装能大大改善单个机体的外观确是无疑的。涂装分为两种：<strong>线型涂装</strong>主要沿机体方向勾勒出一条或几条线，它能直接把繁复的装甲结构统一成一个整体，由涂装飞船获得了精细与整体性的平衡。而<strong>面型涂装</strong>主要是有装饰作用，所有外壳刷上统一色系的涂装会强烈凸显出外壳与内部器件的对比感。另外，当飞船装甲过大时，合理利用涂装以显示分区可以让整体更加醒目</p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/27a23ea4f02a4091df97886fb83ac69d.png" srcset="/img/loading.gif" class=""><p>此外，海盗在其他势力的制式飞船上加涂装更能彰显其个性——这也是其他制式飞船很少画涂装的原因。</p><p>飞船的功能结构与其游戏内容是契合的，这里发现的<strong>功能结构</strong>有武器（机枪、激光）、机库、舰桥（航母有大舰桥，小飞机有小的舰桥）、引擎周围的导热管、货仓、存储罐、舷窗（有黄色亮光）、飞机指示灯（在机翼边缘）、反应装甲（这是从坦克上借鉴的）</p><p>飞船的“内部器件”是具有重要功能的模块，颜色一般以灰色、深灰色为主，内容主要是<strong>平行的管线</strong>、<strong>类似集成电路的设计</strong>，内部器件被故意设计成繁复的，一是为了凸显<strong>飞船的真实性</strong>，比如引擎给人的印象就是复杂，这种设计能突出引擎特征，二是与相对简单的装甲形成<strong>强烈对比</strong>，增添飞船层次性，让整个设计错落有致。在外壳周围的一些暗部设计很好地起到了<strong>装饰边缘</strong>的作用。</p><p>综合起来，starsector的飞船设计理念可以总结为：统一性、多样性、对称性、层次性、功能性、阵营风格各异。当然缺点也存在：大多数飞船缺乏涂装，内部器件和外部装甲的比例不协调，而且外部装甲的装饰太过复杂，导致整体看起来过于零碎没有统一感。大多数飞船色彩搭配并不鲜艳（虽然在鲜艳和真实感之间取得平衡时很困难的事），但有少数飞船结合优秀的曲面设计和对称性设计，虽然不鲜艳但是给人以强烈的美感。</p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/45f6a4319921dbfa4e24a680da4bd785.png" srcset="/img/loading.gif" class=""><h3 id="其他设计飞船拆解：案例与优劣分析"><a href="#其他设计飞船拆解：案例与优劣分析" class="headerlink" title="其他设计飞船拆解：案例与优劣分析"></a>其他设计飞船拆解：案例与优劣分析</h3><p><strong>一种相对小巧的飞船</strong></p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/5507559d4c9368d20e2751def388db6d.png" srcset="/img/loading.gif" class=""><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/cc2b75a5c6cba835fe489d3fa0ff4838.png" srcset="/img/loading.gif" class=""><p>优势：P2的颜色设计非常值得借鉴，灯光将机体的<strong>边缘</strong>映照出相同的颜色，白色作为<strong>连通颜色</strong>连接不同的区域，让足足5种颜色和谐地融汇在一起。P1和P2装甲的非发光部分做了做旧处理，增加了阴影，整体摆脱了平面化。</p><p>劣势：虽然有阴影，但是整体的光源并不清晰，也可能是平面光，让飞船的立体感不强烈。同时缺少作为复杂性点缀的内部器件，导致颜色的整体对比度也不强烈，缺少现实感。</p><p><strong>使用偏置光源的立体式飞船</strong></p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/664050ac456f11d91ec7984f15295521.png" srcset="/img/loading.gif" class=""><p>评价：这个飞船使用的是偏置光源，同时注意飞船的结构是三维立体式结构，这种结构的劣势在于：它<strong>过于写实</strong>，从而与低像素的画风形成不统一。3维飞船的直接映射需要强烈的立体支撑感，包括高清晰度、光源的正确照射，甚至要求必须在三维背景下完成，而这种设定对一个2D游戏是不可接受的。另外，因为3维飞船的真实性，许多2D用到的技巧都不可行，比如在飞船周围增加武器零件以丰富颜色对比度，这使得飞船的观感更差。</p><p><strong>配色出彩的一组飞船</strong></p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/3eb22e6231fbd04cd1e92be577aca4d4.png" srcset="/img/loading.gif" class=""><p>评价：这组飞船的最大特点就是配色非常舒服，每个飞船大致有3种主要颜色：一种主颜色和两种辅助色，主颜色又包含偏暗的阴影颜色。辅助色用于驾驶舱、灯光等点缀。</p><p><strong>造型和涂装都富有特色的飞船</strong></p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/1c8b396ab142f8ffae13f9053b1fd71f.png" srcset="/img/loading.gif" class=""><p>评价：这个飞船的造型很好看，整体呈现一个三角形，明显的轴对称结构，中间紧实两侧舒展，越靠近中间处颜色越浅，两侧占面积比较大的区域用深灰色，这样让整个飞机中心突出。同时在深灰色区域也都加上装甲设计，略微摆脱廉价感。但不足的是，没有强烈的阴影对照，整体的立体感欠缺很多。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>人权的边界线——底层人民的经济困境与生育权利</title>
    <link href="/2020/07/24/%E4%BA%BA%E6%9D%83%E7%9A%84%E8%BE%B9%E7%95%8C%E7%BA%BF%E2%80%94%E2%80%94%E5%BA%95%E5%B1%82%E4%BA%BA%E6%B0%91%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%9B%B0%E5%A2%83%E4%B8%8E%E7%94%9F%E8%82%B2%E6%9D%83%E5%88%A9/"/>
    <url>/2020/07/24/%E4%BA%BA%E6%9D%83%E7%9A%84%E8%BE%B9%E7%95%8C%E7%BA%BF%E2%80%94%E2%80%94%E5%BA%95%E5%B1%82%E4%BA%BA%E6%B0%91%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%9B%B0%E5%A2%83%E4%B8%8E%E7%94%9F%E8%82%B2%E6%9D%83%E5%88%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="人权的边界线——底层人民的经济困境与生育权利"><a href="#人权的边界线——底层人民的经济困境与生育权利" class="headerlink" title="人权的边界线——底层人民的经济困境与生育权利"></a>人权的边界线——底层人民的经济困境与生育权利</h1><blockquote><p>2020年5月29日广西河池，都安县保安乡上镇村弄邓，一对90后夫妻目前生育有9个孩子，分别有3个女儿6个儿子，最大的孩子12岁在读4年级，还有1个再有3个月也会降生。男子平时外出在工地打工赚钱养家，家里种有玉米自己吃。男子表示有在家产子的经历，都是老妈在帮忙。这对夫妻对未来充满希望，表示会慢慢打工为所有的孩子赚足学费。</p></blockquote><p>将每个家庭的财产与生育率作一幅图，生育率的图像呈现哑铃形：最低处是中产家庭，两边是富裕家庭和底层家庭。富裕家庭为了确保自己的产业有继承者，往往会生育不只一个孩子；底层人民则是在买“生产力”，一般来说，一个男孩成年后打工或者务农，总能挣到超过他抚养费用的生活费，加上政府给的低保费用，一户贫穷人家由此重获新生，如果中了“生育彩票”，培养出有正经工作的孩子，那么这户人家就很大可能在接下来的几十年内摆脱贫困，所有兄弟姐妹都可以过上好日子。</p><p>但我看到这个理论的时候，总是对其有很深的抵触，思考许久，我的疑惑是：人的权利，到底是谁在维护谁的权利？</p><hr><p><strong>消灭苦难有两种方式，要么改善现状，要么消灭幸福</strong></p><p>人们总是认为贫穷是单纯的，就像是缺水、缺粮一样，忍忍就过去了。但贫穷有着独特的吸引力：它将开阔的变成狭隘的、将公平变成嫉妒、将善良变成丑恶。就像是千千万万贪欲“幸福”的困苦家庭一样，这户人家选择在贫困中创造一个又一个生命。忍受着常年的物质匮乏，接受远远落后于他们求知欲的教育，长大则背负十一份责任，曾经的兄弟姐妹都化作工厂里大汗淋漓时承受的压力，如此一日又一日，一年又一年，年老力衰时回到那个抚育自己的村落，又有了数倍于自己一辈的孩子们，十人养一人，百人养十人，这一循环不会轻易打破，因为每个人都心知肚明：如果不再让新的生命献祭给“贫穷”，那么他们自身就会被献祭——无劳动能力者没有活下去的权利。</p><p>在大一返乡时，我在动荡的火车厢里翻阅着何夕的《大饥之年》，“大饥之年，人易子而食。”那天的夜里没有星星，空气中混合着人们的谈论声，这几百上千人融洽地待在狭小的车厢中，一定程度上缓解了我的恐惧感。当时我应该想到，几百公里之外的广西，那是另一种的易子而食，人出生即被预支出劳动力，永远看不到理想，永远看不到自由，我们为何不将其视为家畜呢？当然，他们是幸福的，因为在满是苦难的土壤里根本不存在幸福的种子，活在相对性里的人们，将隆起的高山看作地之柱，将奔流而下的瀑布视为天之泉。</p><p>存在者才有权利，存在者构建的法律，保障的是存在者的权利。时间是它们忠实的卫士，试图违背人类本性的反叛者都在短短百年内被不留痕迹地抹去。在过去几千年的历史中，人类的一部分当然也尝试过改写这一法律，但最后，往往只有存在者的法律获得了最多的拥护，婴儿出生后即受法律保护，因为任何谋杀的手段都让现存于世的人们感到自身的存在受到威胁。未存在于世的“人”会如何感想呢？谁也不管这个。但奇怪的是，我竟然认为人在诞生之前就是被保护的，就像是对废纸篓怜悯每一丝纤维一样无意义。</p><hr><p><strong>相对性与生存策略</strong></p><p>若是作一个审判者，以绝对自洽的法律判断对错，我找不到这样的标准。我现在如此怜悯贫困中的孩子，也有千百年后生活在物质无限充足的社会中，那些怜悯着我的人类。我的生活是如我认为的那般幸福，还是说我也同那些孩子一样，只在苦难中存在？道德与正义建立在相对性之上，人们如同一个个观察者，在不同的时间、不同的地位上去看待一件事，谁是“真理”呢？历史已经写下了答案，真理并不存在于世界上，有的只是无穷无尽的斗争与反斗争，支配与反支配。</p><p>人是有会创造文化认同的社会性动物，它们是图腾。如果将人类看作一个整体，它的进化无疑是令人惊叹的：人类在无数的个体竞争中进行自我迭代，又在多变的历史环境下不断异化。贫穷的人不再遵循自然法则，他们的法则是金钱的法则、法律的法则。活在资本主义“世界”的人们开始了自己的异化：泯灭自由意志、吃苦耐劳、容易满足、永远乐观。基因里强大的适应能力给了人类无穷无尽的生存动力，他们从泥土里挖掘草根，在时间域里开拓近似无穷尽的生产力工具——他们自己是工具，工具也是自己。局外人用自己的图腾去衡量异教徒，注定是毫无意义的。</p><p>正如尼采所说：上帝已死。</p><p>不到二十年时间，我也不例外地找到了自己的生存方式。可我不能再论证人类超越动物性的“道德”与“正义”了，唯物者的视角被笼上一层阴影，当然，总有毫无阴霾的唯物者们信仰这一图腾。过去的时间里我为了是否接受人性的异化而犹豫着，最终选择了规则，但也留存一些大义的理想，其实是欲望的延伸，来自于幼小时记忆中不知名的角落。当然了，理想是相对的，手段是唯一的。理性视角下的我无须为自己的规则与外界格格不入而懊恼，但依然需要进行庞大的知识整理使得理论自洽。想想生活在相对论宇宙中的人类吧，地球以每秒29.8千米的速度绕太阳公转，太阳也以一个速度绕银河系公转，银河系与仙女系在几亿年后交融在一起……但博尔特的短跑记录是百米9秒58。相对性下的人类世界依然是可以被构建的。</p><p>自由意志，那是更深层的本源，人顺应异化本能地活着，与在自由意志的控制下活着，究竟是否为同一个事物呢？让我发笑的是，我的理想是试图用前者的方法构建后者的世界。这大概是互相矛盾的吧，但如果两者能统一的话，就没有任何问题了。</p><hr><p><strong>后记</strong></p><p>这篇文章写在假期的深夜，尽管已经过了凌晨一点，但我还是毫无睡意，有时候也为了自身的存在迷茫过，在思考很久以后，得到了这篇答案。无意义吗？意义是不存在的，每个人创建自己的图腾，然后按照规则行事。</p>]]></content>
    
    
    <categories>
      
      <category>经济</category>
      
    </categories>
    
    
    <tags>
      
      <tag>时政分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
