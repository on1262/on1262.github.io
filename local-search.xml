<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【读书笔记】精通Cocos2d-x游戏开发(基础卷)：程序设计思想札记</title>
    <link href="/2020/07/24/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E7%B2%BE%E9%80%9ACocos2d-x%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91(%E5%9F%BA%E7%A1%80%E5%8D%B7)%EF%BC%9A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E6%9C%AD%E8%AE%B0/"/>
    <url>/2020/07/24/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E7%B2%BE%E9%80%9ACocos2d-x%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91(%E5%9F%BA%E7%A1%80%E5%8D%B7)%EF%BC%9A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E6%9C%AD%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="【读书笔记】精通Cocos2d-x游戏开发-基础卷-：程序设计思想札记"><a href="#【读书笔记】精通Cocos2d-x游戏开发-基础卷-：程序设计思想札记" class="headerlink" title="【读书笔记】精通Cocos2d-x游戏开发(基础卷)：程序设计思想札记"></a>【读书笔记】精通Cocos2d-x游戏开发(基础卷)：程序设计思想札记</h1><h1 id="程序设计思想札记"><a href="#程序设计思想札记" class="headerlink" title="程序设计思想札记"></a>程序设计思想札记</h1><p>这本书是我从2020-6-16开始学习的，目的大概是为了完成小学期的作业吧，书中有一句话启发了我，大概意思是“编程学习的是思想，而不是记忆代码。”我觉得很有道理，于是打算用这篇札记记录自己学到的程序设计<strong>思想</strong>，尽量用脱离具体实现的方式将优劣势讲清楚，便于以后独立设计一个系统时来参考。但一些总结性的东西会具体写出来。</p><p>这篇笔记可以看作读书笔记，也可以看作大作业的心得总结，当然详细的总结会放在技术文档和开发日志里，这里只是写一些闲言碎语吧。</p><hr><h3 id="可读性和可维护性：C-变量命名规则"><a href="#可读性和可维护性：C-变量命名规则" class="headerlink" title="可读性和可维护性：C++变量命名规则"></a>可读性和可维护性：C++变量命名规则</h3><p>变量命名指南：</p><ul><li>不在变量名中写变量类型：减少重复和低效</li><li>减少容易混淆的词：英语中很多词无法从部分推出整体词义，那么应当用构词法描述一个变量</li><li>尽可能具体，方法命名要一目了然</li><li>用稍长的变量名代替简短变量名+单行注释：减少阅读者的记忆负担</li><li>不要用类似val/value/result/temp/count/str这种无意义变量名</li><li>正确使用惯用语：i,j,k,n,e</li><li>生命周期比较短的变量，命名也相对要短：长命名的潜台词是“这是值得注意的变量，需要被记住”</li><li>合理使用一次性变量：并列式长代码需要拆分，嵌套式短代码需要合并<br>驼峰命名法相比于下划线，占地小，紧凑性更好，有些时候区分类和变量时，类用大写驼峰，变量用小写驼峰。但也有自己的缺点，比如HTTP，ID这种缩写词，而且在查找变量的时候必须加上大小写通配。</li></ul><p>还有一些技巧；</p><ul><li>变量、类用名词，方法和函数用动词</li><li>控件命名保留匈牙利命名法，如button-btn, label-lbl等</li><li>对容易用错的变量（比如指针和对象、全局变量），可以保留匈牙利命名法：</li></ul><ol><li>指针加p：避免-&gt;和.用错</li><li>全局变量加g_, 静态变量加s_：这些都是容易出bug的</li><li>成员变量加m_：避免和外部变量重叠<br>总地来说，变量命名需要考虑阅读效率、阅读无歧义、写作效率、写作无歧义、搜索效率、规避潜在风险、规则的简化等，是需要语言学与心理学还有编程经验三者深度融合后才能进行改进的。这次的工程也会采用这些规则来规范编写。</li></ol><h3 id="引擎与顶层逻辑的交互：回调、封装"><a href="#引擎与顶层逻辑的交互：回调、封装" class="headerlink" title="引擎与顶层逻辑的交互：回调、封装"></a>引擎与顶层逻辑的交互：回调、封装</h3><p>对于一个节点来说，加入节点树后，引擎会自动在某些时刻调用方法：初始化，添加进场景时，删除时。对于一些节点，需要每帧进行检测，那么就需要自定义回调函数，并且向引擎“注册”。有时引擎接受到外部输入时，需要将其反馈给节点，那么节点需要事先指定一个回调函数用于接收。</p><p>将外部输入和渲染看作一极，顶层逻辑看作另一极，那么游戏引擎就是连接两极的纽带，为了进行有效的沟通，诞生了消息传递和update等机制。</p><h3 id="内存泄漏与日志统计"><a href="#内存泄漏与日志统计" class="headerlink" title="内存泄漏与日志统计"></a>内存泄漏与日志统计</h3><p>内存泄漏指的是：在堆中创建对象后，没有在结束前进行回收。这个问题非常隐蔽：</p><blockquote><p>…他在维护这份代码的过程中，向其中添加了一些错误判断，如果发生错误，返回什么…但他在添加代码时，所有的返回语句都忘记把这块内存删掉了</p><p>任何一个系统的维护都是长效性的，内存泄漏也是。一种解决方法就是，将构造函数与析构函数的执行次数输出到日志中，这样程序结束后统计日志，就可以发现潜在问题了。</p></blockquote><h3 id="C-11的lambda表达式"><a href="#C-11的lambda表达式" class="headerlink" title="C++11的lambda表达式"></a>C++11的lambda表达式</h3><p>当我们需要在函数内部临时建立一个函数处理一些灵活的工作时，可以构建一个lambda函数：</p><blockquote><p>std::function&lt;return type()&gt; func1 = [capture list] (params list) mutable exception-&gt; return type { function body }</p></blockquote><p>lambda函数func1像变量一样被创建出来，被储存为std::function类型。capture list规定了func1能够利用的外部变量（范围是func1被创建时所能操作的变量），然后params list规定了调用func1时额外传入的参数，mutable修饰符表示函数可以改变捕获的变量（临时改变供自己使用？），exception抛出异常（允许函数体内部用throw()抛出异常）</p><p>但是需要注意，lambda的capture list中的变量是在<strong>创建时就定下来的</strong>，如果是引用捕获&amp;，捕获的是一个引用，func1创建后的修改会有影响，而如果是值捕获=，就只有当时的值，此时对捕获变量的修改都是没有意义的。</p><h3 id="template与可变参数模版"><a href="#template与可变参数模版" class="headerlink" title="template与可变参数模版"></a>template与可变参数模版</h3><p>这篇文章介绍了模版的应用：<a href="https://blog.csdn.net/lianhunqianr1/article/details/79966911" target="_blank" rel="noopener">https://blog.csdn.net/lianhunqianr1/article/details/79966911</a></p><blockquote><p>C++标准委员会采用一套类似函数式语言的语法来设计C++模板，而且设计成图灵完备 (Turing-complete)（详见参考），我们可以把C++模板看成是一种新的语言，而且可以看成是函数式编程语言，只是设计依附在(借助于）C++其他基础语法上（类和函数）。</p></blockquote><p>模版有其复杂的使用方法，但是这里只记录它的思想。首先是“简化”思想，运用模版编程后，不需要对每个类型单独设计一套规则，这就将相似的东西合并起来，大大简化了代码量。第二点是“灵活”，有时候程序员不知道也不需要知道一个类的确切形象，只要知道可供操作的一部分就行了，这时候只有用模版才能开发出具有普适功能的算法和容器。第三点是“动态生成代码”，模版的工作是在编译期和运行期进行的，一些典型场景中（比如用if进行类型判断），一部分花销可以从运行期迁移到编译期，这样就减小了运行开销。</p><p>模版是泛型的基础，泛型中一个思想就是<strong>“Substitution failure is not an error”</strong>，意思是对类型的适配有多次尝试，编译器会自动推导可行的方案（比如对不同参数的函数调用，自行适配合适的参数），然而一次尝试的失败并不是程序错误，只有所有尝试失败才是错误。也就是说，编写者需要设计出任何情况下至少有一种方案能够被执行的代码。自然，智能化的代码需要更加更加智能化的编写者。</p><p>可变参数模版的关键在于参数调用，这里的思想是<strong>匹配调用</strong>或者<strong>递归调用</strong>，后者是前者的延伸。匹配调用也就是：既然不知道参数长度，那么就准备多个函数，逐一匹配合适的函数即可。而递归调用将承接可变长参数的函数func1与解析的函数func2合二为一，将参数列表设为前n个固定参数与最后的可变参数，然后递归调用自身，这样就逐一解出所有参数，但是注意取值为n时，需要准备n-1个函数用来处理递归最后的“余数”，这一点是模版元编程需要考虑“全体情况”的表现。</p><h3 id="变量的四个属性：数值、类型、const、右值（C-11）"><a href="#变量的四个属性：数值、类型、const、右值（C-11）" class="headerlink" title="变量的四个属性：数值、类型、const、右值（C++11）"></a>变量的四个属性：数值、类型、const、右值（C++11）</h3><blockquote><p>通过是否可取地址操作符，以及是否有名字，可以判断是否为右值。右值是指表达式结束后就不存在的临时对象。</p></blockquote><p>在模版变成时，当然需要处理右值的函数，然而在模版的嵌套、转发中，右值可能变成左值（也就是本来赋值完就销毁的变量却拥有了自己的地址和名字）。这时用C++11提供的引用<code>T&amp;&amp;</code>就可以同时保留变量的四个属性，做到“完美转发”</p><h3 id="虚函数与多态特性"><a href="#虚函数与多态特性" class="headerlink" title="虚函数与多态特性"></a>虚函数与多态特性</h3><p>这里参考这篇文章：<a href="https://blog.csdn.net/hackbuteer1/article/details/7558868" target="_blank" rel="noopener">虚函数与纯虚函数的区别</a></p><p>虚函数蕴含的思想是<strong>多态</strong>，整个代码的执行情况对于编译器来说并不是单一的（虽然从结果上，它只能是唯一的，但编译器不需要知道整个情况）。因此，虚函数调用不取决于类型，而取决于实际初始化的类型，就如下面的代码：</p><pre><code class="hljs plain">int main(void)&#123;    A *a &#x3D; new B();    a-&gt;foo();   &#x2F;&#x2F; 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!    return 0;&#125;</code></pre><p>但是，基类定义了虚函数，子类才能继承并重载，这时候我们依然可以用基类生成一个对象，而这样的对象是不合理的：基类本该是抽象的东西，却可以被实例化。因此，纯虚函数<code>virtual void funtion1()=0</code>，规定了其必须被重写，而且这样的基类不可以被继承。</p><p>可以看出，虚函数和纯虚函数的引入是将现实中的抽象和具象关系体现在代码上，让代码更加安全，同时把“抽象”作为内嵌在语言的特性推广为所有开发者的共识，降低代码理解难度。</p><h3 id="节点继承与回调方法：Cocos2dx引擎与顶层的交互接口"><a href="#节点继承与回调方法：Cocos2dx引擎与顶层的交互接口" class="headerlink" title="节点继承与回调方法：Cocos2dx引擎与顶层的交互接口"></a>节点继承与回调方法：Cocos2dx引擎与顶层的交互接口</h3><p>在处理游戏内容的可拓展性上，cocos2d采用的思想是<strong>继承和回调</strong>，通过对节点类Node的继承，实现游戏内容的多样性和统一性。而事先规定好特定的回调函数，在约定的时刻由引擎调用，就实现了游戏逻辑的可拓展性。</p><p>回调函数：</p><ul><li>init初始化节点时调用</li><li>onEnter被添加进场景中调用（这里是二次初始化）</li><li>onExit节点从场景删除</li><li>update与时间相关，比如每一帧的逻辑、定时逻辑<br>可以认为继承是引擎为内容维度提供的接口，回调是引擎为逻辑维度提供的接口，游戏顶层设计在这两个维度上与引擎进行交互。</li></ul><h3 id="内存池设计"><a href="#内存池设计" class="headerlink" title="内存池设计"></a>内存池设计</h3><p>内存池的思想是将大大小小的内存申请需求统一，以此来<strong>用额外的内存空间为代价换取低频的内存扩展请求</strong>。这是由于技术的发展，使得内存不再需要节约使用，而更需要低频使用。</p><p>内存池的基本功能：</p><ul><li>接管原本代码中的new和delete/free功能，先申请一大块内存空间，再自行决定分配。同时释放的时候也可以暂时不delete，减少频率</li><li>内存池本身申请内存时，做到连续，低频，且尽量占用少（这三者其实是互相矛盾的）</li><li>内存空闲太多时，需要释放一部分内存。<br>PS：这一部分就实现了自主选题中的内存管理需求</li></ul><h3 id="cocos2d-x运行机制解释"><a href="#cocos2d-x运行机制解释" class="headerlink" title="cocos2d-x运行机制解释"></a>cocos2d-x运行机制解释</h3><p><strong>与windows系统关联的启动机制</strong></p><ol><li><code>_tWinMain</code> 作为入口，初始化实例AppDelegate</li><li>调用Application::getInstance()-&gt;run(); 回调applicationDidFinishLaunching，完成制作者自定的初始化</li><li>windows下的OpenGL进行底层交互处理（键盘，窗口最小化等），GLFW直接与Director等进行信息传递</li></ol><p><strong>引擎内部的运行机制</strong></p><ol><li><p>全局初始化：AppDelegate中的applicationDidFinishLaunching，可添加开发者自己的初始化代码</p></li><li><p>进入DisplayLinkDirector的mainloop（），其中的drawScene()对每一帧进行场景渲染和逻辑执行：</p></li><li><p>执行schedule的update进行逻辑更新：schedule作为调度器驱动action更新，并且执行每一帧的游戏逻辑和关于时间的逻辑</p></li><li><p>Director直接控制游戏的暂停、恢复、结束、场景切换（但判断逻辑并不在这里）</p></li><li><p>场景渲染</p><h3 id="消息、逻辑、调度交互"><a href="#消息、逻辑、调度交互" class="headerlink" title="消息、逻辑、调度交互"></a>消息、逻辑、调度交互</h3></li></ol><p><strong>消息的观察者模式：包括注册、触发、处理、注销四个步骤</strong></p><hr><p>这里首先介绍一些C++11的bind机制：</p><pre><code class="hljs plain">void TestFunc(int a, char c, float f);auto bindFunc1 &#x3D; bind(TestFunc, std::placeholders::_1, &#39;A&#39;, 100.1);bindFunc1(10);</code></pre><p>bindFunc1将一个3个参数的函数变成1个参数，2个“定量”的函数，bind第一个参数对应目标函数，后面的placeholder就对应使用时需要传入的东西。需要注意的是，预先设定的参数都是按值传递的。</p><hr><p>这里来总结观察者模式：</p><p><code>auto listener = EventListenerKeyboard::create();</code>：创建监听器，申请得到一个实例</p><p><code>listener-&gt;onKeyPressed = CC_CALLBACK_2(HelloWorld::fighterMoveCallback, this);</code>：指定监听器的哪个事件会触发哪个实例的哪个成员函数，本质上是对listener的成员指针指定要一个bind()，这里的this指当前场景的实例</p><p><code>_eventDispatcher-&gt;addEventListenerWithSceneGraphPriority(listener, this);</code>：向Director注册（_eventDispatcher其实是封装了向Director相关函数），监听器本身是绑定在节点（这里是Scene）上的，而监听器本身也拥有一个指向回调函数的指针。</p><p>触发由引擎和底层负责，这里只需要实现HelloWorld::fighterMoveCallback方法即可。</p><p><strong>调度器：Schedule</strong></p><p>Scheduler是一个全局调度器，可以从Director中获取指向它的指针，调度的本质就是<strong>在规定的时间由引擎调用某个实例的成员函数</strong>，所以需要3个元素：指向调度器的指针，指向实例的指针，实例的成员函数。</p><p>一般来说，调度器的指针是很容易获得的，实例的指针用this即可实现，所以调度一般定义在该实例对应的类中。</p><p>回调按类型分为update回调（每一帧执行的回调），对象回调和函数回调，脚本回调，执行回调。对象回调其实也是调用函数，只不过这个函数是事先约定的形式：</p><p><code>typedef void (CCObject::*SEL_SCHEDULE)(float)</code>：这里规定了一种类型叫SEL_SCHEDULE，它被定义成一个指针，指向一个CCObject类或派生类的成员函数，而这个成员函数的参数必须是float，返回类型必须是void。</p><p>调度器注册时机：</p><ul><li>Node回调函数中，如onEnter或onExit，会在下一帧开始计时</li><li>单击回调，会在当前帧立刻计时</li><li>计时回调内嵌套回调：难以控制时间<h3 id="cocos2d-x顶层逻辑设计"><a href="#cocos2d-x顶层逻辑设计" class="headerlink" title="cocos2d-x顶层逻辑设计"></a>cocos2d-x顶层逻辑设计</h3></li></ul><p>今天终于是把书差不多啃完了……以现在的预期来看，UI界面只能靠手画，同时分辨率固定，这些暂时没法解决。其他的主要在顶层规划，这也是相当考验能力的环节。</p><p>从内容上来看的话，我将游戏设计拆分成以scene为主的“内容切片”</p><ul><li>scene内加载要考虑耦合度，可能会复用的加载模式不可以在单个scene做</li><li>游戏UI独立于画面，设置继承Node的UINode，游戏UI不写在场景加载里，以便重复调用</li><li>各scene间进行解耦，每个继承的scene间的数据传输用约定的方法进行通信，尽量将数据传输大的scene进行整合</li><li>游戏逻辑去中心化，但是约定用tag进行全局的自由通信，游戏与固定的非组件部分存储指针通信</li><li>对于动态产生的节点，不存储指针，每次访问时调用方法获取实时数据。</li><li>对于复杂的逻辑控制，抽象出一个逻辑节点来做。<h3 id="debug-类之间的互相包含"><a href="#debug-类之间的互相包含" class="headerlink" title="debug:类之间的互相包含"></a>debug:类之间的互相包含</h3></li></ul><p>今天debug的时候遇到了这个问题，两个类的定义互相包含，这时候要用前置申明，而且不能写继承关系。</p><h3 id="关卡设计中的序列模式与难度设置"><a href="#关卡设计中的序列模式与难度设置" class="headerlink" title="关卡设计中的序列模式与难度设置"></a>关卡设计中的序列模式与难度设置</h3><p>首先要解决两个问题：在阶段BOSS和最终BOSS被击落前不能开启下一个阶段；每个阶段是一条时间轴，这里我想设计成既可以从外部读取又可以自动生成的机制。</p><p>一般来说玩游戏是为了有爽快感，随着玩家自身操作水平和装备的提升，固定的游戏难度难以让玩家得到充分的满足。因此，游戏难度应该参考玩家飞机的DPS（这决定了是否能理论上通关）、玩家历史战绩（这体现了玩家的水平）、时间难度（这让游戏更加丰富，也带有一些随机性）、关卡难度系数（让游戏从前到后难度有变化）。</p><h3 id="碰撞判定机制的设计"><a href="#碰撞判定机制的设计" class="headerlink" title="碰撞判定机制的设计"></a>碰撞判定机制的设计</h3><p>碰撞判定也是这个游戏的一大难点：全像素化碰撞太耗性能，直接用boundingBox碰撞又不能避免透明像素的干扰。那么在解决碰撞问题时，我的方案是用一个根据booundingbox自动伸缩的“细长”区域判定。</p><p>2D游戏有设计的优势：绝大多数情况子弹都要穿过敌机的横截面，而穿过纵截面的情况极少发生，这是因为敌机的速度一般都垂直于横截面方向。所以这样就极大方便了碰撞判定。同时对于不同类型的问题，我搭建了scene到各元素的双向通信机制，理论上这个机制可以用动态类型转换+Node-&gt;name进行区分，但这种操作有运行风险不说，性能消耗也比较大。我采用的方式是scene持有多个vector，各节点在加载时分别向scene注册自身的指针到指定vector中，各节点退出时也向scene注册销毁自身的指针，然后每一帧调用scene的碰撞判定，分组进行判定，减小内存消耗。</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏开发</tag>
      
      <tag>读书笔记</tag>
      
      <tag>cocos2d</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【读书笔记】Pragmatic_Programmer_札记</title>
    <link href="/2020/07/24/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Pragmatic_Programmer_%E6%9C%AD%E8%AE%B0/"/>
    <url>/2020/07/24/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Pragmatic_Programmer_%E6%9C%AD%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="【读书笔记】Pragmatic-Programmer-札记"><a href="#【读书笔记】Pragmatic-Programmer-札记" class="headerlink" title="【读书笔记】Pragmatic Programmer 札记"></a>【读书笔记】Pragmatic Programmer 札记</h1><h3 id="前言和概要"><a href="#前言和概要" class="headerlink" title="前言和概要"></a>前言和概要</h3><p>这本书是在七月份读的, 有差不多300页, 考虑到英文书算是比较容易理解, 应该一两周能读完.(PS: 实际从10号读到16号)</p><p>重点处会用黑体标注. 主要还是根据书中一些精华的句子写感想.</p><blockquote><p>Your background stems from an understanding of the basic principles of computer science, and your experience comes from a wide range of practical projects.</p></blockquote><p>这是一个关于学习编程知识的建议, 有最基础的计算机知识, 然后在不同领域积累许多经验. 所以语言没什么限制, 思想才是有价值的东西.</p><blockquote><p>There are other factors that can contribute to software rot, and we’ll touch on some of them elsewhere, but neglect accelerates the rot faster than any other factor.</p></blockquote><p>软件工程中的”熵增理论”或”破窗理论”, 书中建议将<strong>及时重构, 修复那些不好的设计</strong>放在第一位, 如果实在没有时间, 也要将其标注起来, 构建以一个围栏, 阻止一块不好的代码继续扩散. 这个建议是基于软件开发中的混乱度提出的, 软件在开发过程中, 总是不可避免地走向混乱, <strong>软件开发的过程也就是与混乱抗争的过程</strong>, 那么尽量保护自己的代码, 让它们简洁高效, 是延续抗争意志的很好的手段.</p><blockquote><p>If you find yourself working on a project with quite a few broken windows, it’s all too easy to slip into the mindset of “All the rest of this code is crap, I’ll just follow suit.”</p></blockquote><p>这个是破窗理论的延伸, <strong>一块不好的代码不仅会让开发者更易于添加糟糕的代码, 还会让开发者认为其他代码也是不好的.</strong>, 我注意到的是这种情形<strong>不仅适用于代码, 还适用于开发计划/开发文档等</strong>, 第一天进行开发的时候应当设计一个简洁的框架, 然后每隔一段时间适量地作出计划, 保证整体的准确性和指导功能. 计划不能太过详细, 不然后续修改需求时就会被看作一块”破窗”, 计划也不能太抽象或者没有, 不然过几天去看当时写的代码的时候就会觉得是写出来的东西难以阅读, 也找不到定位. 总之好的设计一定是精简又可扩展的, 使得每一天都能及时踏在开发的进度上, 而不至于迷失方向或疲于修改计划.</p><blockquote><p>Once you’ve got it, show people, and let them marvel. Then say “of course, it would be better if we added….”</p><p>People find it easier to join an ongoing success.</p></blockquote><p>不仅是对团队而言, 对独立开发者也是这样. <strong>让一个项目时时刻刻处于即将成功的状态, 会让它更加有吸引力</strong>, 最初的开发要做的是写出一个最精简的可行的框架, 给人眼前一亮的感觉, 然后依照这个最初的创意不断的添加功能. 对独立开发者来说, 也就是时时刻刻让项目富有吸引力, 从而让自己能坚持开发下去.</p><blockquote><p>If you give your users something to play with early, their feedback will often lead you to a better eventual solution</p></blockquote><p>这也是迭代开发的好处, 能够迅速地将开发工作转换成可见的成果</p><h3 id="Duplication-重复"><a href="#Duplication-重复" class="headerlink" title="Duplication 重复"></a>Duplication 重复</h3><blockquote><p>The alternative is to have the same thing expressed in two or more places. If you change one, you have to remember to change the others, or, like the alien computers, your program will be brought to its knees by a contradiction. It isn’t a question of whether you’ll remember:<strong>it’s a question of when you’ll forget</strong>.</p><p>The DRY principle tells us to keep the <strong>low-level</strong> knowledge in the code, where it belongs, and reserve the comments for other, <strong>high-level</strong> explanations. Otherwise, we’re duplicating knowledge, and every change means changing both the code and the comments.</p></blockquote><p>这是第一个重要的概念: <strong>在任何地方都尽量不要出现重复的知识</strong></p><p>我在过去的经验里也有这种现象: 在许多地方写上一些相似的代码, 但是修改的时候又忘记修改其他地方的东西, 或者修改了代码却没有修改注释. 现在来看看文章中给的解决方法:</p><ol><li><p>用code generator在每一次更改的时候同步代码. 这也可以使用于代码和文档之间(doxygen), 其核心理念就是<strong>在更改时同步</strong>. 用到的技术有metadata/preprocessor等</p><blockquote><p>To ensure that the tests accurately reflected the specification, the team generated them programmatically from the document itself.</p></blockquote></li><li><p>在注释中用<strong>更高级的逻辑概括代码的内容</strong>, 通常是代码的目的或作用, 这样在更改代码的时候也就不会需要同时修改注释了</p></li><li><p>为了避免头文件和实现中的注释重复, 在头文件中存放<strong>与接口相关的信息</strong>, 而在实现中写一些<strong>被封装起来的但是很重要的细节</strong></p><blockquote><p>Use the header files to document interface issues, and the implementation files to document the nitty-gritty details that users of your code don’t need to know.</p></blockquote></li><li><p>避免违背事实的抽象关系和重复的抽象关系.</p></li></ol><p>这一点书中给了一个实例: 一个运送路线包含卡车, 司机, 和路线, 而卡车中又包含号码牌, 司机和卡车类型. 而当司机生病需要替换时, 问题就来了: 有两个重复的司机. 另外, 卡车其实并不包含司机, 如果一定要包含的话, 那么这个卡车是正在运送货物的卡车. 而不是普通意义的卡车. <strong>在设计抽象的时候时常会出现重复或是违背事实的抽象关系, 从而让实际设计的类不是我们想要的类</strong>, 解决这个问题, 当然是尽量避免重复, 我想到的, 在设计时应该这样询问自己:</p><ul><li>我是否能从这个类中的某几个类成员直接得到另一个类成员? (避免相互包含的重复)</li><li>在这个类需要应用的情况中, 这个类是否都包含它的成员属性?是否有没考虑到的成员属性? (避免违反事实的包含关系)</li><li>在这个类需要应用的情况中, 类成员的是否满足所需的性质? 如可修改性, 唯一性, 可比较性(浮点数带来的精度问题), )可独立存在性(指针指向的独立内存空间)</li><li>在这个类需要应用的情况中, 类成员是否具有不能具备的性质? 如可访问性(public的滥用), 可修改性(const), 过大的取值范围(约束限制)等</li></ul><ol><li>尽量用访问函数获取类的属性<blockquote><p>Where possible, always use accessor functions to read and write the attributes of objects</p><p>有两个例子, 一个是文中给的: 一个line类有两个成员start和end, 当需要获取长度时, 为了不违背重复性的规则, 要用两个点计算这一长度, 但是这一计算通常是昂贵的, 于是设置一个distance, 在获取长度时, 先看起点和终点是否修改过了, 如果修改了就更新distance, 再传出.</p></blockquote></li></ol><p>另一个例子是getInstance()的作用, 用来得到静态指针指向的实例, 也是唯一的实例. 这两个例子都说明<strong>用访问函数存取属性可以做更多逻辑上的封装, 让类的设计更加合理</strong></p><ol><li>设计良好的可重复利用的生态环境<blockquote><p>What you’re trying to do is foster an environment where it’s easier to find and reuse existing stuff than to write it yourself.</p></blockquote></li></ol><p>这其实有分成两点: 对个人而言和对软件/语言生态而言.</p><p><strong>对个人而言, 尽量提高代码的可重复利用性</strong>, 这不仅是提高效率, 也是集中修改. 例如用一个utils类统一管理各种需要用到的静态方法, 或者用宏定义将多个数值定义统一.</p><p><strong>对生态环境而言, 简化调包方法, 降低调包风险.</strong></p><p>这是我结合语言更新来思考的, C++的调包并没有像python那么方便, 往往是直接copy别人的代码, 还要手动搜索接口说明. 复杂的复用方法让整个软件生态面临重复性的风险, 这直接带来<strong>性能不确定的第三方库</strong>, 然后导致开发者趋向于自己造轮子, 又带来了<strong>开发的复杂度上升和沟通成本的增加</strong>, 论坛的活跃度降低, 对新手而言也很不友好. 这些都会导致整个语言生态环境的没落.</p><h3 id="Orthogonality-正交性-解耦合"><a href="#Orthogonality-正交性-解耦合" class="headerlink" title="Orthogonality 正交性/解耦合"></a>Orthogonality 正交性/解耦合</h3><blockquote><p>You get two major benefits if you write orthogonal systems: increased productivity and reduced risk.</p></blockquote><p>正交性也就是解耦合, 书中总结了一些好处, 这里列出比较有新意的点:</p><ol><li>将问题局限化: 一个结构出问题以后整个错误只会在这个结构内, 这样就可以减少思考范围, 提高debug速度</li><li>避免对第三方库的依赖: 与第三方库解耦后, 只要接口合适, 可以任意更换成另一个库, 减少依赖性.<blockquote><p>Every change needs a meeting of the entire team, because any one of them might be affected</p></blockquote></li></ol><p>这是一个很有趣的点, <strong>对一个团队的解耦可以减小沟通成本</strong>, 也就是管理的时候, 将整个程序拆解成细分的几个子部件, 然后指名各个小团队制作, 这样确保每个级别只有较少的人参与研发, 沟通也富有效率, 然后部件与部件之间正交化, 一个团队的延误不影响其他团队的工作.</p><p>满足正交性以后, <strong>用模块化和层次化的思想构建一个系统</strong></p><img src="/2020/07/24/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Pragmatic_Programmer_%E6%9C%AD%E8%AE%B0/056f9a574fe47828a21074cf7e239d0d.png" srcset="/img/loading.gif" class=""><p>如图, 交互界面内部是模块化的, 而交互界面和数据库之间是层次化的. 层次化的东西下部只需向上提供接口, 同时模块化的东西, 各模块直接也只需提供接口. 这就保证了整个系统是可靠高效的.</p><blockquote><p><strong>Don’t rely on the properties of things you can’t control.</strong></p></blockquote><p>这一句话的例子是: 不要用电话号码去分辨每一个客户. 同样, 也不能用地区/姓名等区分每一个客户, 虽然在客户数量少的情况下这样做很有效. 但是最本质的是区分<strong>一个抽象的类和从属于类的成员的区别</strong>, 前者的独立性不可由后者的独立性保障, 也比如说, 一个对象的同一性判断不可以用内存中的位置来决定, 这是因为这个位置是对象的一个属性, 虽然这个位置对于一个对象是唯一的, 但很多情况下, 开发者所要的唯一性是脱离于对象生命周期的, 那么在这种时候就应该用别的方法去识别唯一性.</p><blockquote><p>If an object persistence scheme is transparent, then it’s orthogonal. If it requires you to create or access objects in a special way, then it’s not. Keeping such details isolated from your code has the added benefit of making it easier to change vendors in the future.</p></blockquote><p><strong>引入第三方库通常是增强耦合度的</strong>, 例如stl库, 从database到GUI都要调用其中的方法, 那么一旦修改其中的某个定义, 就一定会波及多个层. 在此基础上, 要么对引入的库谨慎判断, 要么自己封装一层接口, 不直接在代码中使用第三方库, 而是集中在接口使用.</p><p>对第三方库的可替代性也有判断标准, 就如这句话所说的, 如果第三方库的使用比较奇特, 那么就尽量不要引入. 最好的第三方库是transparent的</p><blockquote><p>With AOP, you implement logging orthogonally to the things being logged. Using the Java version of AOP, you could write a log message when entering any method of class Fred by coding the aspect:</p></blockquote><p>这下面是一个例子, 意思是说AOP让log不是由每个方法独自发出的, 而是在每个方法被调用时统一发出的, 这就避免了重复调用log, 而且AOP在你编写的时候就自然而然地适用, 不需要去对源代码进行任何改动.</p><p>以后在开发的时候, 可以用一个基类实现这些功能,</p><blockquote><p>In fact, we suggest that every module have its own unit test built into its code, and that these tests be performed automatically as part of the regular build process</p></blockquote><p>这是一个关于<strong>自动化测试</strong>的建议, 也就是每个组件自身有内部的测试, 组件自身包括功能和测试两部分, 一方面可以很方便地进行调用, 另一方面减小耦合度, 节省了编译的时间.</p><blockquote><p>With truly orthogonal documentation, you should be able to change the appearance dramatically without changing the content. Modern word processors provide style sheets and macros that help</p></blockquote><p><strong>文档的解耦</strong>, 也就是自动编写目录, 将格式与内容分离, 以及格式的统一控制等等.</p><h3 id="Reversibility-可逆性"><a href="#Reversibility-可逆性" class="headerlink" title="Reversibility 可逆性"></a>Reversibility 可逆性</h3><blockquote><p>If you keep decisions soft and pliable, it won’t be hard at all. If you have poor encapsulation, high coupling, and hard-coded logic or parameters in the code, it might be impossible.</p></blockquote><p>可逆性指<strong>面对未来需求的不确定性时, 如何编写出易于改动的软件系统</strong>, 书中提到的观点有两个:</p><ol><li>系统上, 为可能的改动预留空间</li><li>利用接口, 将第三方库封装在接口里面<br>注重系统的可逆性当然是有必要的, 可我觉得这里只提了这个趋势但是没有提到如何权衡: 假设第三方库要更换, 那么就要封装一层接口; 假设系统要更换, 就要设计可更改的模式. 可逆性越大的软件也越臃肿, 这样毫无疑问会降低开发效率. 那如何保持简洁又兼顾可逆性? 这里思考的应当不是哪些需求可能会改动, 而是哪些需求不会改动.</li></ol><p><strong>在确定的需求基础上, 编写出最独立,最小化的软件</strong></p><p>所以在刚开始的时候, 应当尽量确定一些不会改变的东西, 比如软件的功能, 软件使用的平台, 是否依赖网络, 软件的最大性能需求等等. 确定以后再思考可能会改动的部分, 比如软件的GUI界面, 软件的额外功能等. 在编写的时候应当尽量不包含会改动的部分, 比如尽量不引入第三方库(除非确定这个库拥有满足需求的性能), 对长期维护的项目, 要考虑第三方库的维护状态. 也要考虑代码的易读性.</p><h3 id="Tracer-Bullets-技术验证与原型构建"><a href="#Tracer-Bullets-技术验证与原型构建" class="headerlink" title="Tracer Bullets: 技术验证与原型构建"></a>Tracer Bullets: 技术验证与原型构建</h3><p>书中的tracer bullets来源于曳光弹的形象比喻, 它是一个用来验证技术是否可行的原型机, 并且这个原型机成为后续大规模开发的骨架, 其他功能陆续被添加到这个原型机上, 逐步改装, 最终完成.</p><p>与tracer bullets对应的conventional alternative是一次性集成, 或者是单向地设计-实现-集成这个模式. 单向化有两个弊端, 第一是<strong>在测试前无法得知技术的有效性, 风险大</strong>, 这也是我之前碰见的一个问题. 我在设计动态星球生成器的时候, 没有考虑到放大后的模糊效果和性能损耗, 最终开发出的东西无法运用在实际场景中. 另外一个弊端是<strong>模块化开发, 一次性集成的方法缺少实时激励, 无论是对开发者还是用户</strong>. 激励在软件开发中很有必要, 越复杂的系统越需要心理上拉出”战线”.</p><blockquote><p>A small body of code has low inertia—it is easy and quick to change.</p></blockquote><p>这是tracer bullets的另一个好处: <strong>技术验证的代码体量小, 易于修改</strong>.</p><blockquote><p>Prototyping generates disposable code. Tracer code is lean but complete, and forms part of the skeleton of the final system.</p></blockquote><p>这里强调了Tracer bullets和prototype的区别, 前者是一个<strong>完整的骨架加上小部分的实现</strong>, 后者是一个不完整的骨架加上完全的实现, tracer bullets是可以保留到最后的, 而且这个骨架就是实际应用的东西, 而不是一个供参考的原型机. 这样能确保tracer bullets工作在实际的情况中, 而且避免了最开始的重构工作.</p><blockquote><p>What sorts of things might you choose to investigate with a prototype? Anything that carries risk. Anything that hasn’t been tried before, or that is absolutely critical to the final system. Anything unproven, experimental, or doubtful. Anything you aren’t comfortable with.</p></blockquote><p>这里需要注意的是<strong>每一次尝试新事物的时候都最好做原型验证</strong>, 这样能有效避免风险. 在开发的时候无论时间是否充裕, 都应该采用最有效的开发方式, 在这种开发中技术失败的风险也会被考虑进去.</p><blockquote><p>It’s easy to become misled by the apparent completeness of a demonstrated prototype, and project sponsors or management may insist on deploying the prototype (or its progeny) if you don’t set the right expectations.</p></blockquote><p>prototype注意的是<strong>验证某个技术是否可行, 只需要一部分代码是正确的</strong>, 而tracer bullets不同, 它需要<strong>写出能完整运行的最小的正确代码, 不需要完整, 但是需要正确和能运行</strong>, 这就导致prototype必然被推翻重来.</p><blockquote><p>By coding at a higher level of abstraction, you are free to concentrate on solving domain problems, and can ignore petty implementation details.</p></blockquote><p>这是说<strong>在最初的时候不要考虑语言的具体细节, 只需要用一种伪代码描述出业务逻辑即可</strong>, 确实在思考问题的时候我默认都会从语言的角度思考可行性, 但是这是不对的, 因为理清业务逻辑不需要理清语言细节, 一个逻辑可以有很多实现, 而我在构建框架的时候并不需要去寻找最合适的实现, 甚至不需要关注是否能实现, 这些东西都是在实现的过程中考虑的.</p><blockquote><p>But with a mini-launguage, you would instead be able to issue an error message using the vocabulary of the domain.</p></blockquote><p>这也是站在业务逻辑思考的好处, 一些错误提示是基于语言或计算机系统本身的, 但这种提示是脱离<strong>业务语言</strong>的, 在业务语言中, 仅有业务本身的选择, 而将所有语法错误和执行错误都重新阐释为业务逻辑的错误.</p><blockquote><p>Given that most applications exceed their expected lifetimes, you’re probably better off biting the bullet and adopting the more complex and readable language up front</p></blockquote><p>软件是无生命的, 但是在使用的时候依然要考虑它的<strong>生命周期</strong>, 我的思考是, 在代码能够被理解的时候, 它是有活力的, 而当没有人能理解一段代码的时候, 代码就失去了活力, 而失去活力的代码会失去其价值.</p><p>开发和管理存在一个平衡: 富有活力的代码通常难以创造, 而管理没有活力的代码也非常困难. 所以这取决于这段代码的生命周期有多长: 生命周期为一天或几天的代码, 不需要开发文档, 只需要内部的注释. 而生命周期为半个月到一个月的代码, 需要开发文档, 但不需要对第三方库的维护. 而生命周期为一年到几年的代码, 则需要编写完善的开发文档, 并且尽量对第三方库封装接口, 从而让第三方库可以根据维护性更换.</p><p>生命周期应该看作代码本身的一个属性.</p><blockquote><p>We find that often the only way to determine the timetable for a project is by gaining experience on that same project.</p></blockquote><p>依据最开始的决定对整个项目的时间作规定是很不可靠的, 预估一个程序的开发时间最好的方法就是直接取开发这个程序. <strong>在开发过程中逐步确定剩余的时间, 并依照这个时间作决策</strong></p><p>也就是说, 整个开发计划是随着开发进程而变化的.</p><h3 id="ToolBox拥有自己的工具箱"><a href="#ToolBox拥有自己的工具箱" class="headerlink" title="ToolBox拥有自己的工具箱"></a>ToolBox拥有自己的工具箱</h3><blockquote><p>Many new programmers make the mistake of adopting a single power tool, such as a particular integrated development environment (IDE), and never leave its cozy interface.</p></blockquote><p><strong>每一种工具都有自身的优缺点, 没有哪个是完美的</strong>, 这也说明开发者应当掌握不同的工具来处理不同的情况, 用自身的经验加上合理调度来达成最优效率.</p><p>当然, 在一个开发进程中使用过多的工具也代表着很难被别人理解.</p><blockquote><p>As Pragmatic Programmers, our base material isn’t wood or iron, it’s knowledge.</p></blockquote><p>这一句话只是单纯看着很有哲学意味…</p><p><strong>Plain text</strong></p><p>可以翻译作”朴素的文本形式”, 书中对平面文本比较推崇, 它的优点是可以被人理解, <strong>对于一些在使用时需要被理解的东西, 通常以文本的形式保存</strong></p><p>但也有缺点, plain text占空间大, 同时在读取和写入的时候比较昂贵. 一些其他的缺点其实并不是plain text的锅, 例如易读性. 二进制的东西读取并不困难, 同时plain text也可以通过加密形式存储.</p><p><strong>Using Unix Tools Under Windows</strong></p><blockquote><p>But if you do all your work using GUIs, you are missing out on the full capabilities of your environment. You won’t be able to automate common tasks, or use the full power of the tools available to you. And you won’t be able to combine your tools to create customized macro tools.</p></blockquote><p>确实GUI在自动化处理上有些问题, 但是我觉得并不需要强行在GUI和命令行之间作划分, 有时候<strong>简单的操作由GUI完成, 自动化的东西交给命令行</strong>, 这样应该能保持效率的最大化?</p><p><strong>Use a single editor well</strong></p><p>最好选择一个编辑器来熟悉, 然后充分利用它的快捷键提高效率.</p><p>好的编辑器有以下特征:</p><ol><li>可配置, 可以自行配置让编辑器符合自己的喜好</li><li>可拓展, 可以添加新的内容</li><li>可编程, 可以自己设计复杂的组合操作</li></ol><p><strong>Always Use Source Code Control</strong></p><blockquote><p>There is a tremendous hidden benefit in having an entire project under the umbrella of a source code control system: you can have product builds that are automatic and repeatable.</p></blockquote><p>书中的观点是: 源代码管理不仅可以适用于代码, 更适用于任何自己编写的东西, 比如脚本, 管理文档等. 这样可以随时退回到之前的操作, 非常方便.</p><p>所以对于任何可以被管理的文件, 尽量把他们应用在源代码管理中</p><h3 id="Debugging-调试"><a href="#Debugging-调试" class="headerlink" title="Debugging 调试"></a>Debugging 调试</h3><p>书中总结了几条调试的规则, 这里简要列出:</p><ol><li>bug复现</li><li>数据可视化</li><li>程序运行追踪</li><li>先假设自己的代码有问题, 再思考第三方代码是否有问题</li><li>不要假设哪些代码是必定正确运行的, 而是去证明它</li><li>在找到代码之后, 反思如何避免它<h3 id="Text-Manipulation-文本操作"><a href="#Text-Manipulation-文本操作" class="headerlink" title="Text Manipulation 文本操作"></a>Text Manipulation 文本操作</h3></li></ol><p>文本操作的一些功能:(以Perl为例)</p><ol><li>建立数据库</li><li>自动方法生成</li><li>测试数据生成</li><li>抽取声明和接口</li><li>生成文档<blockquote><p>Write Code That Writes Code.</p></blockquote></li></ol><p>这句话解释了自动处理的重要性. 建立一个代码生成器是很有必要的, 这里是一些功能:</p><ol><li>创建新的文件, 并应用模版</li><li>执行自动的格式转换操作</li><li>执行预处理操作</li><li>执行给定的同步操作或一致性检查</li><li>手动处理一些源代码中的可变片段(结构体等)<h3 id="Pragmatic-Paranoia-偏执心理"><a href="#Pragmatic-Paranoia-偏执心理" class="headerlink" title="Pragmatic Paranoia 偏执心理"></a>Pragmatic Paranoia 偏执心理</h3></li></ol><blockquote><p>You Can’t Write Perfect Software</p></blockquote><p>这句话也是我感触比较深的, 在写程序的时候当然要追求效率, 但是不要追求完美. 因为完美的程序一般都会花费远远大于预定的时间来开发, 在绝大多数时候我只需要一个简单够用的程序.</p><p><strong>Design by Contract</strong></p><p>这是确保程序在正确性和完美之间的找到平衡的一个方法, 简单来说, 就是在给定条件下, 一个方法能确保结果中的一部分被正确呈现, 而一些模糊的部分会怎么样, 并没有被规定.</p><p>DBC包含三个部分: 调用者必定凑齐的条件, 依照条件返回结果的方法, 和检查条件与结果是否正确的class</p><blockquote><p>Subclasses must be usable through the base class interface without the need for the user to know the difference.</p></blockquote><p>这是继承的一个原则: <strong>继承类必须在调用基类接口的时候表现得和基类一样</strong>, 不然继承的原则就会被破坏, 这里的表现得一样不是指一样的输出, 而是输入范围至少要和基类的范围一样. 也就是说在用户使用继承类的基类接口的时候, 用户可以当做基类来使用而不会产生错误.</p><p>DBC在C++中有预处理器来保证, 如<strong>Nana</strong>, 在JAVA中有<strong>iContrast</strong></p><blockquote><p>With enough components and agents that can negotiate their own contracts among themselves to achieve a goal, we might just solve the software productivity crisis by letting software solve it for us.</p></blockquote><p>有时候面对输入不一样的情况, 并不总是将其当作<strong>错误</strong>, 而对于特殊情况, 依然能返回正确的结果, 那么程序本身在扩展的时候就自动地找出复杂范围的可行方案(例如类型推断)</p><p><strong>crash earlier</strong></p><blockquote><p>when your code discovers that something that was supposed to be impossible just happened, your program is no longer viable.</p></blockquote><p><strong>在程序最开始出错的地方停止</strong>, 一方面是避免后续的报错影响debug思路, 另一方面是避免重要的数据被错误地覆盖.</p><p>另外, 为了尽早检测出错误, 在每一个模块都应当设置<strong>检测运行状态合理性的代码</strong>, 也是为以后的debug留下线索</p><blockquote><p>If It Can’t Happen, Use Assertions to Ensure That It Won’t</p></blockquote><p>很多时候在编程中会默认加上一些条件, 然后根据这些假设编程, 但是<strong>对正确性的检测不能因为主观的假设而偏颇</strong>, 此时使用Assertion来显式表达自己的假设.</p><p>但是要注意, 断言中不能存放任何业务逻辑的代码, 因为断言可能在编译时被关闭.</p><blockquote><p>First, they assume that testing finds all the bugs. Second, the optimists are forgetting that your program runs in a dangerous world.</p></blockquote><p>这是<strong>Assertion不仅用于debug</strong>的原因, 因为断言针对的是所有潜在bug和不正确的输入</p><blockquote><p>For example, if your code tries to open a file for reading and that file does not exist, should an exception be raised?</p></blockquote><p>这就涉及到exception的意义: <strong>exception用在处理设计者意想不到的状况, 不能参与正常的业务逻辑处理</strong></p><p>同时, 大量的异常处理会打乱整个代码的逻辑, 我们在debug的时候用exception<strong>只需要知道大概的范围, 但不需要精确到每一步</strong>,因此抛出异常的也只是一个try块, 最好不要是每一行代码都检测.</p><p>以我之前的经验, 在捕获异常的时候, 最好直接用<strong>方法+功能来定位</strong>, 这样设计者既可以直接找到出错的地方, 也可以知道运行的宏观逻辑.</p><blockquote><p>An error handler is a routine that is called when an error is detected.</p></blockquote><p>可以设计一个专门用来处理异常信息的接口, 便于异常的管理和查找</p><blockquote><p>Finish What You Start</p></blockquote><p>尽量在同一个方法内完成打开和关闭操作, 否则很容易出现多次打开或不正确的打开时机等问题</p><p>也可以利用语言内部的对称性, 将资源的打开关闭放在构造和析构函数里. <strong>用一个类实例作为资源的抽象</strong>, 同样的, 这种方式也能避免在throw exception的时候没有释放资源, 因为资源会随着C++的特性自动释放</p><p><strong>deallocate structure</strong></p><p>书中给了三种方式:</p><ol><li>父结构自行负责子结构资源的分配和释放</li><li>父结构不管子结构, 每个结构独立管理资源的分配和释放</li><li>如果父结构还有子结构的资源, 则拒绝释放.(外部管理)<h3 id="flexible-适应性强的代码"><a href="#flexible-适应性强的代码" class="headerlink" title="flexible 适应性强的代码"></a>flexible 适应性强的代码</h3></li></ol><blockquote><p>A good way to stay flexible is to write less code.</p></blockquote><p>这个建议很简单, 只要不写代码, 就能降低代码的修改难度. <strong>保持代码的简洁性也是增强适应性的一个方式</strong></p><blockquote><p>Rather than digging though a hierarchy yourself, just ask for what you need directly.</p></blockquote><p>在一个类中对另一个类的接口调用<strong>尽量只调用浅层的方法</strong>, 因为如果一连串地调用, 就减少了封装的程度, 增加了耦合度.</p><p><strong>The Law of Demeter for Functions</strong></p><p>任何方法只能调用:</p><ol><li>自身的方法</li><li>传入参数的方法</li><li>方法定义域中生成的实例的方法.<blockquote><p>First, we want to make our systems highly configurable. Not just things such as screen colors and prompt text, but deeply ingrained items such as the choice of algorithms, database products, middleware technology, and user-interface style.</p></blockquote></li></ol><p>从<strong>外部定制</strong>来说, 可定制的远远不止用户的flavor, 更包含开发者的可选项. <strong>用文件来定制被每次都修改源代码更加优美</strong></p><p>可定制的有很多, 比如运行路径, 用户界面, 平台等.</p><blockquote><p>Our goal is to think declaratively (specifying what is to be done, not how) and create highly dynamic and adaptable programs. We do this by adopting a general rule: program for the general case, and put the specifics somewhere else—outside the compiled code base.</p></blockquote><p>这一段写的非常出乎我意料. *<em>我们写出的程序是一次性编译的, 那么就不应该存在特定的目的. *</em></p><p>最理想的状态是用metadata描述程序的功能, 然后整个程序是一个引擎, 对描述进行解析, 并按照预想的方式运行. 这样, 程序的功能部分用人类语言描述出来, 保留了大部分业务逻辑的信息. 然后引擎本身也是高度解耦的, 可以较大程度覆盖可能的业务逻辑.</p><p>在工作场景里, 写一个程序不仅要覆盖给定的需求, 更要在拓展潜在需求上尽量做到健壮, 灵活. 这种写程序的目标是整个可能性的组合, 而不是一个单一的目的.</p><h3 id="workflow-用户的操作空间"><a href="#workflow-用户的操作空间" class="headerlink" title="workflow 用户的操作空间"></a>workflow 用户的操作空间</h3><blockquote><p>It can be eye-opening to see where the dependencies really exist.</p></blockquote><p>workflow用在这种地方: 用户可以执行不同的操作, 但是一些操作需要在另一些操作执行完以后才能执行. 那么如何设计程序? 这就是<strong>用图形表达出用户可能的所有操作, 即一个操作空间</strong></p><p>基于操作空间, 可以设计前端的结构:</p><blockquote><p>In a hungry consumer model, you replace the central scheduler with a number of independent consumer tasks and a centralized work queue.</p></blockquote><p>序列化, 也就是将用户的操作拆分成<strong>去中心化的动作, 然后放在中心化的序列中</strong>, 这种设置比用很多flag表示要有效得多.</p><p>同时, 可以将多个序列进行拆分重组, 进而达到多线程的目的. 上述的workflow检测依赖性, 然后将满足解耦条件的动作从序列中抽出. 也可以合并多个序列, 只要检测能否互相并存即可. 这种情况下, <strong>所有的依赖性都可以通过检测序列来实现</strong></p><h3 id="concurrency-同时性"><a href="#concurrency-同时性" class="headerlink" title="concurrency 同时性"></a>concurrency 同时性</h3><blockquote><p>Because things can now happen at the “same time,” you may suddenly see some time-based dependencies.</p></blockquote><p>多线程并不是”麻烦”的技术, 相反, 多线程给代码设置更高的要求, 让一些低劣的代码不能正常运行, 这促使开发者提高编程水平.</p><h3 id="Publish-Subscribe消息机制"><a href="#Publish-Subscribe消息机制" class="headerlink" title="Publish/Subscribe消息机制"></a>Publish/Subscribe消息机制</h3><blockquote><p>Objects should be able to register to receive only the events they need, and should never be sent events they don’t need.</p></blockquote><p>这个消息通知机制就是cocos2d里用到的机制: <strong>接受者向发送者注册, 然后发送者每回发送的时候, 都向注册了的组件发出通知</strong></p><p>这里我有一些启发: 对于可以通信的东西, 它们交流代码媒介是什么呢? 既然消息是去中心化的, 那么交流一定要有一个共同语言. 而<strong>共同的基类就是组件间交流的语言</strong>, 当组件都有相同的基类的时候, 组件间的交流就可以基于这个语言, 当然也只能限于这个语言.</p><h3 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h3><p><a href="https://baike.baidu.com/item/MVC%E6%A1%86%E6%9E%B6/9241230?fromtitle=MVC%E6%A8%A1%E5%BC%8F&fromid=713147&fr=aladdin" target="_blank" rel="noopener">MVC设计模式</a></p><blockquote><p>separating the model from both the GUI that represents it and the controls that manage the view</p></blockquote><p>这是MVC的设计思想:<strong>数据被封装成一个model, 读取和写入都是单向的</strong>,</p><p>MVC的设计思想不仅用在GUI的设计中, 只要是涉及数据+交互的, 都可以用MVC进行解耦.</p><h3 id="Blackboard-匿名论坛设计模式"><a href="#Blackboard-匿名论坛设计模式" class="headerlink" title="Blackboard 匿名论坛设计模式"></a>Blackboard 匿名论坛设计模式</h3><blockquote><p>A blackboard system lets us decouple our objects from each other completely, providing a forum where knowledge consumers and producers can exchange data anonymously and asynchronously.</p></blockquote><p>黑板设计模式的意义在于<strong>黑板本身仅是一个容器, 而业务逻辑被分散到各个组件中去</strong>, 这是去中心化的. 去中心化有它的好处, 对于非常复杂的规则, 如果编写一个中心化的东西(可以参考桌游的gm), 那么对所有情况进行组合是非常困难的. 但是现实中很多逻辑本身就是去中心化的, 比如人与人的交流活动, 而将去中心化的东西用程序实现, 就涉及到一个”论坛”, 论坛中的讨论者是去中心化的, 但是论坛本身是中心化的, 这样就可以做到组件的充分解耦.</p><p>我也想把这个模式叫做<strong>匿名论坛模式</strong></p><h3 id="Programming-by-Coincidence"><a href="#Programming-by-Coincidence" class="headerlink" title="Programming by Coincidence"></a>Programming by Coincidence</h3><blockquote><p>As developers, we also work in minefields.</p></blockquote><p>要避免coding中的一些潜在问题, 我摘选了几点比较好的建议:</p><ol><li>在运用新技术时一定要先作技术验证, 避免产生歧义.</li><li>不要依赖潜在的东西, 比如语言, 平台, 和测试的特定接口</li><li>在测试的时候, 不仅确保结果正确, 也确保过程和预想的一样.</li><li>不要为了兼容而兼容, 在适当的时候就要果断进行重构<h3 id="optimizing-性能优化"><a href="#optimizing-性能优化" class="headerlink" title="optimizing 性能优化"></a>optimizing 性能优化</h3></li></ol><p>这部分还是关于时间复杂度的, 但是程序整体的性能瓶颈并不一定是算法, 也可能是读写速度, 存储空间等</p><h3 id="refactor-重构"><a href="#refactor-重构" class="headerlink" title="refactor 重构"></a>refactor 重构</h3><p>四个重构的场景:</p><ol><li>代码有重复性(DRY)</li><li>代码耦合度高</li><li>代码中应用的assumption过于陈旧</li><li>有性能瓶颈<blockquote><p>Don’t try to refactor and add functionality at the same time.</p></blockquote></li></ol><p>重构的理念是<strong>小步重构, 大量测试</strong>, 也就是不要在重构的时候无意间改变了原先的业务逻辑.</p><h3 id="test-测试"><a href="#test-测试" class="headerlink" title="test 测试"></a>test 测试</h3><blockquote><p>In C++ you can achieve the same effect (at compile time) by using #ifdef to compile unit test code selectively.</p></blockquote><p>之前有提到说每一个模块都应该带有对自身的测试代码, 那么这些测试代码就可以放在宏定义里面. 当然, <strong>测试的逻辑一定要和业务逻辑的代码解耦</strong></p><blockquote><p>A test harness can handle common operations such as logging status, analyzing output for expected results, and selecting and running the tests.</p></blockquote><p>我认为每个系统的测试都是不一样的, 很难做到同一个测试系统用于不同的代码, 但是在log中对error和warning由专门的分类比直接用string写字符串要好很多.</p><p>我认为一个良好的log应该是包含<strong>可视化, 分级, 折叠, 自动保存信息</strong>等功能, 用不同的颜色输出error和warning, 然后每次输出后都保存到文档中, 以便下次调试时比较. 对于比较复杂的系统, 将次要的输出信息折叠起来, 只保留主要部分.</p><p>但与其对一段不良的代码做许多测试, 还不如<strong>尽量编写没有bug的代码</strong>,通过改良编程习惯, 加深对底层的理解,做到防患于未然</p><blockquote><p>The wizard code is not factored out behind a tidy interface—it is interwoven line by line with functionality that Joe writes.</p></blockquote><p>这里的wizard指的是自动代码生成器, 就像自动类框架生成这种东西. 但是使用的条件是开发者必须完全熟悉wizard生成的代码, 因为这些代码是全面地和开发者的代码混合的.</p><h3 id="The-Requirements-Pit-充分理解需求"><a href="#The-Requirements-Pit-充分理解需求" class="headerlink" title="The Requirements Pit 充分理解需求"></a>The Requirements Pit 充分理解需求</h3><blockquote><p>Requirements rarely lie on the surface. Normally, they’re buried deep beneath layers of assumptions, misconceptions, and politics.</p></blockquote><p>寻找<strong>真正的需求</strong>确实是比较困难的, 有时候难以想象完全整个交互场景, 有时候没有真正拆解需求的组合, 导致设计的框架过于复杂.</p><blockquote><p>It’s important to discover the underlying reason why users do a particular thing, rather than just the way they currently do it.</p></blockquote><p>真正的需求可能连用户自己都不清楚, 因为<strong>一个单一的需求无法决定整个程序框架, 可能的需求和潜在的变动一同组成的需求域才能决定程序哪方面需要flexible</strong></p><p>另一个了解需求的方法是: 假设自己是用户. 也就是站在用户的角度思考自己计划的设计是否足够强大, 且足够方便.</p><blockquote><p>Don’t be a slave to any notation; use whatever method best communicates the requirements with your audience.</p></blockquote><p>在理解并记录需求的时候需要的是最符合业务逻辑的语言, <strong>业务逻辑的语言并不局限于任何一种图表或记号</strong></p><h3 id="Maintain-a-Glossary-制作术语表"><a href="#Maintain-a-Glossary-制作术语表" class="headerlink" title="Maintain a Glossary 制作术语表"></a>Maintain a Glossary 制作术语表</h3><p>这也是一个<strong>标准化</strong>的东西, 对文档中的描述给定一个准确的定义, 当然这主要用在大型项目中. 从共同的语言中特异化一些东西来描述业务逻辑, 可以说是一种”业务语言”</p><h3 id="while-in-coding"><a href="#while-in-coding" class="headerlink" title="while in coding"></a>while in coding</h3><p>这一节实际上是之前的小节的汇总, 包含一些我觉得很有用的观点.</p><ol><li>在开始项目之前做技术验证和原型建模</li><li>在开始项目之前先扫除直觉上的担忧</li><li>不要写太多太详细的技术文档, 要拥有较强的灵活性<blockquote><p>Often, it is only during coding that certain options become apparent.</p></blockquote></li></ol><p>我也有类似的经验, 写着写着才发现有的地方可以用很巧妙的方式实现, 或者以另一个方式拓展. 但是否要遵循这种方向? 我觉得应该要看这个拓展性是不是符合项目需求或潜在需求的.</p><blockquote><p>Never underestimate the cost of adopting new tools and methods.</p></blockquote><p>这是建议不要在正式项目中<strong>过多使用不熟悉的技术</strong>, 同样地, 框架设计应该在满足需求的同时尽可能简洁, 而不是在没有必要的地方留下拓展接口.</p><blockquote><p>Test Early. Test Often. Test Automatically.</p></blockquote><p>在集成化测试前作单元测试是很有必要的, 因为越是复杂的不可靠系统越难找到真正的bug, 最好在每次build时都自动地进行测试</p><h3 id="comments-注释"><a href="#comments-注释" class="headerlink" title="comments 注释"></a>comments 注释</h3><blockquote><p>In general, comments should discuss why something is done, its purpose and its goal.</p></blockquote><p>注释是另一个维度的东西, 注释补全了代码中人的意图和业务逻辑, <strong>注释和代码是互补的, 是高层次的逻辑抽象, 而不是代码的翻译</strong></p><p>与doxygen相反地, 可以把<strong>设计文档的一部分通过自动生成器同步到代码注释中去</strong>, 也可以将代码注释和技术文档各自独立, 并单向集成到API Reference中</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>读完真是身心俱疲…</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>编程思想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程设开发总结</title>
    <link href="/2020/07/24/%E7%A8%8B%E8%AE%BE%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <url>/2020/07/24/%E7%A8%8B%E8%AE%BE%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="2020年7月程设开发总结"><a href="#2020年7月程设开发总结" class="headerlink" title="2020年7月程设开发总结"></a>2020年7月程设开发总结</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今年6月上旬到七月初的这二十多天大概是我人生中第一次写一个3K-5K量级的项目, 从第一天对游戏引擎完全不了解, 到自己用一下午去设计一个UI界面, 甚至去分析飞船的结构特点, 最终用稍微超过预期的时间完成了一个勉强满意的”模具”, 虽然离理想中的游戏差距很多, 但是提供了一个可以完善的平台, 让我有信心继续做下去. 中间着实有不少困难, 甚至让最初企划时的兴奋感都消散殆尽, 但是能做出一个能代表自己风格的作品, 确实是一件有意义的事, 甚至可以说没有什么比自我实现这种事更有意义了.</p><p>当然, 在这种量级的开发中, 尽管已经提前设想过一些解决方案, 但还是遇到了意料之外的情况. 设计的理念也有待改进. 这篇文章就是总结这些琐碎的东西的.</p><h3 id="健壮性和复杂性-应当考虑不变的是什么-而不是可变的是什么"><a href="#健壮性和复杂性-应当考虑不变的是什么-而不是可变的是什么" class="headerlink" title="健壮性和复杂性: 应当考虑不变的是什么, 而不是可变的是什么."></a>健壮性和复杂性: 应当考虑不变的是什么, 而不是可变的是什么.</h3><p>在写这个游戏的最开始, 我的构想还不是很成熟, 于是最初的目标就是: 尽可能保证底层设计的健壮性, 这样以后再变动设计时就能尽量减小重构次数. 依照这个方案, 前期对底层的处理确实比较模块化, 同时避免了后面的许多问题. 但是这样也使得整个设计非常复杂, 在处理<strong>类的相互包含问题</strong>的时候, 我之前设计的复杂的相互引用机制让debug变得异常困难. 如果舍弃这个机制, 整个底层都要重构, 好在最后尽量避免了相互引用, 然后<strong>把独立的方法集成到一个工具类中</strong>, 这样就确定了一个不循环的结构关系, 当然<strong>如何设计一个自顶而下又可以互相通信的机制</strong>也是我没考虑过的问题. 所以这里我先提出一点想法:</p><p><strong>在设计的时候先考虑哪些需求是不会改变的, 再以此设计一个最精简的系统</strong></p><p>就例如游戏中的各个scene, 整个游戏流程只需要提供一个实例, 那么scene只需要一个静态成员存放instance就可以了, 然后用getInstance()方法, 完全可以避免成员需要拿指针的问题. DataLoader也是, 同一时间只能加载一个存放的内容, 不同存档不需要交换信息, 而且DataLoader的类型也是确定的: 加载游戏配置数据和玩家存档里的数据, 这样就只要设定两个静态成员就可以了.</p><h3 id="对内部细节的封装"><a href="#对内部细节的封装" class="headerlink" title="对内部细节的封装"></a>对内部细节的封装</h3><p>一开始我对飞机的定义很不明确, 武器是否可更换? 飞机是否可更换? 飞机型号是否有特殊技能? 是否有特定的增益? 但在设计的时候应该始终把飞机看作一个”黑箱”, 对战斗scene来说, 只要能获取飞机的位置/血量等数据就可以, 而不需要关注内部的东西, 同样整个level生产的也无外乎飞机/子弹/掉落物/特效等, 设计的时候就设计几个基类供level调用即可.</p><h3 id="代码的可维护性"><a href="#代码的可维护性" class="headerlink" title="代码的可维护性"></a>代码的可维护性</h3><p>写到后面的时候时常会犯一些低级错误: 重载函数写错了参数列表, if语句中==少打了一个=, 还有各种约定的规则没有被遵守. coding的过程也是<strong>不断制定规则的过程</strong>, 但是这些规则在编写的时候制定下来, 又如何保证一定能被遵守呢? <strong>任何程序员自行编写的规则都尽量要做到强制被遵守</strong>, 例如两个函数调用前后的顺序, 就用isLoaded来检测, 在没有遵守的时候抛出异常, 又如Reflection这个类的机制, 这是个反例, 所有的飞机都需要在创建的时候手动向反射表注册, 这样并不符合上面所说的理念. 这个改进的方案还没想好(也许没有?), 但是像这种规则即使不能避免, 也要及时整理在技术文档里.</p><p>save里的数据也缺乏维护性, 这是因为最初的时候对<strong>飞机/子弹的实例和模版概念没有分清</strong>导致的, 按理说save里只能存放实例, 也就是一些具有特异性的东西, 但是<strong>属性本身就是有变和不变两个性质的</strong>, 属性的数量/类别/作用都是不变的, 但属性的数值却是可变的, 所以一个武器的属性表就应该同时存放在gameData和save里, 同时这里实例的概念是什么? 是拥有相同属性, 相同的类模版, 但属性数值可以不同的一些飞船. 一个实例并不代表游戏里的一个飞船, 事实上<strong>实例本身仅有数值特意化的功能, 实际生成的数量是由程序控制的, 每个游戏内实体的区分也仅靠内存地址的不同</strong>, storage里存放的实例都是不同的, 因为给玩家相同参数的东西没有意义, 所以每个物品对应一个实例, 但level里的实例是可复用的, 因为生成的飞机基本都是一样的外观, 方便动态控制生成的数量. 这也限制了按照实例查找个体的范围, 这个范围是不能包括可复用实例的区域的.</p><p>像这种唯一性的确定规则, 应当在设计的时候就想好. 后期更改会带来很大的麻烦</p><h3 id="开发进度的可视化-amp-迭代开发"><a href="#开发进度的可视化-amp-迭代开发" class="headerlink" title="开发进度的可视化&amp;迭代开发"></a>开发进度的可视化&amp;迭代开发</h3><p>整个开发过程最艰难的大概就是做UI和写行星生成器的时候, 这里我的开发流程并不合理, 首先行星生成器我花了3天时间研究, 但是结果上这一个东西因为性能原因不能产生大面积的可动背景, 而这三天里, 我并没有做任何推动开发进度的东西, 导致写完以后一度丧失了进行下去的信心. <strong>对一个独立开发者而言, 如何规定开发计划, 让整个开发进度可视化, 并得到充分的反馈, 是开发能否进行下去的关键</strong>, 在做行星生成器的时候, 我把整个游戏背景设计/UI设计完全押注在这一个技术的实现上, 然而这种是很危险的. 对一个最精简框架所必须的UI, 背景图片而言, 他们虽然要遵循一个统一的视觉形象, 但是不能依赖一个未知能否实现的技术.</p><p>在规划的时候也应该从最精简的框架入手, 先<strong>搭建出一个能用的东西, 再去思考怎样让它变得更好</strong>. 过度追求完美是很危险的, 就像我在写行星生成器的时候, 过度想让它完美呈现, 却因此破坏了整个游戏的开发进程, 也破坏了迭代开发的原则. 以后的设计中要避免各个技术的相互耦合, 对于难度高的技术, 尽量先写一个可用的版本, 再去完善它.</p><h3 id="文档规范化-amp-注释规范化"><a href="#文档规范化-amp-注释规范化" class="headerlink" title="文档规范化&amp;注释规范化"></a>文档规范化&amp;注释规范化</h3><p>这次没有用doxygen生成文档, 虽然写了许多注释, 但回看的时候效果都很差: <strong>太少注释让人无法理解运行原理, 太多注释让人花费大量的时间在浏览无用信息上</strong>, 后期修改一个源文件的时候, 经常在十几个方法里面寻找, 但是在中途就忘记了自己要找什么东西. 同时满足注释的详细程度和检索遍历程度, 听起来是矛盾的, 但其实也有方法: <strong>一些注释是只需要全局检索的, 例如TODO, 那么只要有可检索的关键字就行了</strong>, 而需要让人了解”这个方法是干什么的”这些注释, 不能写得太过琐碎, 最好写出<strong>一整块注释, 大致说明代码的功能, 需要特别注意的地方在所在行添加注释</strong>, 这样就不必在繁多的注释行中不断阅读.</p><p>doxygen也是比较方便的, 但是我还没有关注过注释的可维护性, 在对程序进行修改的时候, 注释很难进行同步修改, 这也是我写大量功能性注释的弊端:<strong>注释太多反而加大了修改的工作量, 也增添了额外的规则</strong>, 而最好是在一段代码通过稳定测试以后再写一个总结性质的注释.</p><h3 id="过程中的奇异bug们与一些零碎经验"><a href="#过程中的奇异bug们与一些零碎经验" class="headerlink" title="过程中的奇异bug们与一些零碎经验"></a>过程中的奇异bug们与一些零碎经验</h3><p>开发过程中也遇上了一些奇怪的bug:</p><ol><li><p>枚举的size{small,medium,large}中的small与cocos2d命名空间的一个宏定义重名(所以<strong>一般在cpp里用using namespace而不要在头文件里用</strong>)</p></li><li><p>设置rotation后再设置anchorPoint总是显示错位, 后来发现是因为旋转后锚点的位置也会在坐标系中改变</p></li><li><p>提示nullptr, 是因为垃圾自动回收机制导致的</p></li><li><p>用removeChildByName的时候, 对参数理解不到位, 导致后来一些奇奇怪怪的报错(以后要多看reference)<br>也有一些零碎的东西需要改进</p></li><li><p>cocos2d::ui这个命名空间太长了, 最好用 <code>namespace vlns = very::long::namespace</code> 削短</p></li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
      <category>游戏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏开发</tag>
      
      <tag>cocos2d</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020SummerGame：美工设计笔记</title>
    <link href="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="2020SummerGame：美工设计笔记"><a href="#2020SummerGame：美工设计笔记" class="headerlink" title="2020SummerGame：美工设计笔记"></a>2020SummerGame：美工设计笔记</h1><h2 id="美工设计笔记——飞船设计P"><a href="#美工设计笔记——飞船设计P" class="headerlink" title="美工设计笔记——飞船设计P"></a>美工设计笔记——飞船设计P</h2><p>因为假期时间很充裕，这次游戏的美工打算自己画，也是积累一些美术方面的经验。整个学习过程就是：观看优秀的美工设计-总结各自的优缺点和风格特异性-尝试转移到自己的设计上。而关于理论方面，我打算先自己看完优秀案例再学习理论基础，以便能随时与实践联系起来。</p><p>初步来说，整体的美工设计包括飞船设计、武器设计、子弹/激光等特效设计，爆炸效果设计，游戏背景设计，UI设计，宝石设计。当然整体的风格要统一。</p><h3 id="Star-sector飞船拆解：涂装、外壳纹理、外壳结构、内部器件、功能模块"><a href="#Star-sector飞船拆解：涂装、外壳纹理、外壳结构、内部器件、功能模块" class="headerlink" title="Star sector飞船拆解：涂装、外壳纹理、外壳结构、内部器件、功能模块"></a>Star sector飞船拆解：涂装、外壳纹理、外壳结构、内部器件、功能模块</h3><p>Star sector的飞船设计很明显的特点就是：各方阵容特色鲜明，整体造型统一，同时与UI搭配和谐。整体拆解如上所说，但是部分结构还是需要细分：首先关注一下打光，star sector的飞船打光大都是<strong>从上向下的点光源或线光源</strong>，打光区分<strong>球面</strong>和<strong>圆盘</strong>，同时根据反光度的不同，区分<strong>外壳</strong>和内部<strong>器件</strong>，同时根据光和阴影的分布，可以将飞船的曲面表示出来，许多飞船<strong>中间亮两边暗</strong>，整体呈现半球形的曲面分布。</p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/b9a5e2688026aea33132a83487f68bbb.png" srcset="/img/loading.gif" class=""><p>（打光下的球体，注意两个小球的光点并不在中间，这种对应的物理结构我还没搞清楚）</p><p>不同阵营的涂装、外壳结构、外壳纹理是不同的。<strong>外壳覆盖范围</strong>有全覆盖型（看起来很坚固，但是速度缓慢）、半覆盖型、贴边覆盖型（只有贴边的平行装甲，中间部分都是露出的）、无覆盖型（找不到光滑面，都是内部器件）。按照<strong>对称性</strong>划分可以有对称型和不规则型，其中不规则型大多采用圆滑设计，来保持整体美观。同样，根据势力范围不同，飞船的<strong>基本图案</strong>也是不同的，分为以平行四边形为基础和以圆形为基础。但是，在各个阵营的飞船中也能找到共同的东西，比如<strong>统一为白色的舰桥</strong>：</p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/71532e57a67ac4f036ba59f9177281ef.png" srcset="/img/loading.gif" class=""><p>当外壳结构确定好后，外壳纹理起到细化的作用。<strong>拼装式外壳纹理</strong>经常在以圆形为基础的飞船上看见，此时飞船表面像是被设计好的几块外壳拼装出来一样：</p><p><strong>搭建式外壳纹理</strong>在以平行四边形为基础的飞船上看见，此时飞船表面各部件有实际的层次。这是因为拼装出的类似球状在光的渲染下比较好看，而如果平行四边形采用拼装式，那么只能得到一块平面，如果平行四边形在3维空间采用曲面设计的话，就其二维特征不统一了，反而会破坏飞船的美感。</p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/6a8b6a51709adf96539ca7cf85bc9ecf.png" srcset="/img/loading.gif" class=""><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/1e18c10bef9b8a3e85fc039c0db29d29.png" srcset="/img/loading.gif" class=""><p>再来看下涂装，starsector飞船有涂装的很少，但是涂装能大大改善单个机体的外观确是无疑的。涂装分为两种：<strong>线型涂装</strong>主要沿机体方向勾勒出一条或几条线，它能直接把繁复的装甲结构统一成一个整体，由涂装飞船获得了精细与整体性的平衡。而<strong>面型涂装</strong>主要是有装饰作用，所有外壳刷上统一色系的涂装会强烈凸显出外壳与内部器件的对比感。另外，当飞船装甲过大时，合理利用涂装以显示分区可以让整体更加醒目</p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/27a23ea4f02a4091df97886fb83ac69d.png" srcset="/img/loading.gif" class=""><p>此外，海盗在其他势力的制式飞船上加涂装更能彰显其个性——这也是其他制式飞船很少画涂装的原因。</p><p>飞船的功能结构与其游戏内容是契合的，这里发现的<strong>功能结构</strong>有武器（机枪、激光）、机库、舰桥（航母有大舰桥，小飞机有小的舰桥）、引擎周围的导热管、货仓、存储罐、舷窗（有黄色亮光）、飞机指示灯（在机翼边缘）、反应装甲（这是从坦克上借鉴的）</p><p>飞船的“内部器件”是具有重要功能的模块，颜色一般以灰色、深灰色为主，内容主要是<strong>平行的管线</strong>、<strong>类似集成电路的设计</strong>，内部器件被故意设计成繁复的，一是为了凸显<strong>飞船的真实性</strong>，比如引擎给人的印象就是复杂，这种设计能突出引擎特征，二是与相对简单的装甲形成<strong>强烈对比</strong>，增添飞船层次性，让整个设计错落有致。在外壳周围的一些暗部设计很好地起到了<strong>装饰边缘</strong>的作用。</p><p>综合起来，starsector的飞船设计理念可以总结为：统一性、多样性、对称性、层次性、功能性、阵营风格各异。当然缺点也存在：大多数飞船缺乏涂装，内部器件和外部装甲的比例不协调，而且外部装甲的装饰太过复杂，导致整体看起来过于零碎没有统一感。大多数飞船色彩搭配并不鲜艳（虽然在鲜艳和真实感之间取得平衡时很困难的事），但有少数飞船结合优秀的曲面设计和对称性设计，虽然不鲜艳但是给人以强烈的美感。</p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/45f6a4319921dbfa4e24a680da4bd785.png" srcset="/img/loading.gif" class=""><h3 id="其他设计飞船拆解：案例与优劣分析"><a href="#其他设计飞船拆解：案例与优劣分析" class="headerlink" title="其他设计飞船拆解：案例与优劣分析"></a>其他设计飞船拆解：案例与优劣分析</h3><p><strong>一种相对小巧的飞船</strong></p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/5507559d4c9368d20e2751def388db6d.png" srcset="/img/loading.gif" class=""><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/cc2b75a5c6cba835fe489d3fa0ff4838.png" srcset="/img/loading.gif" class=""><p>优势：P2的颜色设计非常值得借鉴，灯光将机体的<strong>边缘</strong>映照出相同的颜色，白色作为<strong>连通颜色</strong>连接不同的区域，让足足5种颜色和谐地融汇在一起。P1和P2装甲的非发光部分做了做旧处理，增加了阴影，整体摆脱了平面化。</p><p>劣势：虽然有阴影，但是整体的光源并不清晰，也可能是平面光，让飞船的立体感不强烈。同时缺少作为复杂性点缀的内部器件，导致颜色的整体对比度也不强烈，缺少现实感。</p><p><strong>使用偏置光源的立体式飞船</strong></p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/664050ac456f11d91ec7984f15295521.png" srcset="/img/loading.gif" class=""><p>评价：这个飞船使用的是偏置光源，同时注意飞船的结构是三维立体式结构，这种结构的劣势在于：它<strong>过于写实</strong>，从而与低像素的画风形成不统一。3维飞船的直接映射需要强烈的立体支撑感，包括高清晰度、光源的正确照射，甚至要求必须在三维背景下完成，而这种设定对一个2D游戏是不可接受的。另外，因为3维飞船的真实性，许多2D用到的技巧都不可行，比如在飞船周围增加武器零件以丰富颜色对比度，这使得飞船的观感更差。</p><p><strong>配色出彩的一组飞船</strong></p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/3eb22e6231fbd04cd1e92be577aca4d4.png" srcset="/img/loading.gif" class=""><p>评价：这组飞船的最大特点就是配色非常舒服，每个飞船大致有3种主要颜色：一种主颜色和两种辅助色，主颜色又包含偏暗的阴影颜色。辅助色用于驾驶舱、灯光等点缀。</p><p><strong>造型和涂装都富有特色的飞船</strong></p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/1c8b396ab142f8ffae13f9053b1fd71f.png" srcset="/img/loading.gif" class=""><p>评价：这个飞船的造型很好看，整体呈现一个三角形，明显的轴对称结构，中间紧实两侧舒展，越靠近中间处颜色越浅，两侧占面积比较大的区域用深灰色，这样让整个飞机中心突出。同时在深灰色区域也都加上装甲设计，略微摆脱廉价感。但不足的是，没有强烈的阴影对照，整体的立体感欠缺很多。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>人权的边界线——底层人民的经济困境与生育权利</title>
    <link href="/2020/07/24/%E4%BA%BA%E6%9D%83%E7%9A%84%E8%BE%B9%E7%95%8C%E7%BA%BF%E2%80%94%E2%80%94%E5%BA%95%E5%B1%82%E4%BA%BA%E6%B0%91%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%9B%B0%E5%A2%83%E4%B8%8E%E7%94%9F%E8%82%B2%E6%9D%83%E5%88%A9/"/>
    <url>/2020/07/24/%E4%BA%BA%E6%9D%83%E7%9A%84%E8%BE%B9%E7%95%8C%E7%BA%BF%E2%80%94%E2%80%94%E5%BA%95%E5%B1%82%E4%BA%BA%E6%B0%91%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%9B%B0%E5%A2%83%E4%B8%8E%E7%94%9F%E8%82%B2%E6%9D%83%E5%88%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="人权的边界线——底层人民的经济困境与生育权利"><a href="#人权的边界线——底层人民的经济困境与生育权利" class="headerlink" title="人权的边界线——底层人民的经济困境与生育权利"></a>人权的边界线——底层人民的经济困境与生育权利</h1><blockquote><p>2020年5月29日广西河池，都安县保安乡上镇村弄邓，一对90后夫妻目前生育有9个孩子，分别有3个女儿6个儿子，最大的孩子12岁在读4年级，还有1个再有3个月也会降生。男子平时外出在工地打工赚钱养家，家里种有玉米自己吃。男子表示有在家产子的经历，都是老妈在帮忙。这对夫妻对未来充满希望，表示会慢慢打工为所有的孩子赚足学费。</p></blockquote><p>将每个家庭的财产与生育率作一幅图，生育率的图像呈现哑铃形：最低处是中产家庭，两边是富裕家庭和底层家庭。富裕家庭为了确保自己的产业有继承者，往往会生育不只一个孩子；底层人民则是在买“生产力”，一般来说，一个男孩成年后打工或者务农，总能挣到超过他抚养费用的生活费，加上政府给的低保费用，一户贫穷人家由此重获新生，如果中了“生育彩票”，培养出有正经工作的孩子，那么这户人家就很大可能在接下来的几十年内摆脱贫困，所有兄弟姐妹都可以过上好日子。</p><p>但我看到这个理论的时候，总是对其有很深的抵触，思考许久，我的疑惑是：人的权利，到底是谁在维护谁的权利？</p><hr><p><strong>消灭苦难有两种方式，要么改善现状，要么消灭幸福</strong></p><p>人们总是认为贫穷是单纯的，就像是缺水、缺粮一样，忍忍就过去了。但贫穷有着独特的吸引力：它将开阔的变成狭隘的、将公平变成嫉妒、将善良变成丑恶。就像是千千万万贪欲“幸福”的困苦家庭一样，这户人家选择在贫困中创造一个又一个生命。忍受着常年的物质匮乏，接受远远落后于他们求知欲的教育，长大则背负十一份责任，曾经的兄弟姐妹都化作工厂里大汗淋漓时承受的压力，如此一日又一日，一年又一年，年老力衰时回到那个抚育自己的村落，又有了数倍于自己一辈的孩子们，十人养一人，百人养十人，这一循环不会轻易打破，因为每个人都心知肚明：如果不再让新的生命献祭给“贫穷”，那么他们自身就会被献祭——无劳动能力者没有活下去的权利。</p><p>在大一返乡时，我在动荡的火车厢里翻阅着何夕的《大饥之年》，“大饥之年，人易子而食。”那天的夜里没有星星，空气中混合着人们的谈论声，这几百上千人融洽地待在狭小的车厢中，一定程度上缓解了我的恐惧感。当时我应该想到，几百公里之外的广西，那是另一种的易子而食，人出生即被预支出劳动力，永远看不到理想，永远看不到自由，我们为何不将其视为家畜呢？当然，他们是幸福的，因为在满是苦难的土壤里根本不存在幸福的种子，活在相对性里的人们，将隆起的高山看作地之柱，将奔流而下的瀑布视为天之泉。</p><p>存在者才有权利，存在者构建的法律，保障的是存在者的权利。时间是它们忠实的卫士，试图违背人类本性的反叛者都在短短百年内被不留痕迹地抹去。在过去几千年的历史中，人类的一部分当然也尝试过改写这一法律，但最后，往往只有存在者的法律获得了最多的拥护，婴儿出生后即受法律保护，因为任何谋杀的手段都让现存于世的人们感到自身的存在受到威胁。未存在于世的“人”会如何感想呢？谁也不管这个。但奇怪的是，我竟然认为人在诞生之前就是被保护的，就像是对废纸篓怜悯每一丝纤维一样无意义。</p><hr><p><strong>相对性与生存策略</strong></p><p>若是作一个审判者，以绝对自洽的法律判断对错，我找不到这样的标准。我现在如此怜悯贫困中的孩子，也有千百年后生活在物质无限充足的社会中，那些怜悯着我的人类。我的生活是如我认为的那般幸福，还是说我也同那些孩子一样，只在苦难中存在？道德与正义建立在相对性之上，人们如同一个个观察者，在不同的时间、不同的地位上去看待一件事，谁是“真理”呢？历史已经写下了答案，真理并不存在于世界上，有的只是无穷无尽的斗争与反斗争，支配与反支配。</p><p>人是有会创造文化认同的社会性动物，它们是图腾。如果将人类看作一个整体，它的进化无疑是令人惊叹的：人类在无数的个体竞争中进行自我迭代，又在多变的历史环境下不断异化。贫穷的人不再遵循自然法则，他们的法则是金钱的法则、法律的法则。活在资本主义“世界”的人们开始了自己的异化：泯灭自由意志、吃苦耐劳、容易满足、永远乐观。基因里强大的适应能力给了人类无穷无尽的生存动力，他们从泥土里挖掘草根，在时间域里开拓近似无穷尽的生产力工具——他们自己是工具，工具也是自己。局外人用自己的图腾去衡量异教徒，注定是毫无意义的。</p><p>正如尼采所说：上帝已死。</p><p>不到二十年时间，我也不例外地找到了自己的生存方式。可我不能再论证人类超越动物性的“道德”与“正义”了，唯物者的视角被笼上一层阴影，当然，总有毫无阴霾的唯物者们信仰这一图腾。过去的时间里我为了是否接受人性的异化而犹豫着，最终选择了规则，但也留存一些大义的理想，其实是欲望的延伸，来自于幼小时记忆中不知名的角落。当然了，理想是相对的，手段是唯一的。理性视角下的我无须为自己的规则与外界格格不入而懊恼，但依然需要进行庞大的知识整理使得理论自洽。想想生活在相对论宇宙中的人类吧，地球以每秒29.8千米的速度绕太阳公转，太阳也以一个速度绕银河系公转，银河系与仙女系在几亿年后交融在一起……但博尔特的短跑记录是百米9秒58。相对性下的人类世界依然是可以被构建的。</p><p>自由意志，那是更深层的本源，人顺应异化本能地活着，与在自由意志的控制下活着，究竟是否为同一个事物呢？让我发笑的是，我的理想是试图用前者的方法构建后者的世界。这大概是互相矛盾的吧，但如果两者能统一的话，就没有任何问题了。</p><hr><p><strong>后记</strong></p><p>这篇文章写在假期的深夜，尽管已经过了凌晨一点，但我还是毫无睡意，有时候也为了自身的存在迷茫过，在思考很久以后，得到了这篇答案。无意义吗？意义是不存在的，每个人创建自己的图腾，然后按照规则行事。</p>]]></content>
    
    
    <categories>
      
      <category>经济</category>
      
    </categories>
    
    
    <tags>
      
      <tag>时政分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
