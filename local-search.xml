<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【二】矛盾根源</title>
    <link href="/2021/03/07/%E3%80%90%E4%BA%8C%E3%80%91%E7%9F%9B%E7%9B%BE%E6%A0%B9%E6%BA%90/"/>
    <url>/2021/03/07/%E3%80%90%E4%BA%8C%E3%80%91%E7%9F%9B%E7%9B%BE%E6%A0%B9%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h2 id="其一"><a href="#其一" class="headerlink" title="其一"></a>其一</h2><p>人对生命意义的追问起源于自身的矛盾，也就是在新皮质处形成的认知体系中，无法用已知方法寻求解决。我们所承认的一套认知体系，它可以是片面的，可以是矛盾的，它唯一的趋势就是迎合原始欲望的需要，用足够巧妙、灵活的方法解释世界，获取现实的反馈。幸运地，即使关于人生存的部分是直接被激素、神经刺激翻译出固定的意义，但是人生活的部分却有足够大的可变性。</p><p>一般化地，我们面临这样一个局面：在个体生存的环境中，一种原始欲望A的行为与原始欲望B的行为发生冲突，而冲突又是不可在外部解决的。这种看似无法解决的问题，实际上却可以通过改变中间为之翻译的话语体系来解决。欲望只是神经冲动，从饥饿感到想吃食物，中间有着理性为之翻译的过程，这个中间物质，就是话语体系。它将原始欲望在个体所处的时刻变化的环境中翻译成合理的东西，从而在客观上，准确地增加人生存下来的机率。如果是这样，我们可能要问一些问题：人能自我改变这种话语体系吗？话语体系是否可以任意改变？</p><p>现实中最典型的例子，一是传销，二是宗教。前者力图在小范围、短时间内改变一个人的认知，后者力图在长时间内构建新的话语体系，前者见效快，后者更加严密。但无论是哪种，都有人自我改变话语体系的例子，这是现实的、实践的证明。而在理论上，由千亿量级的神经元构成的极复杂的微观系统，应当具有不同于简单系统的特殊性质。这个性质就是，它在概率意义上（可以看作拿许多个复制人做实验），具有能够拟合一切思维的可能性。有意思的是，当我们讨论自由意志，却避开了这种可能性，反而试图探究一个人在单一时间线上是否能够做出所谓的自由选择。这里的自由是什么呢？人是没有改变时间的权力的，我们的命运，在宇宙的某个遥远的边缘已经被全部书写记录下来了，它存在吗？存在或不存在，无法得知。没有重新回到上一时刻的能力，就无法谈论自由。而我们在得到答案时产生的失落感，是由于我们错误地将生存期望同这个无意义的命题错误地联系起来。</p><p>回到最初的问题，在从实践和理论两个方面证明了这一可能性后，我们迫切想了解的是，如何改变，以及改变的界限在哪。虽然可以直接从实践上学习经验、总结原理，但这里试图从微观的角度解释宏观上总结的经验。</p><h2 id="其二"><a href="#其二" class="headerlink" title="其二"></a>其二</h2><p>一个合理的话语体系，必须是足够稳定的，它必然有足够强的生命力和自我修复能力来对抗外界的各种冲击。在复杂性极大的系统中，这种动态平衡就是稳定的直接定义，而简单系统中的静态平衡是不存在的。我所理解的抗冲击性在微观上来观察，就是一条回路的稳定性。它包括：在整体收敛的局部最优解（即这个话语体系自己），是否有另一种回路能够更好地服务原始欲望的表达和反馈？在它产生的所有信号中，是否存在某些情况使得它会与其他回路的输出信号矛盾？当然，生物学上的神经通路的建立有更多的条件：可塑性、足够的刺激，但这里讨论“解决冲突”而不是建立新的结构，因此不需要关注这些。</p><p>从宏观来看，第一个条件表现为，我们的话语体系是否会获得足够多（或者最多）的现实反馈，这是话语体系存在的基础。而第二个条件表现为，我们的话语体系是否是自恰的。这可以理解为：它对单一的事件A反应出喜悦，对单一的事件B反应出沮丧，而事件C中混合着事件A和事件B，话语体系自身又不允许表达矛盾的感受。如同学生在敬佩生病的老师依然坚持上课时，又因为老师不公正地批评了自己而怨恨他，究竟是倾佩还是怨恨？最终现实的回答往往是：“他是个好老师，但我不是个好学生”，以此正当化批评的起因，从而维持话语体系的稳定。</p><p>相反，许多所谓的话语体系建构理论，都是基于文字游戏。它们提出一个新的、合理的东西，要求人去相信它，但是有与个体所处的环境差异太大，无法改变任何有关原始欲望的现实的矛盾。这样的话语体系有效吗？它就像一个被证明正确的数学定理意义，正确，但是无用。而正因为无用，我们更难以接收它们，以至于需要一遍又一遍的自我暗示来强制内心接受它们。不基于现实矛盾的话语体系是无效的，不能用现实的外部闭环来完善自己的话语体系是缺乏养分的。后者需要在现实中建议一个有效的回路，它可以是获取正面的情感，也可以是规避负面的情感。</p><h2 id="其三"><a href="#其三" class="headerlink" title="其三"></a>其三</h2><p>以上给出的条件依然不够明确，需要多强烈的外部闭环？我认为这取决于人的状态。哺乳脑，一说情感脑，即人掌握情感的、较原始的部分，在我看来是可塑的，但需要足够多的时间，和稳定的外部闭环。我们必须时刻注意那被束缚在脱氧核苷酸中的基因，和时刻释放着电信号的神经元，它们之间的时间感知差异是多么显著。但即使有那么大的差异，也不能默认较慢的部分没有改变的可能。困难在于，如何构建现实中稳定的闭环？这就需要对现实的足够的理解了。</p><p>人并非崇高的生物，欲望，可以被以各种不合逻辑的、简陋的方式满足，即使这些方式与话语体系冲突，但那它毫无疑问能获得正向的情绪响应，能满足情绪需求。简单地说，饮鸩止渴，缺水和毒性是两个问题。解决了前者，之后再解决后者，问题被这样转移了，在现实的外部世界中被解决的机会也就提升了。人并非崇高的生物，其实是指人完全可以以不崇高的形式生活下去。崇高这个形容词是针对那些错误的、自以为是的话语体系提出的，它们没有留意现实，而只是一味地陷入寻找绝对真理的桎梏中。至于这样的脱离单个的人的话语体系究竟包含何种价值观念，那是很久以后才能讨论的问题了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【一】反思人自身</title>
    <link href="/2021/03/07/%E3%80%90%E4%B8%80%E3%80%91%E5%8F%8D%E6%80%9D%E4%BA%BA%E8%87%AA%E8%BA%AB/"/>
    <url>/2021/03/07/%E3%80%90%E4%B8%80%E3%80%91%E5%8F%8D%E6%80%9D%E4%BA%BA%E8%87%AA%E8%BA%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="其一"><a href="#其一" class="headerlink" title="其一"></a>其一</h2><p>许多哲学思想都在就解决一个终极问题：人存在的意义是什么？又或者，我们希望有一个规则来告诉自己，我在有限的人生中究竟应该追寻什么？但这个问题是不存在答案的。就像在询问可观测的宇宙之外是否有一个巨大的笼子，没有人可以与这个笼子产生直接或间接的相互作用，它是隐形的存在，任何研究它的理论都与熟悉的世界没有任何关联。人生的意义就是这样的笼子，人们研究它，却并不在乎它的形状、样子、性质，而只在乎它的存在与否，这是因为我们要消灭自身在所处的社会中产生的认知矛盾，这些矛盾在各种作用后被我们自己转化为可以通过逻辑表达的一个问题。一旦解决这个问题，就会有其他的问题继续浮现，就像曾经太阳被看作围绕地球旋转，这种地球中心论被赋予一种神圣的超越世俗的意义一样。</p><p>人们提出关于这个脱离认知存在的笼子的问题，它需要被解决的实际的形式并不是问题本身，而是提出问题的动机，和透过这一动机所观测到的，人自身的矛盾本身。这并不是在规避这个形式上的问题的解答，而是从中还原出有意义的信息。一个脱离认知存在的问题既然可以在已知的思维中出现，必然有它与世俗紧密联系的交点，而这个矛盾就是交点所在，是人误以为不关心的却在实际上关心的全部。</p><h2 id="其二"><a href="#其二" class="headerlink" title="其二"></a>其二</h2><p>所有与可认知的世界不存在联系的问题，都不是真正需要研究的问题。当然，这个“可理解”的范围在未来可能会扩大，现在我们不关心太阳变为红巨星的世界会是什么样子，但倘若在未来人可以在各个时间点自由的穿梭，或者人可以保留记忆到上亿年后的世界，那么这个问题就与可认知的范围紧密联系了。但这并不表示现在我们需要研究它们，除非我们很有自信相关的技术即将被发明出来。事实上，所有那些人关心的“无意义”的问题，他们的兴趣总是要么落脚在自以为的现实的利益之上，要么是现实中某种没有被自身察觉的欲望或矛盾的体现。这种兴趣使得人们看似想解决问题，实际上是想解决与问题毫无关系的东西。</p><p>这里的论述都是针对现实中有认知意义的问题而被写下的。讨论的范围可以不是物质的作用而是人的精神，但起因在现实的人，在这个微观复杂却在宏观上各个层面都表现出可识别的相对简单的形式的神经系统。过去的理论上的社会要么被建构在逐利的理性人基础上，要么被建构在基于现实的预测模型上，或者根本没有人的存在，只有一个个执行其功能的政府机构、抽象的市场，这种脱离实际上的人存在的社会难以得出符合现实的结论。</p><p>在自然界，我们可以观察到微观上复杂的巨型系统在宏观上表现出简单易理解的性质，可以认为这种性质来源于相对简单的基本的物理规律。如果一个物体在定义中的信息量不高，那么它不可能在所有角度上观察都呈现出极其复杂的性质，必然能从一个维度进行简化。要想考察构成人的无数粒子如何相互作用，不能从物理的角度去观察粒子，也不能从生物的角度去观察单个的神经细胞，事实上我们不需要精确预测一个人下一秒会抬手还是眨眼。从更高的维度抽象出有价值的东西，并在其上做出有意义的推测，这是可行的而且有价值的。</p><h2 id="其三"><a href="#其三" class="headerlink" title="其三"></a>其三</h2><p>要讨论自由意志的界限，必定要追溯到其客观存在，一个显然的界限就是精神无法直接地改变客观世界。从现代的角度出发，自由意志的物质载体仅仅是神经元接收释放着的电信号，并不存在其他的东西。五感和身体内部的神经末梢传感器作为外部输入，但如果仅定义到负责高级思维活动的那部分，即人区别与一般动物的部分。那么人的原始欲望和生存本能也作为外部输入存在，这一划定的原则是它们不能被自由意志改变。我们无法主观地屏蔽自己的视觉或嗅觉，同样地，我们也无法拒绝感知自身的饥饿感、欢喜与沮丧。当然，对于后两种感觉，有更为复杂的作用在控制。</p><p>这样我们就将自由意志这一系统与其外部输入划清了，即将它能够控制的部分与不能控制的部分分开。严格来说，记忆也不是主观能够控制的，这样处于灰色区域的东西有许多，但总的来说，都可以归在感知现实的外部世界或感知自身的内部世界中。</p><h2 id="其四"><a href="#其四" class="headerlink" title="其四"></a>其四</h2><p>对物种本身而言，存在似乎并没有意义，但进化论从生存竞争的角度引入了基因存续的意义。这种意义并不是形而上的，它并不超越现实，对人来说，只是一种观测上的幸存者偏差。因此不难观察到逐渐演变的现实中有反自我存在的个体或事件发生。即使对于最正常的个体而言，他身上的性状也只是“恰好”显得能促进基因留存而已。在这个方面，有些观点从种群的延续出发，指出个体的延续无关紧要，种群才是基因延续的主体。这种变化使得人的社会需要成为必然。</p><p>理论上，在自然选择的压力下，人保留下的各种性状可以看作种群延续在诸多现实的物理限制下的产物。自从人智慧的生理基础，即现代人的大脑结构出现后，在这一结构所能控制的范围内，生存策略的演化不再受限于DNA所依托的稳定化学结构，而可以进行极其迅速的调整和变化，演进的速度由此急速增长。这些事实看似没有什么值得注意的地方，但事实上有2个容易被忽略的议题：自由意志作为个体生存的工具产生，它是否拥有“自由”？现代社会迅速的发展，人所处的环境的改变速度极大快于原始的基因改变的速度，这种量的积累是否会带来隐藏的矛盾？</p><h1 id="其五"><a href="#其五" class="headerlink" title="其五"></a>其五</h1><p>对前一个问题，回答是否定的。个体的自由意志自脑在物理上近似无穷的可塑性产生，但也受到脑这一环境的限制。它时刻受到原始情感的驱动和限制，这种驱动是强制的。用神经网络的模型来说，外部感官输入经过比较低级脑区的初步理解，得到一系列输入，这种输入传递给负责原始情感的部分，向新皮层作出调控，通过释放兴奋性或抑制性神经递质的方式。人的高级思维共享低级脑区的输出，本身是可塑的部分，输出作用于外部环境，在下一时刻又被外部环境输入。为了让功能强大的新皮层为生物繁衍所用，奖惩规则由较可靠也较古板的哺乳脑和爬行脑控制。所谓的自由意志不仅自身局限于狭小的头骨腔中，还每时每刻都被迫改变自己以适应陈旧的上一代控制系统的无理要求。即使环境不改变，成年人依旧会受到年幼的自己积累的情感经验的影响，更不需要讨论物质极大丰富的当代，教育的反天性化与资本的反人性化。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>毛选第一卷笔记</title>
    <link href="/2021/03/07/%E6%AF%9B%E9%80%89%E7%AC%AC%E4%B8%80%E5%8D%B7%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/03/07/%E6%AF%9B%E9%80%89%E7%AC%AC%E4%B8%80%E5%8D%B7%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="实践论与矛盾论"><a href="#实践论与矛盾论" class="headerlink" title="实践论与矛盾论"></a>实践论与矛盾论</h1><blockquote><p>感觉到了的东西，我们不能立刻理解它，只有理解了的东西才更深刻地感觉它。</p></blockquote><p>毛在这一段主要论述的是认识不能脱离实践，但也应该纠正相反的理解。认识虽然不能脱离实践，但不一定必须由直接的感觉得到。比如数学家理解公式定理，虽然这些数学公式都是摸不着的概念，但他们确实可以去实践，并理解。再看一些空想的东西，人沉迷虚拟世界的游戏，即使这些虚拟的东西是摸不着的，但依然有实践，即是说，幻想的东西和真实的东西并无本质差别，人在它们中实践时，也会被它们改造，进而将人的一部分融入其中。</p><p>从这点看，上山下乡有坏处。人被一种强制的力统治了，人与其说是农村、农民打交道，不如说是以这股力打交道，久而久之，人被这股强制力塑造成扭曲的东西，若人性认为它是错的，那么必然反人性才会认为它是对的。长久地剥夺人最基本的自由，会产生长久的不良影响。</p><blockquote><p>固然，如果不认识矛盾的普遍性，就无从发现事物运动发展的普遍的原因或普遍的根据；但是，如果不研究矛盾的特殊性，就无从确定一事物不同于他事物的特殊的本质，就无从发现事物运动发展的特殊的原因，或特殊的根据，也就无从辨别事物，无从区分科学研究的领域。</p></blockquote><p>如果以物理定律或是机械的方式认识世界，那么对于这个庞大的、混沌的系统，有太多因素互相影响了。然而用矛盾的方式去理解社会，就可以在各个层次抽象出简单的规律，有理由相信复杂系统的演化动力可以是简单的、易于理解的。从实践的角度来看，认清矛盾就将事物发展的影响同它们发展的动力剥离开，确实有助于解决问题。</p><p><strong>矛盾的特殊性代表了不同事物的区别</strong>，不同事物有不同的矛盾，这反映了它们本质之间的不同。</p><blockquote><p>一方面，不懂得必须研究矛盾的特殊性，认识各别事物的特殊的本质，才有可能充分地认识矛盾的普遍性，充分地认识诸种事物的共同的本质；另一方面，不懂得在我们认识了事物的共同的本质以后，还必须继续研究那些尚未深入地研究过的或者新冒出来的具体的事物。</p></blockquote><p><strong>矛盾的一般性是总结了特殊性才能理解的，同时在了解一般性后才能更好把握特殊的矛盾</strong>，两者相互促进。学习中，即使背诵了一般性的解题技巧也无法在具体问题中灵活运用，而只有在了解大部分问题后，总结出一般技巧，这个总结的过程才是进步的过程，甚至不在于是否记下来。</p><blockquote><p>用不同的方法去解决不同的矛盾，这是马克思列宁主义者必须严格地遵守的一个原则。</p></blockquote><p>至少这指出了追寻纯粹的“一般性”的框架是错误的道路，这也不是说一般性的框架不存在，越是一般性的框架就越模糊，一般性和细化这一对特征是无法共同存在的。</p><blockquote><p>一切矛盾着的东西，互相联系着，不但在一定条件之下共处于一个统一体中，而且在一定条件之下互相转化，这就是矛盾的同一性的全部意义。</p></blockquote><blockquote><p>当着我们研究矛盾的普遍性和斗争性的时候，要注意矛盾的各种不同的斗争形式的区别。</p></blockquote><p>在大范围来看，人会死亡、恒星会消亡、物种会灭绝、地貌会变化，但在一两天来看，人是稳定存在的，恒星也是稳定存在的，此时这些大范围的矛盾（比如地貌变迁）就会近似地静止下来，但其实没有静止。极小范围内，比如个人与个人的矛盾相对于整个社会，也是静止的，它们通过大量重复的实验从偶然的东西变成概率下稳定的东西，成为一种现象，也是静止的。</p><p>从不同层面观察，不同的矛盾有固定的影响范围，但也有影响范围极大的，比如古代帝王能影响整个国家。这种实际上会将个体的不稳定因素放大到国家，例如君王个人能力的强弱、早夭、谋杀等等，更重要的是君王维护权贵阶级的利益，与广大百姓的利益有根本的矛盾。而看似古代王朝都持续比较长久，这是长期礼法教化、一套完整的官僚系统保驾护航的结果。</p><h1 id="湖南农民运动考察报告"><a href="#湖南农民运动考察报告" class="headerlink" title="湖南农民运动考察报告"></a>湖南农民运动考察报告</h1><p>农民运动推翻了地主劣绅，固然是一件好事。但农会之所以能摆脱千百年来土地兼并的规律，这是依托于革命的。如何保证农会不会成为新的食利阶级？农民出身能保证短时间的先进性，但长时间来看，需要一种强制性力量，这种力量不能是制度，因为制度是死的，在约束的时候也只是一批人利用制度的帽子去打压另一批人，势必造成力量的分裂。用思想来约束人，这个思想一定要与现实相适应，即思想贴合个人的需求。</p><p>私以为人为制定的东西没有能够约束人本身的力量。相反，科技和客观条件可以无代价地改变整个社会，倘若未来机械极大地丰富了生产力，这时人与人的力量均衡就被打破了。到时候，问题就在于谁拥有对如此巨大生产力的掌控权。显然每个人的掌握权是不一样的，技术工程师和资本家比普通人的掌控权大得多。届时，寡头企业的现象也会增多，因为机器带来的凝聚力使得分裂的力量减弱了，垄断适合大工业生产。相比一个国家，机器无所谓剥削和权力的集中，就如一个内部空前团结的国家，这样的国家可以无限的扩展下去，直到掌控者的能力的最大限度为止。</p><p>就像农民会自发地推翻地主一样，阶层之间相对的稳定只依赖于各自力量的对比，如果农民的力量弱了，无论地主善恶，总是会发生地主侵害农民利益的事件出现。在分析的时候，只要看各自背后的实际力量强弱，就可以得到结论了。</p><p>当食利阶级不依靠广大被统治的阶级生存时，会发生什么？这是个需要仔细分析的问题。</p><h1 id="没有调查就没有发言权"><a href="#没有调查就没有发言权" class="headerlink" title="没有调查就没有发言权"></a>没有调查就没有发言权</h1><p>这个观点不是提出一个制度，而是给出一个规律。对于社会中的问题，如果没有调查，就无法掌握特定问题的相关信息，也就无法指定合适的方案点对点地解决问题。</p><p>然而在生活中，人倾向于用头脑中已知的信息来判断，这就脱离了实践。这种重视实践的态度不是与生俱来的，而是需要刻意培养的。</p><p>毛泽东调查社会的主要对象是阶级，调查有哪些阶级、阶级的力量对比、阶级之间的矛盾关系等。核心是明确哪些阶级是该团结的对象，而哪些是该攻击的对象。</p><h3 id="一些个人见解"><a href="#一些个人见解" class="headerlink" title="一些个人见解"></a>一些个人见解</h3><p>所有斗争都是基于一些共同利益上的，一部分人因为有共同利益而结成团体，在斗争的过程中不可避免地会损害到另一部分人的利益。在土地革命这件事上，农民得到了土地，解放了劳动力，生产的粮食会比原来的还要多，这多出来的粮食和打土豪分来的粮食就是农民得到的利益。总的来说，这种革命让蛋糕变大了，而且分割得更加均匀了。</p><p>但是多出来的蛋糕是从哪来的？是从农民自己做土地的主人后，劳动积极性提升得来的。在现代社会，个体小作坊生产远比不上社会工程化大生产的效率。劳动积极性要求公平，而工业化生产要求分工，有了分工就有了利益分配不均，工业化的分工本质上是打消劳动积极性的，注定有人得不到自己应得的薪水。</p><p>现在，为了进一步经济建设，就必须拥抱工业化生产，拥抱科技发展。在科技发展相对停滞的当前，效率与公平的矛盾已经逐渐严重了。当下的社会已经不具备同时发展公平与效率的条件，而必须在两者中进行权衡。</p><p>土地兼并是几百年来逐渐形成的，需要注意，政策对公平的影响不是立刻作用，而是有不断累积的过程。自改革开放以来，财富的积累通过代际传承，一代一代地增长，社会上的不公平也一代一代地逐渐加深。当政策倾向于效率时，它会在一定的时间内激活生产力，而随着时间增长，效率加深了不公平的程度，最终社会上不公平对效率的抑制力胜过竞争的积极性，倘若政策不进行及时的调整，经济活力就会再度下降。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>风格转换和特征一致化</title>
    <link href="/2021/03/07/%E9%A3%8E%E6%A0%BC%E8%BD%AC%E6%8D%A2%E5%92%8C%E7%89%B9%E5%BE%81%E4%B8%80%E8%87%B4%E5%8C%96/"/>
    <url>/2021/03/07/%E9%A3%8E%E6%A0%BC%E8%BD%AC%E6%8D%A2%E5%92%8C%E7%89%B9%E5%BE%81%E4%B8%80%E8%87%B4%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="内容保持"><a href="#内容保持" class="headerlink" title="内容保持"></a>内容保持</h1><p>文章：J. Johnson, A. Alahi, and L. Fei-Fei. Perceptual losses forreal-time style transfer and super-resolution. In Europeanconference on computer vision, pages 694–711. Springer,2016</p><h2 id="内容的量化"><a href="#内容的量化" class="headerlink" title="内容的量化"></a>内容的量化</h2><p>显然人是无法手工设计特征来量化图像内容的，对内容的量化利用了CNN的性质。CNN较浅层的感受域只有一小部分，所以输出中不含内容，主要是纹理，较深层无法直接感受纹理，所以输出中大多数内容，这样就可以分别提取浅层和深层的输出，做到保持内容的一致</p><h2 id="内容保持-1"><a href="#内容保持-1" class="headerlink" title="内容保持"></a>内容保持</h2><p>当提取了CNN深层的输出时，就可以反过来训练数据，这时网络本身是训练好的，权值不变，输入的数据改变，<strong>也就是利用权值更新数据</strong>，收敛到每一个极值点就是相同内容在每一个风格下的体现。</p><h1 id="风格迁移"><a href="#风格迁移" class="headerlink" title="风格迁移"></a>风格迁移</h1><h2 id="风格的量化"><a href="#风格的量化" class="headerlink" title="风格的量化"></a>风格的量化</h2><p>风格提取的是纹理，但是为了让纹理更加平滑，实际上提取的是每一层的第一小层的输出，就从整体上把握纹理特征。</p><p>风格量化采用Gram矩阵，先得到矩阵，然后计算均方误差，再对每一层的结果相加，就得到loss。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>超分辨率重建</title>
    <link href="/2021/03/07/%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87%E9%87%8D%E5%BB%BA/"/>
    <url>/2021/03/07/%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87%E9%87%8D%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="图像超分辨率重建"><a href="#图像超分辨率重建" class="headerlink" title="图像超分辨率重建"></a>图像超分辨率重建</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>图像重建_PI-REC</title>
    <link href="/2021/03/07/%E5%9B%BE%E5%83%8F%E9%87%8D%E5%BB%BA_PI-REC/"/>
    <url>/2021/03/07/%E5%9B%BE%E5%83%8F%E9%87%8D%E5%BB%BA_PI-REC/</url>
    
    <content type="html"><![CDATA[<h1 id="PI-REC-渐进式图像重建方法"><a href="#PI-REC-渐进式图像重建方法" class="headerlink" title="PI-REC: 渐进式图像重建方法"></a>PI-REC: 渐进式图像重建方法</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>从稀疏的边输入中重建：即自动根据手绘草稿补充细节得到线稿</li><li>从较少的色块中重建：自动丰富细化局部的细节和颜色</li></ol><h2 id="前置知识：GAN训练原理"><a href="#前置知识：GAN训练原理" class="headerlink" title="前置知识：GAN训练原理"></a>前置知识：GAN训练原理</h2><h2 id="PI-REC原理"><a href="#PI-REC原理" class="headerlink" title="PI-REC原理"></a>PI-REC原理</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>总的来说有三个步骤：网络初始化-重建-细化。输入是草图和色块，其中草图用<strong>Canny算法</strong>从原图中提取，色块用<strong>K聚类</strong>提取主颜色，然后用<strong>中值滤波</strong>将边界变得平滑模糊。</p><p>在提取草图和色块的时候，各种算法需要一些超参数来控制程度，文章中的HC指的是在生成训练集时，随机生成超参数来避免网络对单一参数的过拟合。</p><p>棋盘效应：使用反卷积操作生成高分辨率图像时，若卷积核不能被步长整除，就会出现棋盘效应。解决方法时用插值调整原图像大小（？），再在调整后的图像上卷积</p><h3 id="loss设计"><a href="#loss设计" class="headerlink" title="loss设计"></a>loss设计</h3><p>从GAN原理可以知道loss是传导信息中至关重要的部分，事实上loss包含的信息就蕴含了对神经网络的期望。PI-REC的loss（下面的是生成器的loss）设计是多种信息的线性组合。</p><p><strong>每个像素点的误差</strong></p><img src="/2021/03/07/%E5%9B%BE%E5%83%8F%E9%87%8D%E5%BB%BA_PI-REC/2021-01-22-13-26-06.png" srcset="/img/loading.gif" class=""><p>L1范数：矩阵每个元素绝对值之和，对于蒙版后的图像来说，$X_{fake}-M*X_{gt}$只比较自动生成部分的好坏，原本的部分已经被相减操作去除了。而自动生成部分的面积即蒙版的大小，相除得到蒙版每个像素的平均偏差，再乘以$X_{gt}$的大小，使得生成的loss不随蒙版大小变化，但是随输入图片的大小变化</p><p><strong>对抗形成的误差</strong></p><p>采用LSGAN训练，但这里也许用WGAN效果会更好</p><p><strong>特征和风格</strong></p><p>原文是feature loss，这首先要理解feature map. feature map指卷积层的输出。文章中用VGG-19的前5层的loss相加，每层的loss又是将样本送入卷积层中得到的feature map相减的。</p><img src="/2021/03/07/%E5%9B%BE%E5%83%8F%E9%87%8D%E5%BB%BA_PI-REC/2021-01-24-14-21-50.png" srcset="/img/loading.gif" class=""><p>直观的理解就是说，$X_{fake}$不仅在像素层面上要逼真，而且在提取了特征以后，这个特征也要逼真，这就保证不会出现一些线条混乱的情况。</p><p>风格见相关blog</p><p>注意这里的loss是给G迭代用的，每次生成了假图片以后，就得到一个风格与特征相关的loss，然后对其进行改进，<strong>使得还原后的风格与原图的风格尽可能一致，特征也尽可能一致且连续</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GAN原理及衍生</title>
    <link href="/2021/03/07/GAN%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A1%8D%E7%94%9F/"/>
    <url>/2021/03/07/GAN%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A1%8D%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="传统GAN"><a href="#传统GAN" class="headerlink" title="传统GAN"></a>传统GAN</h1><h2 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h2><p>首先有2个网络，生成网络G输入噪声，输出逼真的图像，判别网络D输入图像，输出推测的真假值（0-1）</p><p>先找来一堆目标图像，然后随意初始化G，输入噪声，输出一堆模仿的图像，然后将模仿的图像标记为0，将真图像标记为1，输入到判别网络D中训练</p><p>训练后，判别网络D能成功地区分现在的网络G生成的假图像，然后将D连在G后面，形成新的网络Z，Z网络输入是噪声，输出是真假值。接着对网络Z训练：输入随机噪声，然后将标签设置为1，这样得到的误差反向传播到G网络部分时，就是每个像素点相对于“D网络认为的真实图像的差距”，就可以用来改进G网络，此时D网络的权重不会变化。</p><p>每轮训练时，只有在D网络学习到能分辨真假时才具有超越G网络的水平，此时G网络才能借由Z网络学习到D网络中新的知识。若D网络在给定真假图片时完全无法区分它们了，反映到训练时的情况就是：无论给出的图片是真还是假，D网络输出都接近0.5，每次更新权重时的起始误差都是1-0.5=0.5，且随着训练轮数变多，这个误差还是无法降低到0.5以下。</p><h2 id="理论推导"><a href="#理论推导" class="headerlink" title="理论推导"></a>理论推导</h2><p><strong>KL距离</strong></p><p>KL距离表示两个概率分布间的差异，体现为用一个概率分布去描述另一个概率分布所增加的比特数。</p><img src="/2021/03/07/GAN%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A1%8D%E7%94%9F/2021-01-24-09-36-31.png" srcset="/img/loading.gif" class=""><p>对离散数据，代入每个x得到分布中的概率，然后求和即可。这个距离可以判断分布的差异，分布差异越大，KL距离就越大，从KL距离来看，对最优化目标公式V的概括描述就是：在对数下，让D(x)的概率分布更加接近data的分布，远离G的分布</p><p><strong>分布与最优化</strong></p><p>若给定一组真实数据，我们希望网络能学习到这些数据中像素的分布（在一个高维空间上的分布，比如说，所有猫的图片都可以被映射到区域X上，要学习的就是这个高维区域X）。倘若能得到这个分布，就可以随意提取一张分布中的图片（向量），来表达训练数据以外的图片。但现实中无法得到真正的X，因为手工描述太过复杂。所以在X中选取一堆数据，也就是训练用的图片，<strong>近似以这组图片的分布作为真实数据的分布</strong>，对于待训练的网络G，以其在高斯分布噪声下的输出分布作为其学到的分布。相当于网络G将高斯分布映射到理想的分布X上</p><p>GAN最优化的目标公式：</p><img src="/2021/03/07/GAN%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A1%8D%E7%94%9F/2021-01-24-09-55-13.png" srcset="/img/loading.gif" class=""><img src="/2021/03/07/GAN%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A1%8D%E7%94%9F/2021-01-24-09-55-29.png" srcset="/img/loading.gif" class=""><p>直观地理解，先假设$P_G$和$P_{data}$之间的共有区域测度为0（就是几乎不重合），此时对于来自真实数据data中的x，若判别器D是理想的，那么总是会输出D(X)=1，对于来自虚假数据g中的x，输出D(X)=0，显然这样一来，对于data中的数据，输出期望取对数就是0，对于g中的数据，输出期望在该公式下也是0，这就达到了V的最大值。</p><p>当生成器愈发接近真实数据的分布时，判别器不可能给出明确的0和1了。假设生成器是完美的，不难得出此时判别器的输出只能是各为0.5，才能达到V的最大值。</p><p>整个训练流程相当于求G和D两个“维度”下V的最优化参数（实际上G和D各自都包含了若干个维度的参数），类比于二维优化的梯度下降法，交替训练只不过是每次在单独的“维度”上进行梯度下降而已</p><p>训练开始时，D很容易区分G和真实的图片，很快就能收敛到0，到最后，D无法区分，此时V的输出接近-2log2</p><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><img src="/2021/03/07/GAN%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A1%8D%E7%94%9F/2021-01-24-10-15-52.png" srcset="/img/loading.gif" class=""><p>以下讨论仅针对一轮（iteration）训练：</p><p>首先选取m个样本，这些样本显然来自于期望学到的分布$P_{data}$的，然后选取m个噪声，这些噪声来自于一个随意指定的分布$P_{prior}$，不妨用高斯分布。</p><p>然后用噪声来得到生成器的输出G，接着将真实数据和噪声数据组成m对，放入判别器D中，计算出V，由V的梯度得到误差，用来更新判别器的网络（注意，V至少只有一个最大值，也许具有某些凸的性质让收敛比较容易）</p><p>在判别器训练到收敛后，再用D来训练G。选取m个在prior中的样本，将这些样本依次经过G和D，用V更新g参数。</p><p>注意，在生成器训练的环节，生成器只需要尽可能接近判别器就好了，所以只有一项，而图片中依然用log，然后在学习率前加负号，这种方式使得D的输出默认依然是1，然而由于log的性质，当训练到接近成功的时候，梯度会被放大，从而加快了收敛速度。</p><p><strong>训练中注意的问题</strong></p><p>虽然G的输入是噪声，但噪声也要符合prior的分布，因为网络是将分布映射到分布，所以分布本身也是一个信息。</p><p>对D的训练中，每次最大似然的参考分布就是m个数据的分布，对于越复杂的物体，m应该越大，这样才能较完整地描述物体的性质。而且，对越复杂的物体，采样的prior的维度也应该越大，<strong>这是因为G将采样的分布映射到高维分布，若采样分布维度太少，那么映射出来的分布在高维空间中仍然是低维的，不一定能覆盖真实数据的维度</strong></p><p>由最优化目标可知，找到的最优点并不是极点，而是鞍点：</p><img src="/2021/03/07/GAN%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A1%8D%E7%94%9F/2021-01-24-10-56-55.png" srcset="/img/loading.gif" class=""><p>在早期的时候min(log(1-D))存在梯度消失问题，改成max(log(D))会有改善（选取其他非线性的函数？）</p><p>高斯分布的噪声比均匀分布的噪声要好，因为均匀分布实际上是一个正方体的样子，正方形相对于圆更难被映射到复杂图像上</p><p>实践中，ReLU和MaxPool这种稀疏梯度效果差，这些方法只注意主要部分忽略次要部分，使得每次训练犹如盲人摸象一般，很难挖掘出共同点。</p><p>使用软标签：把1和0泛化为0.7-1的随机数和0.3-0的随机数，猜想目的应该是让分布尽可能重合得比较好</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>GAN之前的生成模型，如VAE，直接用输出图像像素的均方差作为误差，这种图像误差计算方式是不合理的。而GAN相对于这种手工判别的方式，采用神经网络来生成和分配误差，显然比人手工设定有优越性。</p><p>V的函数是有缺陷的：初始状态，D很容易收敛，但对G提供的信息太少，最终状态，D不容易收敛，且对G提供的信息还是太少。这个问题在WGAN得以解决。</p><p>GAN本身并没有风格单一化的问题，这是因为倘若学习到的分布不能覆盖真实分布，那么训练时输出误差就是无穷大，但虽然GAN能覆盖到目标分布，不代表GAN的映射中，各风格是均匀的。</p><h1 id="GAN衍生"><a href="#GAN衍生" class="headerlink" title="GAN衍生"></a>GAN衍生</h1><p><strong>CGAN</strong></p><p>CGAN解决了用一个GAN生成不同风格的图像，方法是将风格作为一个（或若干个）新的维度，并在噪声输入中，但这种情况下的真实图片也得按照风格分类，就是打tag了的，</p><p><strong>PatchGAN</strong></p><p>PatchGAN的输出不是概率数，而是一个概率矩阵，每个元素表示它所观测的范围的真假程度。只要对原始的图像经过多层卷积，就能得到所要的概率矩阵。每次判断时，可以精细地比较局部的判断结果与真实值的误差，从而得到更合理的误差。</p><p>通俗来说，原始的GAN是指出整幅画的好坏，而PatchGAN分别指出一副画各个部分的好坏，从而可以更详细地改进</p><p>从GAN的训练原理可以看出，真正有用的信息包含在误差的计算中，只有得到有效的误差才能继续训练神经网络。</p><p><strong>LSGAN（最小二乘GAN）</strong></p><p>传统GAN最后一层用sigmoid归一化到0-1的概率，对sigmoid来说，原始输入的x一旦脱离了sigmoid线性区，那么将很难辨别出来。然而实际上那些远离的x大概率是非正常的图片，此时sigmoid无法将其区分开。</p><p>LSGAN去掉了sigmoid函数，且去掉了交叉熵，用最小二乘的形式代替，从而使得原始输出也在0-1的合理区间。</p><img src="/2021/03/07/GAN%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A1%8D%E7%94%9F/2021-01-24-11-44-55.png" srcset="/img/loading.gif" class=""><p>LSGAN改进了生成图片质量和稳定性，但无法避免WGAN中的零测集问题，且LSGAN引入了风格单一化的问题</p><h2 id="WGAN"><a href="#WGAN" class="headerlink" title="WGAN"></a>WGAN</h2><p><strong>传统GAN的问题</strong></p><p>GAN的两个loss都是局部的，而没有一个全局的loss进行训练情况的指示，也就无法量化生成图片好坏。而且，传统GAN有模式崩坏的问题，生成图片缺乏多样性（实质上是映射的程度不一致）</p><p>观察G的最优化目标：</p><img src="/2021/03/07/GAN%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A1%8D%E7%94%9F/2021-01-24-12-09-29.png" srcset="/img/loading.gif" class=""><p>假设D已经能完全区分G和真实数据，那么代入上述公式，D(G(z))一定为0，得到的误差就是0，从而产生梯度消失问题。直观地说，若G的分布与真实分布相差极大，那么D即使把他们分割开了，也不能给G提供什么有效信息，只是告诉G“你们之间完全没有交集”，从而使得G无法继续学习。</p><p>假设D训练得不好，此时给出的梯度是不准确的，因为D本身也不包含多少信息，而且有相等的噪声，此时生成器也得到了无效数据。</p><p>总之，G训练得太好太差都无法产生作用。</p><p>另外，原始GAN中-log D trick尽管改善了训练速度，但是这等价于：</p><img src="/2021/03/07/GAN%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A1%8D%E7%94%9F/2021-01-24-12-21-58.png" srcset="/img/loading.gif" class=""><p>KL散度和JS散度都代表了分布的距离，但它们在同一优化目标下的方向是相反的，这就使得训练不稳定，而且此时的KL散度不是原本的那个KL散度，观测角度不同会导致多样性缺乏（直观地说，从A看B，发现自己已经全部覆盖B了，但是从B看A，A并没有全部覆盖B，现实中，我们希望D分布全部覆盖真实分布，但不希望D分布只覆盖一部分真实分布）</p><p><strong>Earth-Mover距离</strong></p><p>也叫W距离。对于真实分布r和生成器分布g，力图将g中的图片作尽可能微小的改动使得其可以与r重合，这些微小改动的总和就是W距离。</p><p>但这种距离无法直接求解，通过一些定理，可以将其变换为：</p><img src="/2021/03/07/GAN%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A1%8D%E7%94%9F/2021-01-24-12-33-38.png" srcset="/img/loading.gif" class=""><p>其中K是Lipschitz常数，K是函数的导数的上界。实际上，只要保证网络f的各个权重在一个范围内，那么叠加后的输出必然有一个导数上界，所以事实上这个K只改变绝对量而不改变相对量，是可以去掉的。</p><p>于是优化目标为让L最大：</p><img src="/2021/03/07/GAN%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A1%8D%E7%94%9F/2021-01-24-13-23-30.png" srcset="/img/loading.gif" class=""><p>这个L就可以定义为loss，L越大，两者的区分度就越大，L越小，分布的距离就越小。这个L就可以指示训练的进度</p><p><strong>WGAN</strong></p><p>WGAN改动有4点：</p><ol><li>判别器最后一层去掉sigmoid</li><li>生成器和判别器的loss不取log</li><li>每次更新判别器的参数之后把它们的绝对值截断到不超过一个固定常数c</li><li>不要用基于动量的优化算法（包括momentum和Adam），推荐RMSProp，SGD也行</li></ol><p>第一点是由于WGAN不是二分类问题，所以不需要sigmoid，第二点是W距离的本质改动。第三点是K的限制。第四点是实践技巧，没啥理论依据。</p><p>对判别器而言，要使</p><img src="/2021/03/07/GAN%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A1%8D%E7%94%9F/2021-01-24-13-43-03.png" srcset="/img/loading.gif" class=""><p>最大，即利用网络的拟合能力来找到取得上界的f。</p><p>对生成器而言，要使得：</p><img src="/2021/03/07/GAN%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A1%8D%E7%94%9F/2021-01-24-13-44-34.png" srcset="/img/loading.gif" class=""><p>最小，因为这个地方只有生成器的权重变化，所以实际上也就是要W距离最小</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>从WGAN可以看出，loss函数的性质是非常重要的，loss函数的零点是比较重要的，那么loss的曲率是否对网络训练有影响？显然像x^2和atan(x)这种都会有梯度消散问题，那e^x是否可以？若将sigmoid(kx)中的k设置为足够小是否也可以呢？</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>原子化的社会</title>
    <link href="/2021/03/07/%E5%8E%9F%E5%AD%90%E5%8C%96%E7%9A%84%E7%A4%BE%E4%BC%9A/"/>
    <url>/2021/03/07/%E5%8E%9F%E5%AD%90%E5%8C%96%E7%9A%84%E7%A4%BE%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="原子化的社会"><a href="#原子化的社会" class="headerlink" title="原子化的社会"></a>原子化的社会</h1><p>前几天看到一段视频，主要的观点是：现在的青年人，要么关心自己的未来，要么关心国家和世界上的大事，而缺乏“附近”的存在，于是，原本由附近连接的社交网络在逐渐崩塌，只剩下一个个原子化的个体。</p><p>这个观点给了我一些启发，但要完全分析这件事，就不得不从经济基础、科技基础上寻找更本质的东西。</p><h2 id="生活水平与社会关系网"><a href="#生活水平与社会关系网" class="headerlink" title="生活水平与社会关系网"></a>生活水平与社会关系网</h2><p>随着生活水平的提高，人们的社会关系网也会变化，这有两个趋势：</p><p>工业化大生产让人得以脱离附近而存在。工业大生产让一个人不需要融入群体也可以自力更生，客观上为社会原子化提供条件。而原本维系“附近”的存在，即一个小团体，却因此缺少了交流的可能性。原本邻里为了生活互相帮扶，也就多了一层社交关系，而现在每个小团体之间都没有交流的必要条件，光靠地缘关系带来的交流的便捷性是不足以提供构筑关系网的动力的。</p><p>然而，工业化大生产让人多出了很多可以用来社交的时间。以前的人们为了经营，在维持生活这个方面花去了大部分时间，而现在，大部分人都脱离耕作存在，即使减去工作的时间，每天也有很多时间用来社交娱乐。这让人社交的动力变大了，原本狭小的邻里关系，已经承载不了如此多的社交流量。</p><h2 id="社会关系中的博弈"><a href="#社会关系中的博弈" class="headerlink" title="社会关系中的博弈"></a>社会关系中的博弈</h2><p>对一个人而言，与邻里相处不好，会带来负面效益；相处得好，也不一定能带来正面效益。也就是说社交是有风险的，而规避社交确是无风险的。在这种明确的规则下，越来越多的人选择网络社交，为的就是可以自由地断绝关系，规避风险，而网络社交也足以承担较大的社交流量，较大地满足人的日常需求。</p><p>对个人而言，工业化生产保障了人的物质存在，人因此就超越物质了，变成了精神上的“人”。这个趋势在未来不会改变，人的精神需求成为了主要的需求，而物质被抛在后面了。对物质丰富的现代社会，<strong>人较少感受到物质匮乏的存在，因此物质变得透明了，就像为建筑物遮挡风雨的玻璃一样，即使发挥了关键作用，也极少进入人的视野</strong>，要理解社会的变化，就应当从人的变化入手。</p><p>假想地来说，一群人在一块，每个人都有与他人交流的机会，不妨给每个人定义一个满意度A，若在交流中攻击他人，则自己和对方的满意度都会下降，若在交流中维护他人，则自己的满意度下降，对方的满意度上升。若不交流，则随着时间的流逝，自己的满意度也会下降。</p><h2 id="脱离物质的人"><a href="#脱离物质的人" class="headerlink" title="脱离物质的人"></a>脱离物质的人</h2><p>人脱离物质以后，最核心的问题就是：谁能定义自己？过去，物质生活占了人生活的绝大部分，但现在，在一片空旷的精神世界中，何种力量能够定义人的精神？我认为这要由人所处的“精神环境”来决定。</p><p>相对物质而言，精神的“食粮”是情感，<strong>而情感必然是寓居在物质上的</strong>。人看到绝美的风景会感到快乐，听到优美的曲子会快乐，通过五官来感受，这种传递必须是近距离的、面对面的。在一次团体活动上体会到快乐，人必然是亲自参加这项活动的，如果只是靠视频的形式“云娱乐”，那也是借助图像来想象。倘若从来没看过或者从来没听过，是无法想象出进行这项活动的情感的。</p><p>因此，现代人的生活，很大程度上是精神需要与物质载体脱离了的生活。脱离了物质生产以后，广泛的精神需求找不到物质承载的载体，进一步地，有限的资源不能满足近乎无限的需求，这是典型的资源短缺下的困境。缺乏粮食的国家会发生战乱，相同地，稀缺的精神资源一定会带来斗争。物质上的丰富确保了大多数人能够存在下去，但精神上的匮乏让大多数人都一定会参与斗争，即争取精神的物质载体。</p><p>这些物质载体并不是人，而是能够与别人“发生关系”的事物，也就是能承载情感价值的事物。财富是这样的东西，它能创造出新的连接，权力和地位也是如此。广泛地说，一切能够创造交流欲望的现实事物，都有其作为精神的物质载体的价值。如一款游戏、一个话题、一部电影。但需要注意，只有在人的关注下，这些物品才会成为载体，而没有关注的物品，只有本身作为物品的价值而已。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【随笔】自尊的内在和外在</title>
    <link href="/2021/03/07/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E8%87%AA%E5%B0%8A%E7%9A%84%E5%86%85%E5%9C%A8%E5%92%8C%E5%A4%96%E5%9C%A8/"/>
    <url>/2021/03/07/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E8%87%AA%E5%B0%8A%E7%9A%84%E5%86%85%E5%9C%A8%E5%92%8C%E5%A4%96%E5%9C%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="自尊的内在和外在"><a href="#自尊的内在和外在" class="headerlink" title="自尊的内在和外在"></a>自尊的内在和外在</h1><p>一个问题：人应当以基于解释自身经历的内在的道德标准衡量自己，还是以基于客观效用的外在道德标准衡量自己。前者追求自我平衡，后者追求外界的正向刺激。</p><p>道德标准，应当是一种人所主动选取的，用于解释正面和负面生理情感的产物。对人本身而言，由多巴胺和诸多神经递质、奖励系统组成的生理情感是有绝对的正面和负面之分，而未有先验解释的世界并没有这种绝对性，两者产生了矛盾，这使得道德标准这一能够赋予意义的工具成为对人的认知而言必要的东西。</p><p>这种缓解矛盾的工具，很大程度上已经先天地决定了。比如对疼痛的恐惧、对群体的需要、好奇和成就感等。这些是人在原始社会中能够生存下来所保留在基因里的知识，对人来说，是先验的知识。现代社会迅速发展，人的生理构成与现实之间的同步丧失了。内生的道德标准不再适用于快速发展的社会。仅靠自然生长而得来的道德观念不再适用，先天的矛盾需要后天的行动、思考来弥补。</p><p>任何一套价值体系、道德标准，应当同时满足先天和后天自恰的需要。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【生活】蛙泳：从喝水到呛水</title>
    <link href="/2021/03/02/%E3%80%90%E7%94%9F%E6%B4%BB%E3%80%91%E8%9B%99%E6%B3%B3%EF%BC%9A%E4%BB%8E%E5%96%9D%E6%B0%B4%E5%88%B0%E5%91%9B%E6%B0%B4/"/>
    <url>/2021/03/02/%E3%80%90%E7%94%9F%E6%B4%BB%E3%80%91%E8%9B%99%E6%B3%B3%EF%BC%9A%E4%BB%8E%E5%96%9D%E6%B0%B4%E5%88%B0%E5%91%9B%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="动作要点"><a href="#动作要点" class="headerlink" title="动作要点"></a>动作要点</h1><p>先手部动作再腿部动作，可以先不连贯</p><p>假定人已经在水面处了，上浮时，需要最大程度把向前的力和水的反作用力转化为头向上的力。首先手微向上抬，这是为了用横向速度换取纵向的上升力，然后手臂朝两侧展开，期间手掌斜向上，这也是获取升力。然后小臂保持水平，由大臂移动使得小臂所成平面向下压水，这时的反作用力让头得以向上抬起。在收小臂的瞬间头才可能向上，当头离开水面时，上层水的压力消失，此时人上浮会更有效。</p><p>蛙泳蹬腿：收的时候腿并拢，在蹬的时候先张开，再夹住并拢。翻的时候小腿翻，膝盖之间的距离保持不变。蹬的时候脚掌保持与小腿垂直，向后蹬。收腿的时候脚掌与身体在一条线上（如果只动小腿，收上来的时候脚会完全露出水面）</p><h1 id="浮不上来"><a href="#浮不上来" class="headerlink" title="浮不上来"></a>浮不上来</h1><ol><li>只有换气的时候往上抬头，其余时候身体都要保持平行以减小阻力</li><li>肩关节往后压，使得身体成直线。腰不要塌</li><li>换气的时候主要靠头向上仰而不是腰向上用力</li><li>吐气后再抬手，手一分开就抬头，换气后先伸手再低头，低头后再蹬腿</li><li>抬头要快一些</li></ol><p>实际上的经验：蹬腿的时候手伸得足够高，手掌类似浮板一样并拢在前面，可以提供升力</p><h1 id="控制方向"><a href="#控制方向" class="headerlink" title="控制方向"></a>控制方向</h1><p>只要划一边手，就会往另一边游，或者腰往一边扭，就会往同侧方向游</p><h1 id="踩水"><a href="#踩水" class="headerlink" title="踩水"></a>踩水</h1><p>手和脚同时，在收的时候减小面积，在蹬的时候增大面积</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游泳</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【其他】背单词的一些心得</title>
    <link href="/2021/02/26/%E3%80%90%E5%85%B6%E4%BB%96%E3%80%91%E8%83%8C%E5%8D%95%E8%AF%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97/"/>
    <url>/2021/02/26/%E3%80%90%E5%85%B6%E4%BB%96%E3%80%91%E8%83%8C%E5%8D%95%E8%AF%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="背单词的心得"><a href="#背单词的心得" class="headerlink" title="背单词的心得"></a>背单词的心得</h1><ol><li>背新词的时候利用一些蛛丝马迹把单词联想到意思上</li><li>高频率地重复，每3-4个新词就Z字形地回来再想一遍</li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>英语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【笔记】单向度的人</title>
    <link href="/2021/02/24/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E5%8D%95%E5%90%91%E5%BA%A6%E7%9A%84%E4%BA%BA/"/>
    <url>/2021/02/24/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E5%8D%95%E5%90%91%E5%BA%A6%E7%9A%84%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="单向度的人-札记"><a href="#单向度的人-札记" class="headerlink" title="单向度的人 札记"></a>单向度的人 札记</h1><h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><blockquote><p>一种组织社会的方式是相对于历史上其他替代性的选择而被评价的</p></blockquote><p>在一定范围内，评价一个社会的方式是“它能否变得更好”，这种好坏是在人的能动范围内的。评价以改变为前提。</p><blockquote><p>面对发达工业社会成就的总体性，批判理论失去了超越这一社会的理论基础</p></blockquote><p>如果新社会不能带来更大的利益，就不会有足够的力量让人自愿投入到新社会的变革中。只要大工业生产依然让每个人获利，就没有人会想到去推翻它</p><h2 id="单向度的社会"><a href="#单向度的社会" class="headerlink" title="单向度的社会"></a>单向度的社会</h2><h3 id="控制的新形式"><a href="#控制的新形式" class="headerlink" title="控制的新形式"></a>控制的新形式</h3><blockquote><p>发达工业社会的显著特征是它有效地窒息那些要求自由的需要，即要求从尚可忍受的、有好处的和舒适的情况中摆脱出来的需要</p></blockquote><p>例子：社会孤立租房抑制买房，鼓励过度消费的夜生活而抑制不工作。最重要的，鼓励过度生产和过度消费</p><p>人无法独自摆脱这种社会抑制，因为一旦人的经历与他人有决定性的差异，就会加大交流的隔阂，从而丧失赖以生存的社会性。可以说这种社会必然有自我稳定机制，现存长期、稳定的社会都存在各种显式或隐式的机制确保相异的革命力量被抑制。</p><p><strong>内心向度的削弱</strong></p><p>思想是物质世界的映射，一个单一技术支撑的社会，必然是一个技术极权的社会，技术并不能一直保持中立性（个人认为，是贸易这个最基本的形式使得技术与商品、商品的价值绑定，从而失去中立性），这就导致技术被赋予的话语成为工业化社会中的唯一话语。无论它是什么，人内心的反驳力量在生存压力面前会不断被抑制。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哲学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】大气层的渲染</title>
    <link href="/2021/02/18/%E3%80%90Unity%E3%80%91%E5%A4%A7%E6%B0%94%E5%B1%82%E7%9A%84%E6%B8%B2%E6%9F%93/"/>
    <url>/2021/02/18/%E3%80%90Unity%E3%80%91%E5%A4%A7%E6%B0%94%E5%B1%82%E7%9A%84%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity星球大气生成"><a href="#Unity星球大气生成" class="headerlink" title="Unity星球大气生成"></a>Unity星球大气生成</h1><p>大气部分知识多而且相当复杂，故单独开一篇文章。</p><h2 id="前置知识：Shader"><a href="#前置知识：Shader" class="headerlink" title="前置知识：Shader"></a>前置知识：Shader</h2><p>Shader分为对顶点的着色方法和对屏幕上每像素的着色方法，分别是Vertex Shader=片断Shder和Pixel Shader=片元Shader（也叫Fragment Shader）</p><p>Unity对Shader编写语言作出统一，使得其不随硬件变化而改变，叫作ShaderLab，可视化shader graph采用的是Vertex/Fragment Shader</p><p>Shader类型：</p><img src="/2021/02/18/%E3%80%90Unity%E3%80%91%E5%A4%A7%E6%B0%94%E5%B1%82%E7%9A%84%E6%B8%B2%E6%9F%93/2021-02-18-10-47-50.png" srcset="/img/loading.gif" class=""><p>注意第1和2个的区别是是否受光照影响</p><p><strong>Unlit Shader框架</strong></p><p>shader编写并非用C#，有自己的语法格式。</p><p>name:Hidden隐藏菜单<br>Properties:属性，对外暴露的接口<br>SubShader：一组Shader，按照性能需求编写不同shader<br>Fallback：当前Shader无效时的其他Shader</p><p>Pass:渲染方法，即核心调用的方法。vert和frag对应顶点和像素着色（可以同时用两种方法来渲染）</p><p><strong>vert和frag</strong></p><img src="/2021/02/18/%E3%80%90Unity%E3%80%91%E5%A4%A7%E6%B0%94%E5%B1%82%E7%9A%84%E6%B8%B2%E6%9F%93/2021-02-18-11-24-00.png" srcset="/img/loading.gif" class=""><p>vert将3D物体的坐标映射到相机的2D坐标上，再将各自的材质坐标也原封不动地映射到2D坐标上。<br>frag将uv坐标还原为颜色，再应用雾效（雾效：越远地方的东西会带上环境的颜色）。<br>注意：_MainTex在用的时候还要再声明一次，所有的properties都如此。vertex第4个坐标是0/1区分位置和向量。</p><p><strong>pipeline</strong></p><p>每一帧，unity会先准备资源，再渲染几何图像，就是vert，再光栅化，逐个像素渲染，即frag</p><h2 id="大气渲染概述"><a href="#大气渲染概述" class="headerlink" title="大气渲染概述"></a>大气渲染概述</h2><p>首先，将大气看作一个球壳，给定摄像机的位置，对每一个像素，从摄像机处发出射线，根据射线的几何关系得到颜色</p><p>若射线与大气不交汇，则不进行操作<br>若射线与大气交汇，但不碰到星体，则要知道穿过的大气厚度与穿过的距离<br>若射线与大气交汇，但碰到星体，则要显示大气下的星体的颜色作为底色。</p><p>大气层独立于星球渲染，要素是厚度和距离<br>星球需要利用材质渲染，先用深度图获取星球表面信息，在映射到真实距离<br>海洋因为也是渲染的材质，所以需要手动根据海洋高度判断“地面”的距离</p><p>摄像机穿过大气的线段，被等分成若干个点，对每一个点进行入射和出射光的计算。</p><p><strong>外散射</strong></p><p>从太阳发出的单色光到达P点，在入射过程（称为外散射）中，单色光被散射掉一部分。散射的比例与波长和经过路线的大气密度有关（显然非均匀，有一个积分）：</p><img src="/2021/02/18/%E3%80%90Unity%E3%80%91%E5%A4%A7%E6%B0%94%E5%B1%82%E7%9A%84%E6%B8%B2%E6%9F%93/2021-02-18-15-03-03.png" srcset="/img/loading.gif" class=""><p>式中给出从任意a点到b点的散射比例计算公式，K代表不同的波长有不同的比例系数，具体是一个负指数幂的形式，H_0是大气密度的一个调节常数。</p><p>外散射给出的t，a-b路径越长，高度越低，经过的粒子数就越多，粒子散射出去的光就越多。</p><p><strong>相位</strong></p><p>将太阳光视作平行光，则对于每一个P点，P点到太阳的射线与P点到相机的射线的夹角都是固定的，光线击中大气粒子后，散射的光在角度上的分布就由下式描述：</p><img src="/2021/02/18/%E3%80%90Unity%E3%80%91%E5%A4%A7%E6%B0%94%E5%B1%82%E7%9A%84%E6%B8%B2%E6%9F%93/2021-02-18-15-25-09.png" srcset="/img/loading.gif" class=""><p>其中g是常数，瑞利散射取g=0，其他情况通常让g在(-1,1)之间变化。</p><p><strong>内散射</strong></p><p>每个像素对应的一个矢量若穿过大气层，则每个P点外散射的光叠加，就得到像素对应的光强。</p><img src="/2021/02/18/%E3%80%90Unity%E3%80%91%E5%A4%A7%E6%B0%94%E5%B1%82%E7%9A%84%E6%B8%B2%E6%9F%93/2021-02-18-15-33-14.png" srcset="/img/loading.gif" class=""><p>I_s代表太阳发出的每个单色光的光强（真实太阳的白光参考太阳光全光谱图）。输入光强、波长的散射系数、相位导致的散射系数都是简单的比例相乘（每个点的相位都相同，所以F拿到积分外面），路径越长，散射积累的光就越多，故关于路径积分。</p><p>积分号里面是三项相乘，大气密度项，大气越密，参加散射的粒子就越多，散射越强。入射单色光衰减系数，带上负指数幂后，入射光经过的大气越厚，衰减的就越多，出射光同理。</p><p><strong>地面散射</strong></p><img src="/2021/02/18/%E3%80%90Unity%E3%80%91%E5%A4%A7%E6%B0%94%E5%B1%82%E7%9A%84%E6%B8%B2%E6%9F%93/2021-02-18-16-08-29.png" srcset="/img/loading.gif" class=""><p>其中I_v是原本大气的部分，I_e是地面散射发出的光强，地面的散射光只需被大气衰减即可。</p><p>实际操作时，每一个block负责有自己的render，shader只获取自己的一块内容</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>暂不考虑摄像机在大气层内部的情况，先找到像素对应的射线、距离</p><p><strong>多个Shader叠加</strong></p>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【随笔】单亲家庭下教育缺失的影响</title>
    <link href="/2021/02/16/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E5%8D%95%E4%BA%B2%E5%AE%B6%E5%BA%AD%E4%B8%8B%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
    <url>/2021/02/16/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E5%8D%95%E4%BA%B2%E5%AE%B6%E5%BA%AD%E4%B8%8B%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="单亲家庭下教育缺失的影响"><a href="#单亲家庭下教育缺失的影响" class="headerlink" title="单亲家庭下教育缺失的影响"></a>单亲家庭下教育缺失的影响</h1><p>未来，随着资本积累继续进行，贫富差异继续扩大，社会阶级继续分裂，资本吸引力大于性吸引力，人们缺失安全感，代偿性性行为导致单亲家庭增多。势必导致底层人群教育机会的减少。</p><p>直接的后果就是心理压力增加，极度缺乏安全感，繁殖的排他性减弱，引入一夫多妻和一妻多夫制度，使得资本更加与繁殖权绑定。底层人群大多采取一妻多夫形式，多人共住一间房屋，小孩由母亲养育。</p>]]></content>
    
    
    <categories>
      
      <category>个人观点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【随笔】大学内卷难题：话语体系解析</title>
    <link href="/2021/02/16/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E5%A4%A7%E5%AD%A6%E5%86%85%E5%8D%B7%E9%9A%BE%E9%A2%98%EF%BC%9A%E8%AF%9D%E8%AF%AD%E4%BD%93%E7%B3%BB%E8%A7%A3%E6%9E%90/"/>
    <url>/2021/02/16/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E5%A4%A7%E5%AD%A6%E5%86%85%E5%8D%B7%E9%9A%BE%E9%A2%98%EF%BC%9A%E8%AF%9D%E8%AF%AD%E4%BD%93%E7%B3%BB%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="内卷环境下的话语体系解析"><a href="#内卷环境下的话语体系解析" class="headerlink" title="内卷环境下的话语体系解析"></a>内卷环境下的话语体系解析</h1><p>这篇文章是第一次用需求来分析话语体系，试图使理论更加完善。</p><h2 id="单赛道话语体系：万物皆下品，唯有读书高"><a href="#单赛道话语体系：万物皆下品，唯有读书高" class="headerlink" title="单赛道话语体系：万物皆下品，唯有读书高"></a>单赛道话语体系：万物皆下品，唯有读书高</h2><p>该话语体系的兴起来源于科举考试中的优胜者相对于一般贫苦人家享有绝对的物质、精神优势，落后的历史条件下，人的生存环境得不到保证，使得生存资料在话语体系占比中增大，官民生活差距大，择偶权让位于物质需要，自由发展与社交需求被生存资料压缩。</p><p>随着时代发展，单赛道的评判标准（秀才-举人-进士-状元）被模糊化，在高考后，大学中诞生了多种评判标准，单赛道的单纯延续，即GPA评判标准；在GPA信服力不足的情况下，引入考证标准，但此时已经向多赛道的方向发展了。</p><p>单赛道标准为何失效，我认为有两大因素：</p><ol><li>物质需要被过度满足是主因，生存需要在过度满足的边际递减效应下让位于安全需要、社交需要、自我实现需要。同时以前被生存需要绑架的其他需求也得以释放。主流发声群体改变，单赛道拥护者的物质资源优势被消解</li><li>资本主义发展程度加深导致就业安全感缺乏，单赛道不再适合于大学以外的生活。资本主义话语体系侵入（渴求高消费、渴求高素质人才、渴求高服从度劳动力）</li></ol><p>总之，单赛道时代随着物质极大丰富而被人抛弃，为了满足社交需求和安全需求，多赛道话语体系被建构起来</p><h2 id="多赛道话语体系：人有优劣之分，亦各有所长"><a href="#多赛道话语体系：人有优劣之分，亦各有所长" class="headerlink" title="多赛道话语体系：人有优劣之分，亦各有所长"></a>多赛道话语体系：人有优劣之分，亦各有所长</h2><p>多赛道话语体系来自于单赛道的崩解带来的新的问题：谁决定社会尊重和安全感的分配？答案是回归原始状态。社会尊重无非是人无我有、人劣我优，安全感还原到原始的性吸引力、性格、家境（指家庭氛围环境），其中每个人在意的“人无我有”的项目不同，于是多赛道体系自然建构。人群被划分为不同小群，每一群之间交流减少（话语体系冲突导致），小群各自拥护一种话语体系。但在择偶方面都回归到本能。</p><p>这个体系看起来健全，但依然有许多需要补充的地方，如每个人难道不可以同时尊重别人，又被别人尊重吗？为何人们要竞争？为何安全感用的是“分配”，而不是“制造”？ 假想一个人人爱人人的社会，人不需要融入社会也可生存，将繁殖欲望变为共同聚餐一样的非排他行为，这可行吗？不可行。因为涉及代际变化的行为天然地引入“存在压力”，且基因突变在个体水平发生，在压力驱动下的囚徒博弈导致假想的“理想人类”是不稳定解。生存竞争意味着人与人需要有所不同，个体繁殖最优解催生了排他性。脱离社会的情况也不可能存在，因为人必须在社会中才能找到配偶。无论如何，总有一种原始需要是排他的、驱动人与异性建立亲密关系的。安全感和社会尊重一定不可能满足所有人，而仅在生存压力（基因的生存压力，包括繁殖压力和个体生存压力）减轻的时候会得到总量的提升。</p><h2 id="新话语体系需要直面的核心问题"><a href="#新话语体系需要直面的核心问题" class="headerlink" title="新话语体系需要直面的核心问题"></a>新话语体系需要直面的核心问题</h2><p>在当前环境下，新话语体系需要解决如下问题：</p><ol><li>如何外在化生存压力？即在物质丰富的条件下，如何决定谁有择偶权（亲密关系-安全需求）、谁有社会尊重力（社交需求）？</li><li>如何将学习这一强制行为合理化？</li><li>如何面对管控校园外部的资本主义话语体系的侵袭？</li></ol><p>我认为，将来的校园话语体系将从多赛道话语体系变为资本主义的多赛道体系。体现为：谁有钱谁就能整容，谁好看谁就有择偶权，谁家境富足就能进行小众艺术，就能被别人尊重。没钱的为了赚钱而学习，有钱的为了自我发展而学习，这必将导致不同学科的难度差异加大。</p><p>资本相对稳定的保值性提供安全感，但人与人无法保持一对一的关系。封建时期以男权对女性的压制为载体确立了单向的一对一关系，现代社会无法建立这种确定感，因为判断的标准并非人个体拥有且可以控制，于是催生出代偿措施（高消费、一对多关系）</p><p>话语体系的传承，除了繁殖机会、个体生存，还有教育机会。单亲家庭造成教育机会丧失。</p>]]></content>
    
    
    <categories>
      
      <category>个人观点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【随笔】破缺处</title>
    <link href="/2021/02/16/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E7%A0%B4%E7%BC%BA%E5%A4%84/"/>
    <url>/2021/02/16/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E7%A0%B4%E7%BC%BA%E5%A4%84/</url>
    
    <content type="html"><![CDATA[<h1 id="破缺处"><a href="#破缺处" class="headerlink" title="破缺处"></a>破缺处</h1><p>自欲望起始，与规则相合，时间演化给出人的答案。</p><p><strong>行动力来自于环境奖励与人精神的健壮，后者取决于需求破缺处的多少。</strong>人所处的环境、所做的事情、与之谈话的其他人等，构成自制力的环境。环境奖励的规则是满足需求，底层需求，如吃饭睡觉、洗澡穿衣、休息，不需要社会给予的话语体系。<strong>深层次需求来自于自我意识，这是社会在自我的映射，因此与社会话语体系牢牢绑定。</strong>在一个话语体系下，该行动对深层需求的满足随之被定义，即感知到环境奖励。一旦环境奖励与需求不相合，那么行动力便随之退却。</p><p>精神健壮性减缓需求的恶性效果，减缓需求增长速度。人的总需求可按照五层需求理论划分，社交需求以上都需要局部话语体系的定义。<strong>奖惩机制在需求被满足时基于奖励，但人欠缺的是需求，而并非欠缺快感奖励</strong>，单一需求满足的奖励不足以覆盖其他需求的欠缺导致的健壮性减弱。单一需求的奖励在过度满足后会有边际递减效应。一旦大部分需求都被满足，由需求匮乏而产生的负面效果被清除，有需求匮乏而产生的其他路径的正面奖励也被削弱。例如，一个人可以在同学去聚会的时候去图书馆写数学题，这是因为他的社交需求被满足，故聚会的奖励变弱，而且他在写数学题时对积累下来的社交需求可以更好的抵制，这是由需求满足带来的边际递减效应导致的。</p><p>不同话语体系的社交需求是不能相互补充的，这是因为高层次需求自话语体系定义，也无法摆脱话语体系，除非在实践中将该话语体系抛弃。人受限于特殊的话语体系中，就必定要解决该话语体系下的需求问题。<strong>有意思的是，大多数环境并不限定单一的话语体系，而是多种话语都可解释现状，此时就能体现人的能动性</strong>，就如一个大学校园环境，可以是内卷的话语体系，也可是多元发展的体系，在未来出路可观的情况下，多元发展体系有建立的基础，但在出路并不明朗的情况下，多元发展体系变为多赛道体系，而后者只是单赛道内卷的一个简单拓展。</p><p>聚焦人类社会最广泛的话语体系：基于自由贸易的资本主义话语体系、基于个人生存和社会需求诞生的一般道德体系（不害人、公平竞争、非暴力等）、基于共同环境限制的一般群体话语体系。最后一种的限制可大可小，大的如基于人种的种族话语体系、基于地域历史和文化的国家话语体系，小的如基于共同工作场所的职员话语体系，或者是基于共同分享风险和安全感的家庭话语体系。这些话语体系就是社会关系。<strong>一个社会关系代表一种话语体系，话语体系映射到自身，就是对人需求的界定，话语体系映射到他人，就是人对他人基于话语道德的评判</strong></p><p>解决话语体系中的核心需求，就使得人有了生存的动力。宗教的存在解决了安全感的需求，而这恰恰是现实中无安全感脆促发的。<strong>虚拟的话语体系并非无作用，这种现实至上的观点是错误的。</strong>如短信的文字虽然是电子屏幕显示的，但内容是对方现实思想的直接映射，因此与现实话语具有同等的重要性。</p>]]></content>
    
    
    <categories>
      
      <category>个人观点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【随笔】喜乐</title>
    <link href="/2021/02/14/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E5%96%9C%E4%B9%90/"/>
    <url>/2021/02/14/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E5%96%9C%E4%B9%90/</url>
    
    <content type="html"><![CDATA[<h1 id="生活的乐与悲"><a href="#生活的乐与悲" class="headerlink" title="生活的乐与悲"></a>生活的乐与悲</h1><p>乐与悲是不能抵消的，它们尽管有相反的作用，但并不遵循数学的加减法。快乐的叠加边际递减，悲伤和疼痛同理。那么，由消极情绪所改变的，能被再还原回去吗？</p><h2 id="做一个情绪猎手"><a href="#做一个情绪猎手" class="headerlink" title="做一个情绪猎手"></a>做一个情绪猎手</h2><p>极端一些来看，两个被物理阻绝的人，无法交流感情。情感需要一种承载体，就像图片、视频、语言、音乐。特定的音乐蕴含特定的情感，这一点很清楚。只要借由音乐进行物与人的交流，就能达到情感交流的目的。但人与人呢？人的交流需要更多东西，自由意志与物的载体，如语言、声音、文字、图像等。</p><p>对两个生活在不同圈子的人，平时接触的人与事都不同，此时便无法利用寻常事物共情，也即无法直接用概括性的文字和语言来传递情感。这时候需要的是情感的原载体，就是原始的能直接触动的情绪资料。</p><p>越是生活圈子远离，就越难找到共同的情绪资料。即使有可以超越现实的虚拟技术，也难以找到交集。关系尽管可以是理想的，但需要现实中的物质来支持。</p><h2 id="正负无法抵消的后果"><a href="#正负无法抵消的后果" class="headerlink" title="正负无法抵消的后果"></a>正负无法抵消的后果</h2><p>还原的要素是记忆，尤其是情感的记忆。喜与悲只是由特定的原材料出发被制造的情感，而如果不改变这些原材料，就无法重置情感的记忆。<strong>不被唤醒的记忆并不代表不存在原材料，而只是潜藏了起来。</strong></p>]]></content>
    
    
    <categories>
      
      <category>个人观点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【unity】RandomPlanets开发日志</title>
    <link href="/2021/02/12/%E3%80%90unity%E3%80%91RandomPlanets%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    <url>/2021/02/12/%E3%80%90unity%E3%80%91RandomPlanets%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Random-Planets：基于噪声的星球生成器"><a href="#Random-Planets：基于噪声的星球生成器" class="headerlink" title="Random Planets：基于噪声的星球生成器"></a>Random Planets：基于噪声的星球生成器</h1><h2 id="2-12"><a href="#2-12" class="headerlink" title="2/12"></a>2/12</h2><p><strong>mesh</strong></p><p><a href="https://blog.csdn.net/zxy13826134783/article/details/80114487" target="_blank" rel="noopener">https://blog.csdn.net/zxy13826134783/article/details/80114487</a></p><p>mesh=顶点数组+面片数组，其中三角形面片序列化为顶点标号组，代表渲染的三角形以及渲染顺序</p><h2 id="2-14"><a href="#2-14" class="headerlink" title="2/14"></a>2/14</h2><p>今天主要是实现分形的perlin noise</p><p>首先要澄清一个自己误解了很久的东西：fractual noise不是一个特殊的noise，而是将各种原生noise（如perlin）进行各octave的叠加形成的。</p><p><strong>山脉</strong></p><p>山脉用perlin noise截断再加入sigmoid锐化处理，从结果来看，容易出现环形山。</p><p>虽然用当地地形作了环形山的消除，但结果仍然不是很好</p><h1 id="2-15"><a href="#2-15" class="headerlink" title="2/15"></a>2/15</h1><p><strong>面数限制</strong></p><p>今天解决因为面数太少导致的模糊问题，方法是将每个正方形继续细分，逐个渲染这些面，从而突破顶点数限制。</p><p>用常量避免了动态数组，最后效果来看，纹理清晰度提升了不少。</p><p>地形生成改成了手动，因为计算量太大。</p><p><strong>大气</strong></p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于学习的二三事</title>
    <link href="/2021/02/08/%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
    <url>/2021/02/08/%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="方法与人的界限：写在大二寒假之后"><a href="#方法与人的界限：写在大二寒假之后" class="headerlink" title="方法与人的界限：写在大二寒假之后"></a>方法与人的界限：写在大二寒假之后</h1><p>这学期高压式的学习生活让我得到了颇为丰富的经验，当然这些经验是有好有坏的。虽然不见得有质的帮助，但好歹还是记录下来，供以后参考。</p><h2 id="理解性记忆"><a href="#理解性记忆" class="headerlink" title="理解性记忆"></a>理解性记忆</h2><p>平时的机械记忆、对着书本背公式、记下关键词然后短期背诵这些方法都无法得到足以在考试中准确反应的知识。将知识输出的过程才是记忆的过程，而机械记忆只是告知有“存在”而已，无法翻译出准确的知识。</p><p>学习中真正有用的环节是接受知识后训练输出的过程、接受新知识时举一反三的过程。前者是过程式的记忆，能长久的保留，后者是联想，让各种知识之间的连接更加通畅。</p><p>实验证明比较好的方法</p><ol><li>独立推导证明</li><li>无提示独立写出一门课程的所有公式（强制联想）</li><li>大量有参考答案的计算、证明（培养解题时的准确感觉）</li><li>复杂的方法，需要总结（但核心步骤是独立写出思路，而不是按照思路背诵记忆）</li></ol><h2 id="题感"><a href="#题感" class="headerlink" title="题感"></a>题感</h2><p>培养题感的目的并不是为了能“看出答案”，而是不要让不确定性带来的焦虑影响解题准确度。培养题感的方法是做带参考答案的题目。另外，平时的作业尽量提高正确率，能有效避免经验不足带来的焦虑。</p><h2 id="思维速度"><a href="#思维速度" class="headerlink" title="思维速度"></a>思维速度</h2><p>这大概是人的界限所在，但正常人也可以通过强制性的联想和集中注意力的训练弥补天赋的不足。有时候对事物的热爱与否会起到本质的作用，这是因为它决定了一个人是否会进行快速而深入的思考。这方面还欠缺实践，等以后再补充。</p>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔：话语权、环境、意志力</title>
    <link href="/2021/02/08/%E9%9A%8F%E7%AC%94%EF%BC%9A%E8%AF%9D%E8%AF%AD%E6%9D%83%E3%80%81%E7%8E%AF%E5%A2%83%E3%80%81%E6%84%8F%E5%BF%97%E5%8A%9B/"/>
    <url>/2021/02/08/%E9%9A%8F%E7%AC%94%EF%BC%9A%E8%AF%9D%E8%AF%AD%E6%9D%83%E3%80%81%E7%8E%AF%E5%A2%83%E3%80%81%E6%84%8F%E5%BF%97%E5%8A%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="话语权、环境与意志力"><a href="#话语权、环境与意志力" class="headerlink" title="话语权、环境与意志力"></a>话语权、环境与意志力</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这篇文章写在寒假即将结束的二月初。最近的一个月从不幸开始，抑郁、挣扎、自我接受，最终以某种奇怪的状态结束。但是时候把这一个月以来自己偶然得来的有价值的思考记录下来了，就像捡起闪着光的碎片一样，虽然现在看来无意义，但在未来可说不定。</p><h2 id="定义人之所以为人的东西"><a href="#定义人之所以为人的东西" class="headerlink" title="定义人之所以为人的东西"></a>定义人之所以为人的东西</h2><p>很长一段时间我在思考人应该遵守哪种道德观念。道德，是个隐含内容很深的词。乍看都是一些天经地义的东西，例如人不能杀人，社会应当为才是举，个人也应尊重他人、和睦相处。但凡是讨论道德就必须讨论好恶，或者说，好恶是道德中核心的东西。一种道德观如一种视角，从其中看向外部的世界，道德在无形中将万物染成黑白两色。有了道德观，必然会以带有偏见的视角看待他人，而这种偏见就形成了一种话语。在我看来，道德观念隐含话语权的争执，一种道德观势必会将人分为高中低三等，而分类方式也千奇百态。</p><p><strong>社会并没有公认的道德观念，同时，话语权自身并不要求是完备的</strong>。站在富二代的视角，穷人是下等人，富家子弟是上等人；站在资本家的视角，打工人是下等人，资本家是上等人；站在国家管理者的视角，国家所代表的阶级是上等人，而与该阶级利益冲突的是下等人。佃农、贫农、富农；打工人、中产、资产阶级，这些划分本身含有好恶性质，因此被攻击的一方必定会塑造出与之对抗的话语体系，进而达成自己生存的目的。</p><p>话语权自身可以是不完备的，毕竟人的逻辑也相当地有破缺，这一点不需要太过解释。</p><p>很长时间我心中的话语权备选项是“程度决定论”和“天赋决定论”，程度决定论，即人与人能力的量上的差异决定了人本质的不同。而天赋决定论，即人与人天赋上的差异起决定性作用，时间对其的影响几乎可以忽略，进而量的差异转移到天赋的差异。前者还让人勉强可以接受，后者就只能让人感到绝望。不幸的是，若我承认了前者，我的经验则会告诉我那么后者更加正确。事实又是如何？小说和漫画中“谁也不会受伤的世界”真的存在吗？</p><h2 id="大一统道德规范与人的实践本质"><a href="#大一统道德规范与人的实践本质" class="headerlink" title="大一统道德规范与人的实践本质"></a>大一统道德规范与人的实践本质</h2><p>我一直追求建构所谓“绝对正确”的道德规范，这也是因为只要依附于这套体系，就能保证自身绝对的纯洁性和正义性。然而长久的探索以后，不幸的结果是这样的道德规范并不存在。</p><p>弃恶扬善看起来是对的，但是对待恶人是否要杀人呢？绝大多数文艺作品对此避讳不谈。若是杀了人，主角自身的正义就显得伪善，若不杀人，就只能让剧情安排恶人从善，或者是恶人被隔绝在视线之外。如何化解斗争？无外乎一方胜利、两败俱伤、引入第三者的力量后互相和解或是不再来往。但双方的内在矛盾并没有解决。</p><p><strong>在道德规范之外，不可质疑的事实是，人必须建构一个适合自身的话语体系才能生存下去</strong>。人作为会思考的高级动物，必须掌握一套能解释自身遭遇的价值体系，即掌握他者如何评价自己。但于此同时，人必须塑造一种让自身也能生存下去的自己的话语体系，以此让自己不排斥自己的存在。<strong>人必须处于自身话语体系里至少是中性的存在</strong>，而且不能接受恶性的存在。在这套为自身打造的体系里，恶性的存在没有现实的过错，而仅仅因为对中性或善性的自己的否定就会遭来反对。</p><p>构建一个无恶性而全为中性的话语体系也是不可能的，因为人有基本的仇恨、厌恶、反感，<strong>无法解释人的内部性的话语体系注定会被抛弃</strong>，为了适应这个体系，必然存在着恶的位置。可惜的是，现实中恶的位置没有像小说中那么巧合地能指向共同的敌人。也许曾经是存在的，即指向非人的资本主义。但是环境在改变，<strong>话语体系因为自身无法提供足够分配给支持者的利益而崩溃，新的体系被建构起来，旧的支持者四分五裂</strong>。同样，若找到持续而长久的利益，新的体系也能让四分五裂的旧体系弥合起来。</p><p>没有大一统的话语体系，现在，什么能带来新的利益，什么就是新的、逐渐壮大的话语体系，也是新的道德观念。社会的总体利益随着生产力的发展而壮大，当生产力停滞的时候，总体利益四分五裂，新的派系之间矛盾激化，争夺话语权。</p><h2 id="意志力：人的能动性"><a href="#意志力：人的能动性" class="headerlink" title="意志力：人的能动性"></a>意志力：人的能动性</h2><p>人的能动性是主观的，因此与话语体系密切相关。但我并没有得到理论上的完整解释，只能凭经验进行猜想。</p><p>人的能动性由人的完整性决定，又由客观现实通过话语体系的映射而激发。解决了话语体系中根源上的矛盾，人的意志也因此增强。客观环境决定了人能够选择哪些话语体系，而选择的某种话语体系又实际地驱使人进行活动。若是无法解决根源矛盾，经验与话语体系不再自恰，驱使力因此减弱。</p><p>另外，这里的解决是现实性的解决，而不是想象的或是虚构的。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文化生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【写作】人物塑造</title>
    <link href="/2021/02/05/%E3%80%90%E5%86%99%E4%BD%9C%E3%80%91%E4%BA%BA%E7%89%A9%E5%A1%91%E9%80%A0/"/>
    <url>/2021/02/05/%E3%80%90%E5%86%99%E4%BD%9C%E3%80%91%E4%BA%BA%E7%89%A9%E5%A1%91%E9%80%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="人物塑造"><a href="#人物塑造" class="headerlink" title="人物塑造"></a>人物塑造</h1><p><strong>对话的声音反映性格</strong></p><p>不同性格的人对事件会有不同反映。外向的更热情，更自信。内向的更细心，更追求稳定。</p><p><strong>桥段：见面</strong></p><p>人与人见面之间的行动会反映出人的性格，包括问候、嬉戏、谈论、怒骂甚至争斗。</p><p><strong>个人生活：衣食住行</strong></p><p>吃的（食物，地点），穿的衣服（整洁度、审美、暴露度（女）），住的地方（大小、审美、干净程度），出行工具</p><p>动作：走路、等待、睡觉、谈论</p><p><strong>情绪外显的小动作</strong></p><p>诸如愤怒、沮丧、高兴、责怪、激动等的情绪，一般人的表现都是一样的，作为与读者共享的共同语言。</p><p>一些肢体语言是个性化的，如在无聊时打发时间的动作、害羞的动作、焦虑的动作、恐惧的动作</p><p><strong>对典型事物的差异式反应</strong></p><p>如用愤怒的方式对待恐惧，用拖延的方式对待困难，用忍让的方式对待折磨</p><p><strong>典型特征组合</strong></p><p>男性：像大哥一样比较霸气的、性格乐观关键时刻会帮自己一把的好基友、自傲的比较文弱的书生、懦弱的废宅类型、孤傲的剑客类、完全被动的弟弟类型</p><p>女性：</p><img src="/2021/02/05/%E3%80%90%E5%86%99%E4%BD%9C%E3%80%91%E4%BA%BA%E7%89%A9%E5%A1%91%E9%80%A0/2021-02-05-20-05-12.png" srcset="/img/loading.gif" class=""><p>更多动作、习惯、嗜好见：<a href="https://zh.moegirl.org.cn/%E8%90%8C%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener">https://zh.moegirl.org.cn/%E8%90%8C%E5%B1%9E%E6%80%A7</a></p><p><strong>思考与需求</strong></p><p>人物在特定环境时，为自己的生存、发展、地位、名利、社会关系等需求而做出的行动。能体现人物自身的思考。</p><h2 id="overlord剧场版"><a href="#overlord剧场版" class="headerlink" title="overlord剧场版"></a>overlord剧场版</h2><p>大坟墓位置转移：在看不见的地方进行，直接过渡<br>骑士侵掠村庄（阴谋）：安兹练习使用魔法望远镜，偶然看到<br>与战士长认识：战士长为了阻止骑士侵掠<br>安兹救下战士长：战士长被刺杀（阴谋）<br>驱动：了解外部信息<br>桥段：旅店被挑衅打碎药水瓶，工会接任务不识字，结识冒险者伙伴<br>驱动：提升声望<br>桥段：森林贤王，草药<br>了解武技-&gt;倾国倾城，夏提亚被控制<br>复活夏提亚-&gt;赛巴斯<br>守卫大坟墓-&gt;利用蜥蜴人召唤不死者</p><p><strong>情节过渡的方法</strong></p><ol><li>偶然法：偶然遇见、偶然看见</li><li>阻碍法：本来想做A,但是因为途中发现不能进行环节B，所以过渡到环节C</li><li>主观动机：角色思考周身环境，想要达成目的A, 选择了方法B，偶然造成了情况C</li><li>线索法：角色看见/观察到了线索A，在一段情节结束后，对A进行探索，遇到了情况C</li><li>直接承接法：为了做A，就要进行B，在进行B的时候遇到状况C</li></ol><p><strong>情节过渡的突兀性</strong></p><p>大环境+偶然事件：如果让两个没有特定联系的人相遇，就只能先铺垫一个大环境，然后创造一个符合环境的偶然事件。</p><p>隐藏线索+逐步铺垫：让两个没有联系的人相遇，首先要在原有环境中创造看起来正常的事件，然后逐步深入关系。刚开始读者认为是正常的事件，事实上在后期会发现是非同寻常的事件，从而引入冲突。</p>]]></content>
    
    
    <categories>
      
      <category>写作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小说</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【笔记】当代叙事学</title>
    <link href="/2021/02/02/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E5%BD%93%E4%BB%A3%E5%8F%99%E4%BA%8B%E5%AD%A6/"/>
    <url>/2021/02/02/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E5%BD%93%E4%BB%A3%E5%8F%99%E4%BA%8B%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="当代叙事学"><a href="#当代叙事学" class="headerlink" title="当代叙事学"></a>当代叙事学</h1><p>作者：华莱士.马丁</p><h2 id="从小说到叙事"><a href="#从小说到叙事" class="headerlink" title="从小说到叙事"></a>从小说到叙事</h2><h3 id="弗莱的历史理论"><a href="#弗莱的历史理论" class="headerlink" title="弗莱的历史理论"></a>弗莱的历史理论</h3><p>第一个角度：从人与环境的比较来分类</p><ol><li>神话：主角本质上优于别人和环境，即主角是神，可以轻易改变人和环境</li><li>罗曼司：主角程度上优于别人和环境，主角不是寻常人，而且靠自己的努力改变了命运</li><li>高级模仿的：主角程度上优于别人，但不优于环境，像史诗的英雄，虽然有非凡的能力但是无法对抗命运</li><li>低级模仿的：主角程度上不优于别人，也不优于环境，主角是一个普通人</li><li>反讽：主角在某个方面劣于一般人。</li></ol><p>第二个角度：从内向外向来分析</p><p>外倾/内倾：外倾倾向于描写别人，内倾倾向于描写自己<br>个人的/心智的：“个人的”倾向于描写外部特征，如动作、事件、语言等，“心智的”倾向于心理描写</p><p>百科全书式的作品是糅合了4个角度的中庸之作，也是最丰富的作品（网文应该都算百科全书式的？）</p><h3 id="小说的虚构与真实"><a href="#小说的虚构与真实" class="headerlink" title="小说的虚构与真实"></a>小说的虚构与真实</h3><p>小说把虚构的写成真实的，这种倾向是小说的本质需要。人们从小说中感受喜怒哀乐，必定先要认可其为“真实的”，小说虚构的成分尽可能接近真实，但本质依然是虚构。小说的本质就是“不像小说”，因此无法用某些特质来区分它，小说本身也就难以定义。</p><h3 id="创造可信的陌生化"><a href="#创造可信的陌生化" class="headerlink" title="创造可信的陌生化"></a>创造可信的陌生化</h3><p>小说中一种套路用得多了，就会被读者记住，从而丧失新鲜感，而由此诞生出反套路作品。在这个现象背后是技巧的陌生化。然而陌生化伴随着真实性的丧失，如何维护真实性，斯克罗夫斯基给出三种方法。</p><p>第一种是为非同寻常的描写找到合理的原因。我的理解是聚焦于一些特定的“有故事的”人群。例如流浪汉、水手、旅行商等等。他们因为自己的身份而旅行，从而可以得到更多有意思的故事。</p><p>第二种是依靠人物的选择来陌生化。为了让人物到新的地方去，<strong>作者可以选取那些在不同阶层生活的人物，如仆人，落魄贵族</strong>，也可以强调人物内心的成长。人物内心的喜好变化以后，他们自然会找到新的故事。</p><p><strong>假设作者意在非常之事，作者的人物就仅是一条线索；假设作者想要日常世界陌生化，那么这一世界就必须落入非常人的眼中，如局外人、疯子、先知，他们可以证明那些自然的东西实际上是惯例的，或不合逻辑的</strong></p><p>第三种方式是在虚构作品中再现社会现实。如在小说中呈现书信、回忆录、传记等。或者直接把小说本身伪装成类似的东西，让读者分辨不出来。</p><p>叙事作品并非要使得世界陌生化，<strong>而是试图找到一种陌生的方式谈论世界</strong>。</p><h3 id="小说话语的冲突"><a href="#小说话语的冲突" class="headerlink" title="小说话语的冲突"></a>小说话语的冲突</h3><p>每一种语言看到的现实是不一样的，不同语言使用者有不同的知识、利益、态度，他们的语言用不同方式描述这个世界。</p><p>一个世界中，互相争鸣的语言各自代表自己描述世界，作者可以选择用从单一语言的角度看待“多音齐鸣”，也可以不偏向任何一方地描绘出多音齐鸣，这种小说允许角色的话语与作者本身的话语相冲突。</p><p>另外，小说中不同话语冲突的现象揭示出道德的虚无性，同一个行为在不同群体眼中看来是冲突的，道德与不道德叠加在一起，不存在一个绝对的道德体系能够考虑到所有群体的利益，所以冲突和矛盾总是存在。</p><h2 id="从现实主义到成规"><a href="#从现实主义到成规" class="headerlink" title="从现实主义到成规"></a>从现实主义到成规</h2><h3 id="现实主义"><a href="#现实主义" class="headerlink" title="现实主义"></a>现实主义</h3><p>概括地说，现实主义是客观的、从典型题材出发的、强调因果联系的一类文学作品。</p><p><strong>客观性</strong></p><p>现实主义要求客观地再现事实。其一，作者应当压制自身的个性和叙述声音，<strong>力求将自己虚构的世界当作真实世界记述</strong>。其二，现实主义排斥幻想、神话，其目的在于通过客观地再现现实，为社会底层人民发声，揭示社会黑暗丑陋处，戳穿粉饰的太平。</p><p>我认为作者的态度是无法避免的，幻想中的世界有无穷无尽的视角，作者选取什么人的视角描述，又选取什么事件、物品描述，这都是充满主观性质的。作者总是带着这样或那样的目的来写作，倘若让故事变得有趣，那么作者既要照顾真实性，又要以某种视角呈现故事。</p><p><strong>典型性</strong></p><p>现实主义既要记录现实，由要避免太过平凡的记录，为了达成这个平衡，折中的办法是选择典型的人物来描述。<strong>黑格尔认为一个完整的性格是引发兴趣的根源</strong>，而完整的性格需要普遍的力量和个人的特殊性融合在一起。现实主义小说写一个人就是写一类人，由小见大。</p><p><strong>历史性</strong></p><p>现实主义小说需要将人放在一个政治、经济、社会的总体现实之内，要求小说中的世界能够像客观世界那样辩证地发展，即由一个形态过度到另一个形态，而描绘出中间那种演变着的社会。</p><p>我认为，作者的引导应当被巧妙地掩饰起来。构造一个暗藏矛盾的社会、让人物替作者选择，总之，情节的转变需要一个“必然”的解释，它不能是刻意的、人工的，而是必然的、自然的。</p><h3 id="程式化的现实主义"><a href="#程式化的现实主义" class="headerlink" title="程式化的现实主义"></a>程式化的现实主义</h3><p>这个标题比较有意思，现实主义声明自己是现实的直接记述者，而现实应当是没有程式化的。但是从观察现实到记述现实，中间必然经过一些选择，这就导致了现实主义的真实性受到质疑。</p><p><strong>非本质性细节</strong></p><p>如果从剧情的角度看，无意义的情节必然导致剧情的涣散。这本是应该避免的，但如果每个事件都有对应，那么整个故事看起来就太过刻意了。因此，一些现实主义作品总是会写些无意义的对话，以削弱故事人工雕琢的痕迹。<strong>我认为这并不是削弱世界本身的人工痕迹，而是削弱了选择性记述的痕迹</strong>，这必然是以情节的涣散为代价的。</p><p><strong>事出有因</strong></p><p>现实主义作品强调因果关系。这种因果关系要求作者用先前的种种细节暗示某个关键的选择有必然性，这是一种从后向前的构造方式。但非本质性细节与这个要求冲突，倘若所有细节都是为之后的必然作铺垫，那么这些细节就不是无关紧要的了。非本质性细节实际上是从历史构造未来的过程。这两种方式是相反的，也是互相矛盾的，可它们却共同增强了事情的可信性。</p><p>有趣的是，现实这一被所有现实主义作品临摹的对象，本身却不一定是事出有因的，许多报纸上记述的离奇事件，如果放在小说里，恐怕是不能让人信服的。我认为人的“信服”并非是一个绝对的标准，因果关系也并非是越严密就越现实，人对真实的判断是从现实提炼出来的，人对小说的判断又是以对真实的判断为根据的，这三者的递进关系使得小说的真实感不等于小说贴近现实的程度。也就是说，<strong>越贴近现实的小说不一定是越看起来真实的小说</strong></p><h3 id="结构主义"><a href="#结构主义" class="headerlink" title="结构主义"></a>结构主义</h3><p>结构主义者寻找各种让小说“自然化”的结构。</p><p><strong>实在者</strong></p><p>人固化在思维里的基本认知，如自然现象、人的身体、头脑、感情</p><p><strong>文化逼真</strong></p><p>人在社会活动中有许多固定模式，如高兴的表现、愤怒的表现、虚荣的表现，这些是个人脚本。如看电影遇到的情况、去朋友家问候碰到的情况，这些是处境脚本。约会需要做的事、早上起来洗漱需要做的事，这些是达成某个目的所用手段的脚本。</p><p>这些脚本在提及开头时，读者就可以联想到之后的东西。同理，如果小说中的事件按照脚本发生的话，所写的东西也就更加真实。</p><p>我认为，脚本是现实生活中相对固定的东西，它们是作者与读者的共有知识。但太过依照脚本反而会削弱真实性，如现在的恋爱喜剧的套路化，就是因为大量陈旧脚本的反复利用。简单地来说，<strong>作者使用与读者共同的语言，但不一定每次都要讲同一个故事</strong></p><p><strong>虚构性</strong></p><p>读者认为小说是真实发生的还是虚构的，似乎对于读者代入的效果没有太大影响。</p><p><strong>暴露其他作品的人为性</strong></p><p>这有点像是指认别人是凶手的人看起来更不像是凶手，在小说中暴露其他小说的虚构之处，更能体现出自身的真实性，另外，一般的读者很少想象到小说中的小说，这也是自然而意外的东西。</p><p><strong>成规性</strong></p><p>尽管当前许多作品标榜自己是反套路的，但并不存在一种作品能真正地完全摆脱套路。这并不是能力不足的问题，而是不能而且没有必要。作者在选择性叙述的时候必定有着选择的规则，就是套路，反套路创造新颖的形式，但是并不比套路本身更加接近本质。相反，历史中许多叙述都是套路化的，这并不改变他们忠于现实的身份。所以套路与真实并不是矛盾的东西，是否反套路需要依据读者的感受来判断。</p><h2 id="叙事结构"><a href="#叙事结构" class="headerlink" title="叙事结构"></a>叙事结构</h2><h3 id="非传统结局"><a href="#非传统结局" class="headerlink" title="非传统结局"></a>非传统结局</h3><p>传统的情节要求有开头、发展、高潮、结尾。但结尾并不是固定的，实践表明小说可以在不更改前面叙述的情况下替换结尾，即是说结尾并不是情节的基本组成单位，而是可有可无的，依照惯例被创造出来的东西。</p><p>开放式结局就是对传统结局的挑战，可以是一段对天气的描述、一段历史名人名言，但不点出主要人物后来的情况。</p><h3 id="克默德的情节"><a href="#克默德的情节" class="headerlink" title="克默德的情节"></a>克默德的情节</h3><p>克默德提出情节的三大特性：时间性、因果性、叙述成规</p><p>时间性是指情节需要有变化，不能是一副固定不变的图画，而应该是流动的。因果性是指情节中的各个事件有内在关联，而这些关联需要在故事中被明确地展示出来。叙述成规是指叙述的事件需要在读者的理解范围内，且不与读者所生活的时代的知识相冲突。</p><p>个人观点：很多小说开头描述一副图画，然而静态的图画是不吸引人的，无论图画被文字描写得多美。文字停下来描写图画的时候，情节就暂时失去了时间性，大段的心理描写就不会吸引人，但停止的文字有助于因果性的构建，单单是事件的陈列并不能构建情节。文字流动起来的时候，时间性被赋予了，因果性减弱了。</p><p><strong>在文字停下来的时候赋予因果性，在文字流动的时候赋予时间性</strong>，这样才能避免情节的消失。但与此同时，还要照顾到读者对时间的感知，<strong>时间尺度剧烈变化导致失真感，时间尺度缓慢变化导致平庸的情节过于聚集</strong></p><h3 id="普罗普的民间故事分析"><a href="#普罗普的民间故事分析" class="headerlink" title="普罗普的民间故事分析"></a>普罗普的民间故事分析</h3><p>民间故事通常由如下环节构成：</p><ol><li>坏蛋给家庭中的一员造成伤害/家庭中的一员缺少或渴望得到某物：<strong>以身犯险的原动力</strong></li><li>不幸或缺乏真相大白：<strong>时间性，矛盾加剧</strong></li><li>英雄接受请求，获准去或受到派遣：<strong>给予出发预期</strong></li><li>寻找者同意，进行准备，英雄离家：<strong>出发场景刻画</strong></li><li>英雄接受考验，为将来的助手作准备：<strong>突破险境的必要伏笔</strong></li><li>英雄与坏蛋直接交手：<strong>高潮预期</strong></li><li>英雄受辱，受到助手帮助，坏蛋被消除，原先目的被达成：<strong>预期挫折</strong></li><li>英雄归去，但未被承认：<strong>真正的挫折</strong></li><li>困难的任务被交给英雄，英雄完成：<strong>对众人承认的铺垫</strong></li><li>英雄被承认，坏蛋受到惩罚：<strong>众人承认，预期实现</strong></li><li>英雄完婚并登上王位：<strong>真正实现</strong></li></ol><p>这个故事包含了一般历险小说的基本构成。个人倾向于用因果关系和预期来分析。</p><p>首先大多数读者心中是有一个<strong>简单预期模型</strong>的，挑战困难时一定会遇到挫折，但挫折后一定会胜利，最后也一定会得到好处。困难-挫折-胜利-奖励，这是利益驱动的链条。但从因果关系来说，并不合理。</p><p>首先主角只能是一个个体，这是读者自身代入所决定的。英雄历险必须有原动力，如果只是为了奖励，则太过拜金了，所以必须给予一个“大义”的名分。得到大义以后，为了迎合出发预期，并突出紧张气氛，需要刻画一个准备过程。旅途开始后，是埋下伏笔的情节，这是为了给英雄最后战胜困难提供助手，而且让助手有理由帮助英雄。然后是高潮预期，在读者原定的预期模型中，故事显然要超过它，于是每一个环节都有虚假的、用来迎合读者的环节和真正的、引起读者兴趣的环节。</p><p>例如挫折，就有预期的挫折和真正的挫折。胜利，有预期的胜利和真正的胜利。这样一来，一个简单的但是有效的模型就构建完成了。</p><p>英雄的社会影响，是人对社会的预期所决定的。<strong>为了得到众人承认，就必须先刻画众人反对</strong>，于是英雄解决真正的困难后还需要再受到一次历练，其中就可以穿插众人反对的情节。</p><h3 id="个人观点：情节推动的主动与被动"><a href="#个人观点：情节推动的主动与被动" class="headerlink" title="个人观点：情节推动的主动与被动"></a>个人观点：情节推动的主动与被动</h3><p>我将推动情节发展的“原动力”在小说中的载体分为“获得奖励”和“解决困难”，前者是从历史出发的、单一源促进的、由人物主导的发展方式；而后者是从结果出发的、多因素共同作用的、由环境主导的发展方式。</p><p>主动式的获得奖励是常用的桥段，比如：家人受到重伤，必须要到十余里外的荒山上采集草药才能救治。这就给主角前往历险的源动力。这种写法的好处在于，不必推敲主角是否有其他途径，因果解释非常简洁正确。但缺陷在于，这种“必须”的要求可能太过刻意，而且主角为何能先验地知道得到目标后就能解决问题，这要么引入第三方，要么写成“传言”，无论何种情况都是比较人工的。</p><p>被动式的解决困难的典型桥段为：主角为了解决困难，提出一个方案，然后在实施方案的过程中遇到了新的困难，最终以方案的顺利实施/失败告终。被动式与主动式的区别在于，主角当前倘若毫无作为，必定会陷入困难中导致失败，而解决困难的方法往往只有几条，可获取奖励的方法可以有无数个。主角在思考方案时，一定要得到最优的或近似最优的，不然读者就难以代入主角的立场。</p><p>情节中主动和被动的推动都是必要的。没有主动推动的话，人物一旦没有困难，就会在某个地方驻足不前（如情节的缓和处），没有被动推动的话，客观世界就无法对人物进行限制，此时人就被神化了。</p><h2 id="叙事结构，各种方法的比较"><a href="#叙事结构，各种方法的比较" class="headerlink" title="叙事结构，各种方法的比较"></a>叙事结构，各种方法的比较</h2><h3 id="故事的剖析：原材料和加工方式"><a href="#故事的剖析：原材料和加工方式" class="headerlink" title="故事的剖析：原材料和加工方式"></a>故事的剖析：原材料和加工方式</h3><p>故事本身的写作是线性的，然而实际发生时间是非线性的，可以是树状的、网状的，等等。如果假设任何故事都能还原到实际发生的，以时间为顺序的特定拓朴结构上，那么这个结构就是故事的原材料。作者用不同的技法、视角和顺序来书写故事，这些是故事的加工方式</p><h3 id="人物"><a href="#人物" class="headerlink" title="人物"></a>人物</h3><p><strong>平面人物与立体人物</strong></p><p>我对两者的区分为：平面人物是静止的、只有一面的人物，而立体人物是动态的、会变化的、与虚构世界充分交互的多面人物。显然平面人物比多面人物更有意思，然而一部小说不可能所有人物都是多面人物。</p><p><strong>立体人物需要其他人物的衬托，并且还需要花费大量笔墨描写人物本身</strong>，显然，如果要塑造立体人物A，就得引入与他相关的人物B,C,D，为了塑造立体的B,C,D又得引入B1,B2,B3,C1,C2,C3…这样发展下去，永远不可能让所有人物都是立体的。</p><p><strong>平面人物的有趣体现在他们处于某种复杂的不可避免的联系中</strong>，平面人物若是独立在情节之外，则会过于单薄，而处于情节本身的平面人物也是有趣的。有趣不仅体现在人物的立体上，还体现在人物与环境的交互上。</p><p><strong>人物与行动</strong></p><p>人物与行动是整体，是动态联系的。最初，人物又行动所确立起来，但人物会思考、会交互、会探索、会萌发欲望，此时之前的行动就变得鲜活起来，进而对后续的行动产生规定。人物活在小说中，但立体的人物活在虚构的世界中。<strong>立体的人物同时受写出来的和没写出来的虚构事实所影响</strong>，这些事实像是构成人物的冰山下部，而人物是冰山上部。小说只揭露了虚构世界的一角。</p><p>人物并非单一地被行动塑造，人物自身对过去的理解也决定了其对未来的抉择。即使是同一种历史，人物的性格使得其对历史的理解不同，由此，<strong>人物拥有独立于情节的自由度</strong>，这一自由度是由作者来设定了，当然，它也是会随着情节变化而动态变化的。</p><h3 id="描写和行动"><a href="#描写和行动" class="headerlink" title="描写和行动"></a>描写和行动</h3><p>描写和行动有时是无法区分的，我觉得，好的描写应当是灵活地静止或运动的，即可以做到一边推动情节发展，一边进行描写，而且这种方式往往很有趣。</p><h3 id="叙事的时间性"><a href="#叙事的时间性" class="headerlink" title="叙事的时间性"></a>叙事的时间性</h3><p><strong>视点</strong></p><p>视点包括三个东西，距离，指描写的详略，从视点出发，越远的东西描写就应该越省略。视角，即透过谁的眼睛来看。声音，即叙述者的身份、地位决定的文字色彩。</p><p><strong>时间</strong></p><p>比较容易忽视的是叙述次序：人物可以回顾过去（闪回），也可以想象未来（闪前）</p><p>关于时间次序，个人认为时间的断裂和分割是需要掩饰的，不然会造成真实感的崩塌。<strong>一个技巧是可以用闪回掩饰时间的间断</strong>，更普遍地说，用时间的一段突变（闪回，闪前）掩饰真正的另一段突变（时间的省略）。<strong>也可以用心理描写来加快外部时间的流逝</strong></p><h3 id="意料之外，情理之中"><a href="#意料之外，情理之中" class="headerlink" title="意料之外，情理之中"></a>意料之外，情理之中</h3><p>读者在阅读小说时，其实不光向前预测，还在向后总结。整个阅读过程就是不断预测、不断总结的过程。意料之外就是在读者预测时，无法预测到这个结果，而情理之中是读者在回顾时，又可以发现结局的趋势。</p><p><strong>偶然事件与趋势</strong></p><p>塑造这种结局的办法之一就是先给出趋势，然后在看似平淡的叙事中插入偶然事件。比如先塑造一个坏人，然后他在某一天突然出车祸，而车祸的原因与他之前犯下的恶行有关。这就是“善有善报，恶有恶报”的趋势引导的结果。</p><p>其他的趋势，比如讽刺（自傲者最终一无所有、执着而放弃一切的人最终必然达不到目标），比如实践改变本质（战争只能播下仇恨的种子），比如传统的奋斗观、平等观，这些更多地是为了传递作品主旨。</p><p><strong>情节的不可预测性</strong></p><p>为了制造偶然事件，就需要利用情节的不可预测性，让读者事先猜测不到结果。情节在<strong>发生点</strong>上是不可预测的，就比如一场实验很多地方都可以出错，但至于哪个地方开始出错，是作者来把握的。情节在<strong>发生方式</strong>上也是不可预测的，比如实验可以以某种看似正确的方式完成，最后分析时才发现一切都要推倒重来。</p><p>情节可以是混沌的，<strong>发生趋势不可预测</strong>。一个小小的火花就可能引爆一个大事件，而何时埋入这不起眼的火花，又是否让它变成大事件，这也是作者自己来掌握的（一个例子，教师不正确的教导方式，让多年后的一个孩子以悲剧结束自己的一生，这个情节中，原先错误的小“火花”被放大，而谁是火花，谁最后产生悲剧，这是读者无法预测的）</p><h2 id="视点"><a href="#视点" class="headerlink" title="视点"></a>视点</h2><p><strong>第一人称和第三人称叙事的弊端</strong></p><p>这两种人称叙事方法都有弊端，第一人称叙事虽然有真实感，但是只能叙自己看到的、听到的，对自己视野之外的东西无法掌控。</p><p>第三人称叙事虽然可以灵活改变，但是最大的缺陷是缺乏真实性。</p><p><strong>第三人称有限视点</strong></p><p>第三人称有限视点作为开创性的叙述方法，可以避免上述两种方法的弊端。这个方法以如下的方式叙述：</p><ol><li>叙述者作为“附在主角身上的目击者”讲故事，不评论，不使用代词“我”（心理描写时也是如此）</li><li>叙述者只能走进主角的内心，只能写主角的心理。</li><li>叙述者看到的也只是主角看到的</li><li>尽可能以描述代替概括，叙述者本身是透明的，不带任何观点</li><li>声音：叙述者以谁的视角叙述，就应该用谁的声音（？）</li></ol><h2 id="元虚构"><a href="#元虚构" class="headerlink" title="元虚构"></a>元虚构</h2><p>元虚构打破了虚构与现实的界限，在元虚构作品中，人物认识到自己处在虚构的世界中，且他们意识到自己被某个外部的“现实世界”关注着，由此产生与读者或是作者的直接互动。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小说</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【写作】小说表现力的几点思考</title>
    <link href="/2021/02/01/%E3%80%90%E5%86%99%E4%BD%9C%E3%80%91%E5%B0%8F%E8%AF%B4%E8%A1%A8%E7%8E%B0%E5%8A%9B%E7%9A%84%E5%87%A0%E7%82%B9%E6%80%9D%E8%80%83/"/>
    <url>/2021/02/01/%E3%80%90%E5%86%99%E4%BD%9C%E3%80%91%E5%B0%8F%E8%AF%B4%E8%A1%A8%E7%8E%B0%E5%8A%9B%E7%9A%84%E5%87%A0%E7%82%B9%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h1 id="小说的表现力"><a href="#小说的表现力" class="headerlink" title="小说的表现力"></a>小说的表现力</h1><h2 id="概括词与描述词"><a href="#概括词与描述词" class="headerlink" title="概括词与描述词"></a>概括词与描述词</h2><p>我将词语分为两类，一类是用来帮助人理解事物的，叫作概括词。例如感情（高兴、悲伤、疑惑、难受）、抽象动作（防御、攻击、写字、画画）、抽象描述（开始、结束、准备、暂住、统治、灭亡）、概述（图书馆、建筑师、职业、性能、等级、优劣）</p><p>相对地，另一类词是客观事物的直接反映，叫作描述词。例如大部分形容词、副词、简单的动作（走、跑、跳），以及颜色、气味、明暗等。</p><p>原则上，概括词只能用在帮助读者理解和简化叙述两个目的上。<strong>初次描述和重点描述的文段是不可以出现大量概括词的</strong>，如写感情，不能写概括词，只能用语言、动作、神采来暗示。尽管很麻烦，但是这才是概括词背后的内涵所在。</p><p>一些时候，如作者希望读者理解的时候，或者是需要详略折中的时候，就可以用概述词来替代，但相对地，<strong>概述词只能体现读者经历过的事情，本身是不蕴含任何新的信息的</strong></p><h2 id="详略"><a href="#详略" class="headerlink" title="详略"></a>详略</h2><p>一般场景上，相同处平凡处略写，不同处新颖处详写，是大体的规律。小场景详略取决与是否与剧情有关，是否需要大量笔墨来产生“<strong>时间停滞</strong>”的感觉。</p><p>大场景上，详略需要穿插来保证真实性。大量概括词虽然能快速推动剧情发展，但是概括词太过不真实而且没有新信息，很容易读起来厌倦。而且要避免概括词导致时间流速变快，产生严重的脱线感。</p><h2 id="剧情推动"><a href="#剧情推动" class="headerlink" title="剧情推动"></a>剧情推动</h2><p>严格地说，一段剧情是由其之前的剧情和作者的构思共同决定的。</p><p>对于新的行动，<strong>要考虑到角色是否有足够的理由行动，或是否有足够的理由不行动。</strong>，对于新的遭遇，<strong>要考虑到遭遇是否有一定的必然性、是否与逻辑圆合</strong>，对于语言、态度，需要从角色性格入手，<strong>而角色性格又是由角色的遭遇塑造的</strong></p><p>作者可以从客观上控制剧情，在一个展开中，<strong>作者能绝对控制的也只是世界的物质部分、无机部分</strong>，而人的交互是由角色本身对无机世界的反映构成的，包括对世界规律的反映。</p><h2 id="跌宕起伏"><a href="#跌宕起伏" class="headerlink" title="跌宕起伏"></a>跌宕起伏</h2><p>过于普通的剧情让人失去耐性，过于激烈的剧情让人感觉没有逻辑性，<strong>关键在于：每个事件都有一个正常的开始，一个跳出读者预期、但是在接收范围内的结束，以及由此衍生出正常的新的事件</strong></p><p>为了加入新的冲突，可以偶尔给出完全出乎意料的事件，但这会严重降低真实性，要么让出乎意料的事件发生在开头，这样整体来看真实性不断上升，就没有下降的可能；要么借用人物之手来刻画冲突，即利用人物的不确定性来覆盖事件的刻意加入。</p><h2 id="微观上的丰富"><a href="#微观上的丰富" class="headerlink" title="微观上的丰富"></a>微观上的丰富</h2><p>在一两句话的阶段上，细节上的丰富有固定的处理模式：</p><ol><li>先展现局部、再展现整体。即给出足够的信息描述事件A，最后点出事件A，相当于一个小型推理过程。</li><li>直接用B代替A描述，读者在阅读中自然理解B就是A。让直白的信息委婉化，委婉的场景就适合委婉的文字表达</li><li>先描述影响，再描述主体，即未见其人先闻其声，这是微观上的描述。扩张到宏观上就是侧面描写。</li><li>利用预期之外又合理的东西营造真实感，描写当前场景的意想不到的细节，传递新信息。</li><li>控制详略，使得实际事件与阅读时间同步，有利于读者的无缝代入</li><li>控制详略，有节奏地传递新信息</li></ol><h2 id="剧情在宏观上的处理手段"><a href="#剧情在宏观上的处理手段" class="headerlink" title="剧情在宏观上的处理手段"></a>剧情在宏观上的处理手段</h2><p>在篇章的结构层次上，有一些塑造手法：</p><ol><li>剧情侧面烘托，用来营造压迫感、恐惧感</li><li>细节反转，即可以诱导读者理解为A，但伏笔都指向的B，最后结果揭晓实际是B，用来营造懊悔感、失落感</li><li>跳脱常规，即反套路。</li><li>保持新奇感，这部分的内容参考其他几篇blog</li></ol>]]></content>
    
    
    <categories>
      
      <category>写作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小说</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【写作】小说与视觉场景的表现力差异</title>
    <link href="/2021/02/01/%E3%80%90%E5%86%99%E4%BD%9C%E3%80%91%E5%B0%8F%E8%AF%B4%E4%B8%8E%E8%A7%86%E8%A7%89%E5%9C%BA%E6%99%AF%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%8A%9B%E5%B7%AE%E5%BC%82/"/>
    <url>/2021/02/01/%E3%80%90%E5%86%99%E4%BD%9C%E3%80%91%E5%B0%8F%E8%AF%B4%E4%B8%8E%E8%A7%86%E8%A7%89%E5%9C%BA%E6%99%AF%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%8A%9B%E5%B7%AE%E5%BC%82/</url>
    
    <content type="html"><![CDATA[<h1 id="小说与视觉场景的表现力差异"><a href="#小说与视觉场景的表现力差异" class="headerlink" title="小说与视觉场景的表现力差异"></a>小说与视觉场景的表现力差异</h1><p>一般地，这里定义视觉场景为：一个人亲身经历过的事情，主要的记忆是视觉记忆、听觉记忆。在不同情况下，小说和视觉场景的表现力是有差异的。</p><h2 id="画面的直接体现力"><a href="#画面的直接体现力" class="headerlink" title="画面的直接体现力"></a>画面的直接体现力</h2><p>画面的直接表现是小说的弱势，例如恐怖图片、战争场面，这些都难以用文字描述。一些必须要描述的场景，也是通过文字唤起人的想象力，而从想象力中赋予感觉。</p><h2 id="复杂的构图"><a href="#复杂的构图" class="headerlink" title="复杂的构图"></a>复杂的构图</h2><p>小说是文字的，难以直接体现复杂的构造，例如一张工程图，就无法用纯文字描述。更广泛些，较复杂的空间，如场景的布置、建筑的描述，也很难用文字流畅地写出来。</p><h2 id="人物心理"><a href="#人物心理" class="headerlink" title="人物心理"></a>人物心理</h2><p>心理是小说表现力优于视觉场景的一大方面，因为文字直接体现思想，所以复杂的心理活动都可以被文字流来体现出来</p><h2 id="快节奏打斗"><a href="#快节奏打斗" class="headerlink" title="快节奏打斗"></a>快节奏打斗</h2><p>这个方面应该是平分秋色的，对于画面而言，显然打斗可以做得很精彩，但是缺陷在于信息量太大，看完也就看个痛快，里面的细节很难注意到。而小说可以把细节全写出来，如何见招拆招、如何看准时机，更多地体现打斗中智斗的部分。</p><h2 id="音乐与情感"><a href="#音乐与情感" class="headerlink" title="音乐与情感"></a>音乐与情感</h2><p>音乐能直接推动人的情绪，但遗憾的是，文字几乎无法利用音乐，因为描述音乐的文字太单薄了，正常人缺乏直接的感觉，所以无法唤起感性认知</p><p>小说中表现情感，要么透过具象化，描述一种让人喜悦的东西，要么通过语言、心理描写来达到。或者是直接写个笑话，将文字当作刺激物本身来引发情感。</p><p>小说中，<strong>用人物的动作，语言，环境的变化来突出情绪</strong>，情感是概括词，不是表现词。概括词只能起到理解的作用，但不能起到刻画的作用，要时刻注意。</p>]]></content>
    
    
    <categories>
      
      <category>写作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小说</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【写作】关于各种各样的异世界小说的笔记</title>
    <link href="/2021/01/30/%E3%80%90%E5%86%99%E4%BD%9C%E3%80%91%E5%85%B3%E4%BA%8E%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E5%BC%82%E4%B8%96%E7%95%8C%E5%B0%8F%E8%AF%B4%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/01/30/%E3%80%90%E5%86%99%E4%BD%9C%E3%80%91%E5%85%B3%E4%BA%8E%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E5%BC%82%E4%B8%96%E7%95%8C%E5%B0%8F%E8%AF%B4%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近一段时间总觉得自己要有一个兴趣爱好，对音乐绘画之类的自觉没有天赋，想来想去感觉比较可行的爱好也就是写作了，所以开始读网文，希望能从中借鉴/收获一些有价值的东西。</p><h1 id="开头：反常现象与谜题"><a href="#开头：反常现象与谜题" class="headerlink" title="开头：反常现象与谜题"></a>开头：反常现象与谜题</h1><p>周明瑞照镜子，发现自已太阳穴上的伤口那段是我第一次被吸引到的。开始的“头痛”确实也是反常现象，但比较常见。而从手枪到血迹，再到照镜子这个桥段，自己开枪自杀的事实在最后把前面的东西串联起来了。然后是更奇异的反常现象：为何自己不会死，又为何自杀等等。包括当时的环境，一切都显得特别让人迷惑。</p><p>幽灵船，一艘能自我修复、不需要船员的船只，也是很反常的东西。先前提及的“水手”之力，交代完背景后，用打斗中的细节告知阿尔杰就是水手，这种简单的推断效果却很好。</p><h2 id="不是做了什么，而是看起来做了什么"><a href="#不是做了什么，而是看起来做了什么" class="headerlink" title="不是做了什么，而是看起来做了什么"></a>不是做了什么，而是看起来做了什么</h2><p>小说感觉像文字版的电影一样，可以充当虚拟世界的摄像机。然而文字的功能太过强大，有时候对动作的描写会直接从作者视角出发，而不是从角色看到的东西转译出来，这样的文字就丧失了趣味性。文字虽然描写了动作、语言、神态，但这些都是透过角色的眼睛、耳朵所得到的，角色不理解的地方读者就不能理解。<strong>文字应当从低级的画面构造出高级的意义，若非必要，不会用高级的意义概括低级的动作</strong></p><h2 id="外貌、言语、动作"><a href="#外貌、言语、动作" class="headerlink" title="外貌、言语、动作"></a>外貌、言语、动作</h2><blockquote><p>长沙发正中坐有一位女士，她穿着戴兜帽的黑袍，涂抹着蓝色的眼影和腮红，露在外面的手腕处缠绕着挂有白水晶吊坠的银链。</p></blockquote><p>描写顺序就是按照从粗犷到细致，从一般到特殊的顺序。注意，年龄、神态等在这里不重要，而刻画通灵者的身份是主要的，所以描写有侧重。</p><p>值得注意的是，为了让画面更加鲜活、对话更加有场景感，需要用文字营造一种陌生的感觉。<strong>在对话中插入难以联想到的环境描写，可以丰富信息量，让整个场景更加真实</strong></p><h2 id="心理"><a href="#心理" class="headerlink" title="心理"></a>心理</h2><p>把乏味的对话写丰富就要穿插心理描写，一长串的让人感到有固定模式的对话肯定是难以读下去的。同时角色想到的事情也会为接下来的行动给予一个契机</p><h1 id="异世界的习俗"><a href="#异世界的习俗" class="headerlink" title="异世界的习俗"></a>异世界的习俗</h1><p>如何让异世界融入生活，我想这是最难表现的部分。就比如，异世界有一种草药，不妨叫夜香草，一般在夜里散发香气，有愉悦精神的功能。如果直接写“需要采集这种草药”，那么这个设定看起来就会比较突兀。如果从草药的特点出发，写某种装饰物的组成成分正好是这种草，那么就能体现草药在异世界中被广泛利用，更好地融入设定中。</p><p>与现时代不同的东西必然造成与现时代不同的影响，抓住异质的东西描写，才能表现出真实的异世界。工作、生存、娱乐、休息，这些事情是构成丰富的生活的各个部分，在塑造一类群体的时候，需要考虑他们为何存在、以何种形式存续这些。</p><p>除了当前的现实，过去的经历、历史的传说故事都需要叠加起来，还需要考虑自然地理对文化的影响这些。人的存在也并非静止的，人有着各自的愿望、爱好，对事件有自己的想法，同时人与人之间有差异，严重的差异导致对世界的认知不同，这些都是应当考虑的。</p><p>考虑非主角的主观能动性。房子会翻修、城市会没落、天气会变化、物品会损旧，应该尽量刻画一个动态的世界，主角之外的地方依然是会变化的，主角看不见的地方依然存在着某些人或事，他们与主角的联系或隐或现。</p><h2 id="异世界元素构成以及缺陷"><a href="#异世界元素构成以及缺陷" class="headerlink" title="异世界元素构成以及缺陷"></a>异世界元素构成以及缺陷</h2><p>原文：<a href="https://zhuanlan.zhihu.com/p/43566526" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/43566526</a><br>原文是写的很好的一篇文章。</p><p><strong>种族的固定性</strong></p><p>通常来说，人族生存在平原，一般为农业或初级工业国，精灵生存在森林，设定为长寿、善用弓箭和魔法，矮人生存在山脉地下，设定为擅长制造武器。魔族生存在边陲地域，通常是君主制。亚人一般生存在人族王国的附近。</p><p>那么问题在于，如何突破传统框架，找到新的生态位，进而构造新的种族？又如何解释人魔斗争的原因？如何解释魔族在边陲却依然有强大的战斗力？</p><p>进一步的，各个种族如何生存，魔物占据何种生态位，这些问题大都是黑箱化的。</p><p><strong>地下城</strong></p><p>地下城一般有核心，依靠核心生长。地下城中有宝物，有无数的魔物，但如何解释地下城为何有宝物？地下城的魔物如何进食？地下城的魔物为何杀不尽？地下城又为何从浅到深，魔物等级逐渐升高？</p><p>这个设定很难自圆其说，因为有太多人工成分，无法用自然的方式基于解释。</p><p><strong>国家</strong></p><p>通常设定：地理环境恶劣造成的生产低下处在战争边缘的严酷国家，凭借强大力量产生征服野心的战争国家，在信仰控制方面的领导地位的宗教国家，在魔法或冶炼锻造方面占有优势的技术领先国家，重商且左右物流流通但寻求中立的商业国家</p><p>不足在于，异世界的政治通常比较幼稚和老套，远不及真实世界的复杂</p><p><strong>经济、制造业、服务业</strong></p><p>经济主要是：货币制度（货币铸造、货币兑换、购买力），经济中心（物流、物资倒卖、采购、原材料的加工处理），商人工会、行商。</p><p>商人公会：身份证明、贸易优惠、贸易垄断、经济纠纷、状态系统（借由公会卡给出冒险者的当前状态）</p><p>制造业：工匠、矿业（问题：矿石的精炼是如何做到的？冶炼工序？<strong>混淆了矿石和金属锭</strong>）</p><p>服务业：草药店，服装店，生活制品店（玻璃、陶瓷、肥皂、沐浴露），酿酒行业</p><p>经营模式：师傅+学徒的模式。</p><p><strong>文化</strong></p><p>语言问题：异世界的语言究竟与现实世界有何种不同？难以解释</p><p>娱乐：棋类、牌类</p><p>纸质品：出版业、绘本</p><p>其他工艺品：雕塑、绘画、音乐</p><p><strong>教育</strong></p><p>与现实世界基本相同，比较共同的是：魔法考试、剑术训练（比赛）、图书馆中的神秘书籍</p><p>社会歧视：血统论、实力论、种族论、帮派论</p><p><strong>冒险者公会</strong></p><p>冒险者等级、经济制度（击杀怪物给予奖励），社交功能（酒馆），任务分派，新人教育（组队、训练）</p><p>建筑：公会建筑、柜台、食堂、酒馆、升级相关、原材料交易相关、任务相关（看板、柜台），信息交流相关</p><p>超国家团结作用：冒险者工会在每个地方都是一样的</p><p><strong>宗教</strong></p><p>教会：职务（主教、牧师），治疗功能（治疗药水），宗教功能（发起战争、仪式、宗教与资本的肮脏交易、种族净化主义），圣骑士（宗教军队），孤儿所（社会援助）</p><p>神明：实体神（能对世界产生干涉且能被打败）、非实体神（能干涉，不能打败）、幻想神（实际并不存在）</p><p>多神制：属性神（地水火风）、种族神（人兽魔）、国家神（庇护国家）、世界神（多世界）、概念神（爱神、酒神、剑神）</p><p>神的干涉：维护世界秩序、给予加护</p><p><strong>实力系统</strong></p><p>直接分级法：字母分级、文字分级</p><p>种族分级法、职业分级法</p><p><strong>奴隶制</strong></p><p>金手指，奴隶纹章</p><p>奴隶身份：犯罪奴隶、人口贩卖、种族问题、冒险敢死队、欠债奴隶、契约奴隶</p><p>反歧视：反亚人歧视、反奴隶制</p><p><strong>技能系统</strong></p><p>基于武器的技能（剑、枪）+体术（拳脚）、基于五感的技能（隐匿）、基于属性的技能（火、风、雷电、耐性），基于自然的技能（植物生长、毒）、基于时间和空间的技能</p><p>魔法：咏唱、魔力、属性（克制）、天赋、后天提升（魔核、魔道具、武器附魔）</p><p><strong>同伴形式</strong></p><p>冒险伙伴、委托关系、契约关系、拯救关系、效忠关系、投奔、购买、招募、求爱、同事</p><h1 id="剧情翻转"><a href="#剧情翻转" class="headerlink" title="剧情翻转"></a>剧情翻转</h1><p>我理解的剧情起伏就是：角色想要完成事件A，但是在途中遇到了出乎意料的困难，可为了解决困难又陷入了事件B，在解决了事件B以后，回到事件A，却发现没有得到预料的结果，反而留下了新的事件C的线索……简而言之就是一环套一环，在原来的事件的中途插入新的事件，形成一个不断展开的复杂局面。事件以意料中的形式展开，插入全新的冲突，又以意料之外的形式结尾。</p><h2 id="有限的资源、巧妙的办法"><a href="#有限的资源、巧妙的办法" class="headerlink" title="有限的资源、巧妙的办法"></a>有限的资源、巧妙的办法</h2><p>要说异世界的魔法，应该是最不合理的东西了。当然，可以提出各种解释来让魔法尽可能科学化，但是即便如此，在战斗中使用一个科学化的魔法击败敌人也没什么好看的，这是因为科学化虽然推动了真实感，但是并不包含“有趣”这个本质的东西。相反地，即使一个设定看起来完全不真实，但是它能在基础的设定上巧妙变通，或者是与其他设定组合、或者是在不同的场景里开发出不同的用途，总之只要在设定的基础上，<strong>呈现出超出常规想象空间的内容</strong>，就是“有趣”的。</p><p>例如，一个显式设定攻击力为999的魔法，可以杀死一个血量为20的魔物，这个事件完全在设定之内，是毫无真实感也毫无新意的。而设定一个强恢复力的魔法，竟然可以杀死不死族的魔物，这个事件就稍显新意，因为治愈对不死族而言是攻击，这个设定还算有趣。若设定不死族首领对其他不死族用治疗魔法回复自身，这个就更好一些，因为一般人难以想到“敌方”视角。</p><p><strong>挖掘普通设定的非正常用法</strong>，类似找法条漏洞一样，先呈现给读者的是基础设定，之后给出巧妙的延伸，中间的逻辑放在效果最后展示，就能收获表演魔术的效果。</p><p>当然，所给资源是不能太多的，而且为了保证真实性，不能在数值上找优化方法，大概应该在语义上找</p><h2 id="超越常规的设定"><a href="#超越常规的设定" class="headerlink" title="超越常规的设定"></a>超越常规的设定</h2><p>比如游戏中的一些规则：攻击力大于HP的话一定能杀死，或者是状态栏、魔力、血量这些设定，都可以进行反常化，从而打破常规。</p><p>例如传送门，一般来说魔物是不会主动越过传送门的，但如果添加了这种设定，就可以增加新颖程度，并开启新的剧情。</p><p>新奇的方式有很多，<strong>但凡只要是新奇的东西，与设定融入得越好，就越有趣</strong>。</p><h2 id="理解的提升"><a href="#理解的提升" class="headerlink" title="理解的提升"></a>理解的提升</h2><p>异世界中的升级方法比较难安排，通常来说分为历练升级、外力升级、理解升级</p><p>历练升级是比较通俗的，当读者跟着角色经过一大段故事以后，自然会认可角色的技能等级提升，也就是熟能生巧。认可的关键是角色确实用了很多次，而且有了丰富的经历。</p><p>外力升级，即遇到强者指点、秘籍等，读者知晓了外力的存在以后，按照外力在读者心中的认可程度，也会认可外力对角色升级的可靠性。关键在于塑造该外力的权威性、有效性，需要许多侧面描写和铺垫。</p><p>理解升级，这个比较困难。读者需要在作者的诱导下，对给定的世界观有新的认识，这要求设定本身逻辑融洽，且逻辑有深度，不容易被参透。作者在诱导时可以提供新的信息，但是给出的理论不能违背之前的设定，而且理论需要易于理解，读者越接受理论，就越能认可角色理解后的升级。</p><p>另外，作者只要保证“真理”的存在，角色一开始可以有错误理解，升级后也可以是不完全的正确理解，这需要一个逐步揭晓的过程。</p>]]></content>
    
    
    <categories>
      
      <category>小说</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【读书笔记】C++性能优化指南</title>
    <link href="/2021/01/12/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91C++%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/"/>
    <url>/2021/01/12/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91C++%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="C-性能优化指南"><a href="#C-性能优化指南" class="headerlink" title="C++性能优化指南"></a>C++性能优化指南</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>Experimentation, rather than intuition, is a theme of this book</p></blockquote><p>优化的时候有些技巧是与人的直觉相违背的。</p><blockquote><p>It takes the same amount of time to write efficient code as slow, wasteful code.</p></blockquote><p>作者的观点是养成写优化的代码的习惯，即使不知道那段代码是否为性能瓶颈。但是在不确定是否能优化的时候，就不要尝试牺牲效率、时间、代码可读性、代码出错率去做不确定的工作。</p><p><strong>Reduce Memory Allocation and Copying</strong></p><p>进行内存操作的时间可能是CPU计算的上千倍。</p><p><strong>Remove Computation</strong></p><p>关注热点代码：重复执行的部分</p><blockquote><p>Developers should therefore attempt not to go all OCD on a big code base changing every occurrence of i++ to ++i.</p></blockquote><p>不要代替编译器去做优化</p><p><strong>Use Better Data Structures</strong></p><p>略</p><p><strong>Increase Concurrency</strong></p><p>多线程方面的优化</p><p><strong>Optimize Memory Management</strong></p><p>改变原有的内存管理机制</p><h2 id="内存速度"><a href="#内存速度" class="headerlink" title="内存速度"></a>内存速度</h2><p>指令和数据都存储在内存中，内存被划分为字（words），一小部分内存有直接对应的地址，称为registers, 其余内存地址都由地址寄存器来映射。</p><blockquote><p>Main memory is so slow that a desktop processor can execute hundreds of instructions in the length of time it takes to fetch a single data word from main memory.</p></blockquote><p>内存读取比执行指令慢了几百倍，部分因为内存距CPU太远，存取有延时。</p><blockquote><p>Access to a nonsequential location completes in somewhere between 6 and 10 cycles</p></blockquote><p>随机读取需要6-10个周期完成，顺序读取可以只要一个周期。</p><img src="/2021/01/12/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91C++%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/2020-11-18-17-21-07.png" srcset="/img/loading.gif" class=""><p>随机读取时间可以粗略估计成50ns，如果以GHz量级衡量CPU运行频率，那么一次内存存取需要50个CPU周期来完成。</p><p>但只要读取的数据在原数据的cache line里，就可以只附加十分之一的时间读取到数据，所以顺序读取的速度为随机读取的十分之一左右。</p><p><strong>缓存cache</strong></p><p>（见 <a href="https://blog.csdn.net/qq_21125183/article/details/80590934）" target="_blank" rel="noopener">https://blog.csdn.net/qq_21125183/article/details/80590934）</a></p><img src="/2021/01/12/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91C++%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/2020-11-18-17-40-01.png" srcset="/img/loading.gif" class=""><p>cache在CPU内部，每次从内存中读取数据的时候，实际上是先存到cahce里，再从cache读取到CPU中，cache line一次读64Byte的数据，CPU一次从cache中读8Byte(64位)的数据，<strong>因此字节不对齐并不影响现代CPU的读取速度，因为一个cache line已经把附近的数据也包含进去了</strong></p><p>当代码中出现长if-else语句时，执行的代码可能不在原来的cache中，所以尽量保证循环中的代码的跳跃行数不要太多。</p><p>另外，if分支也让编译器难以改变代码顺序来优化指令执行速度。</p><p>调用操作系统的指令是非常耗费时间的，可能比调用自身的方法慢一百倍量级。</p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><p>string每次写入都会进行重新拷贝，这样是非常耗时的。一些方法可以优化string的性能，并且适用于其他场合。</p><ol><li>用修改替换重新写入：+=操作符等价于append,不会将原来的字符串复制一份。（提升10倍）</li><li>预分配内存：每次扩展容量事实上都包含一次全部的复制，预分配内存可以减少若干次复制操作（提升20%左右）</li><li>使用迭代器：迭代器在几乎任何情况下都比角标寻址要快（提升20%）</li><li>将返回值作为输出参数，并传递引用：传递引用避免了一次拷贝，但是代价是每次调用都会进行一次解引用（取指针指向的地址）操作。返回值不需要多次执行，所以这个代价可以接受。</li><li>利用append或substr对整块内容进行存取（快20%左右）</li><li>采用C风格的固定大小数组，能快上100倍左右。</li></ol><h2 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h2><p><strong>预先计算</strong></p><p>将可预见的重复计算部分放一开始的运行期、编译期或直接内置结果。</p><p><strong>懒计算</strong></p><p>只有在需要结果的时候才计算，这样能消除中间的一些重复计算过程</p><p><strong>批处理</strong></p><p>对一批数据进行处理，取代单个数据连续地处理</p><p><strong>结果缓存</strong></p><p>对中间结果缓存，减少重复计算开销</p><p><strong>双重检查</strong></p><p>先检查必要条件是否满足，大部分情况下都能得到正确的结果；如果检测的必要条件都满足，再用复杂的方法去检查所有条件是否满足，使得小部分情况下也能输出正确的结果。</p><h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p><strong>堆分配内存是极慢的</strong></p><p>new一个对象，首先要在应用程序本身被分配到的内存中寻找合适大小的区块，如果没有，就需要向OS申请更大块的内存（这个操作极其耗时）</p><p>delete也是很慢的，这是因为delete要尽量回收内存碎片，会做许多不必要的操作。</p><p><strong>栈内存与堆内存</strong></p><p>栈内存比堆内存快，栈内存有cache映射，可以直接读取，不要间接寻址。堆内存因为不确定被分配到哪了，可能不在cache中。</p><p>函数调用涉及参数的复制、函数入栈，重复调用应当写成inline.</p><p>栈内存在运行中创建和销毁开销是0，因为所有操作都是编译期被确定好了的，没有检查。栈内存因为会被反复调用，所以大概率处于cache中（然而本身只是一块普通的内存，不一定总是在cache中，而且如果栈中的数组太大，也不会全部被包含在cache中，此时的随机读写和堆内存中的读写速度是一样的，但栈调用没有new操作和delete操作耗费的时间，依然更快）</p><p>全局变量被分配在全局存储区中，对于小变量，全局存储区不如栈的效率高（有cache），但是对于大数组，在哪开都是一样的，因为cache都无法在64Byte内读取到所有元素。</p><p><strong>避免动态分配内存</strong></p><p>两阶段初始化：先统一分配内存，再在需要的时候将数据装入完成初始化，这样就避免了动态分配内存。</p><p>避免的一个方法就是用静态的大数组代替可变数组，将能确定下来的东西先确定了，从而避免低效的再分配。</p><p>第二个方法是避免再分配内存。可以在循环外进行初始化，对于类和大数组可将复制变为引用，减少一次内存分配。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【算法】查询</title>
    <link href="/2021/01/12/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%9F%A5%E8%AF%A2/"/>
    <url>/2021/01/12/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><h2 id="基本概念与分类"><a href="#基本概念与分类" class="headerlink" title="基本概念与分类"></a>基本概念与分类</h2><p>平均查找长度：进行比较次数的平均期望。</p><p>线性查找表：表中数据的联系是线性的，可以用折半查找，搜索效率是O(logn)</p><p>静态查找结构：线性表只适用于没有插入和删除的情况，若存在动态增删，则需要用动态查找结构。</p><p>基于关键字比较的查找结构vs哈希方法：hash方法将关键字映射到内存地址上，使得关键字相连数据（或完整关键字）能够被直接访问到。</p><h2 id="散列技术"><a href="#散列技术" class="headerlink" title="散列技术"></a>散列技术</h2><p><strong>散列函数</strong></p><p>hash函数将关键字映射到有限连续的地址空间，尽量保证一对一映射且不浪费内存。</p><p>散列函数的计算要求不随输入规模变化而变化，一般采用数值计算。</p><p>当关键字线性分布时，用线性映射方法即可得到近似均匀的地址，典型例为乘法散列函数</p><p>当关键字并不均匀分布，但低位变化近似随机时（可以理解为，一群老年人集中在60-80岁，但是个位的变化随机，所以可以分为个位0-9的10个组，每个组的人数近似均匀），可以用取模来进行均匀化，称为模散列函数</p><p>当关键字分布不均匀且比较离散时，可以将关键字进行复杂的混合运算（如平方），然后取中间的几位，因为混合后关键字的不均匀性被初值的敏感性抵消了（混沌现象），所以得到的结果近似均匀。这种称为平方取中法，缺点是计算耗时长。</p><p>当关键字位数很多，且每一位数字分布大致均匀时，可以采用折叠法，即将长串数字进行分割，然后相加，但相加并不能将某些不均匀性抹除。</p><p><strong>冲突处理</strong></p><p>开散列（链表处理）：</p><p>散列处存放的是链表头地址而不是散列关键字，这样就可以在一个地方存储多个关键字</p><p>链表越长，查找效率越低，链表长度平均值被定义为负载因子。</p><p>闭散列法：</p><p>散列处存放的不一定是原本对应的值，而可能是前后对应的值。每次要先检测该位置是不是确实是hash计算出的值，如果不是，就向后线性查找。</p><p>也可以不采用线性探测，即进行增长间隔的探测，以求在最短时间内跳过其他区域的关键字。</p><p>闭散列比开散列时间复杂度更低，但空间复杂度更高（当闭散列负载因子上升时，时间复杂度会急剧上升）</p><p>双重散列（？）</p><p><strong>插入与删除</strong></p><p>闭散列的删除只能设置一个标志位，如果直接删除，会导致后续的元素丢失（找到空位，误以为结束了）</p><p>插入就是在空位处填充</p><p><strong>hash技术总结</strong></p><p>优点是近似O(1)的查找、插入和删除性能</p><p>缺点：</p><ol><li>性能随着负载因子波动，接近满负载时时性能急剧下降，而且要求散列函数设计良好。</li><li>对闭散列进行多次删除操作会造成大量无效空间，并且降低查找性能。</li><li>散列的空间顺序和关键字排序不一定对应，使得查找前一个和查找后一个这种操作无法实现</li></ol><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>分块查找法：块与块之间抽象出有序的特征，但是块内部可以是无序的。</p><p>多级查找表：先按照性质A对所有元素进行分类，再按照性质B对每组元素进行再分类，从而在查找的时候只需要先后比较关键字的性质A和B，即可快速找到。</p><p>倒排表：多关键字情况下，在每种关键字下对元素进行划分，然后可以直接取每次划分的集合交集，实现多关键字合并查找。</p><p>总结：索引将关键字在高维下划分，一个特征对应一个维度，这要求一个关键字能分解出多个独立特征，并且特征的分类不重合。</p><h2 id="树算法分类以及适用情况"><a href="#树算法分类以及适用情况" class="headerlink" title="树算法分类以及适用情况"></a>树算法分类以及适用情况</h2><p>所有查询都是针对一个维度的、可以进行“线性地”比较大小的关键字（a&gt;b, b&gt;c一定满足a&gt;c）</p><p>对于一次构建、无插入删除的查询需求，直接进行一次排序，然后建立索引或者直接二分查找，排序复杂度为O(NlogN), 单次查找复杂度为O(logN), 底数根据索引结构可以建得非常大，使得查找时间几乎不随数据量变化</p><p>对于带有插入、删除、查询的需求，就需要维护一个树，让单次操作达到O(logN)的复杂度。因为随着插入值的不同，树的结构可能退化成线性表，所以需要各种re-balance操作，让树的结构与数据关系有关，但是树的平衡性与插入数据无关：<strong>这得以实现的原因是，一组特定数据可以对应很多个二叉查找树，re-balance操作使得当前二叉树在这个状态空间中不断向着平衡或近似平衡的方向转移</strong>，通过添加特定的约束，使得树状态在高维状态空间中被持续映射到低维的平衡树空间中。</p><h3 id="树堆-Treap"><a href="#树堆-Treap" class="headerlink" title="树堆 Treap"></a>树堆 Treap</h3><p>treap利用随机性维护二叉树的平衡。在BST的基础上，treap让每个节点包括一个权重，使得BST也成为一个堆，堆的性质并不重要，重要的是新增节点权重的随机性。新增权重越接近堆底，周围节点的权重越低，越有概率超过父节点的权重，旋转调整的概率和幅度就越大。</p><p>这就形成了一个平衡：在堆顶位置的节点基本不需要调整，在堆底的节点大概率会向堆顶移动。节点位置是关键字决定的，节点是否需要调整是概率决定的，<strong>于是关键字相对大小与概率相绑定</strong>，整个结构就完成了宏观上对两侧进行平衡的效果。</p><h3 id="伸展树-splay"><a href="#伸展树-splay" class="headerlink" title="伸展树 splay"></a>伸展树 splay</h3><p>splay通过伸展操作让节点总是被移动到根上，在移动的过程中，新增节点的影响通过旋转被平摊到整个树中，平均深度不断减小。</p><p>splay没有附加性质，但是新增节点无论在哪，添加效果都会被平摊到整个树上。</p><h3 id="红黑树-red-black-tree"><a href="#红黑树-red-black-tree" class="headerlink" title="红黑树 red black tree"></a>红黑树 red black tree</h3><p>红黑树指定了一个保证效率的性质：根节点到每个叶子节点经历的黑色节点数目都相同。为了与严格的AVL区分，红黑树放开了黑色节点的条件，即只让它们数目相同，但不必与红等间隔分布（但红不能连续）</p><p>通过局部的旋转可以维持局部性质，从而保证查询效率，同时也减少了无效的过于精确的平衡。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>建立整体性质的树算法：在局部性质被破坏的时候（插入删除节点），利用旋转操作（二叉树的状态转移操作）来进行局部性质的再平衡，从而保证整体性质不变。</p><p>利用随机性的树算法：在局部性质可能被破坏的情况下，利用一个与插入数据大小无关的随机量，让平衡性只与操作次数有关，而与数据无关。</p><h2 id="OJ6-转系后排名"><a href="#OJ6-转系后排名" class="headerlink" title="OJ6 转系后排名"></a>OJ6 转系后排名</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><strong>思路</strong></p><p>插入、删除、查询均要求log(N)复杂度，可以利用GPA的组成有序性，将每一位作为查找树的一层</p><p>数据结构包括</p><ol><li>一个编号表：固定编号，从编号映射到GPA；</li><li>一个skiplist，共7层，每一层用GPA的该位分组，非叶子节点存储该节点下学生总人数，和自身对应的位数字，叶子节点存储该GPA对应同学个数。skiplist存储顺序无意义，每个点包括4个指针：指向父节点（用于增删节点）、指向左侧和右侧兄弟（右侧总是比左侧大）、指向第一个儿子节点、自身对应位数字、对应同学个数（可以与位数字共享一个整型数）</li></ol><p><strong>空间复杂度</strong></p><p>编号表是O(N)的，不超过1000KB；skiplist每个节点16Byte，假设每个同学对应一个GPA，那么也不超过5000KB</p><p><strong>时间复杂度</strong></p><p>新增同学：编号表直接填入GPA；skiplist中添加新GPA或者更新数字，查找GPA位置每层最多搜索10次，总共最多搜索不超过70次，也就是10lg(GPA)。新增链表O(1)，反向更新数字最多7次，就是lg(GPA)，综合下来是11lg(GPA)</p><p>删除同学：首先要查找GPA，然后减少人数，如果人数只有一个就删除链表，综合也是11lg(GPA)</p><p>给编号查询排名：先查询GPA，O(1)，然后累加法得到前面的人数，最多也是10lg(GPA)</p><p>给编号查询排名前一位的GPA：存储按照GPA存，只要查询当前节点下左兄弟或者左侧父节点的最右侧兄弟。和直接查询排名是一样的复杂度</p><p>查询后一位的GPA：同理</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong>debug记录</strong></p><ol><li>若干地方逻辑混乱，序号用错</li><li>在写查找前一个节点时，没有考虑清楚回溯和再下降的条件：回溯只能在当前节点下无法找到相邻节点才运行，再下降是只要找到新的非0节点即可下降。错误的想法是试图用节点下子节点总数去决定是否需要回溯：即使有子节点，也不一定在查找的节点前面</li><li>输入输出问题：必须用scanf和printf，否则IO操作一定被卡</li></ol><p><strong>可优化的地方</strong></p><p>这个数据结构实际上是利用题设附加条件实现一个简化版的skiplist，在re-balance上不采用随机平衡，而是依靠数据范围确定了一个查找下界：必定在6层60次之内查找完。</p><p>查询上，这个实现不是最理想的：如果将每一层的节点联通，就可以实现前后相邻查找严格等于直接查找的复杂度，这需要在插入的时候事先将前后节点连接起来。</p><p>利用数字的结构，将所有数据存储在树的节点连接关系上，可以在每个节点节省一个int的空间，<strong>通过组合的方式将原本10e6的空间压缩到1.11*min(N,10e6)的空间中（N是树叶子节点的数量）</strong></p><p>在对节点进行分类的时候，可以不拘泥于10进制的分类原则，如果采用2进制或4进制分类，总搜索次数为40次，但理论最低值为3进制分类的情况。<strong>但因为在求余的时候得到O(1)的开销，2进制或4进制比3进制的效果要好很多</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【算法】排序</title>
    <link href="/2021/01/12/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/01/12/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h2><p>内排序、外排序：排序不需要占用额外空间的，是内排序。</p><p>排序基本操作：比较和交换，执行次数是衡量排序性能的一个指标</p><h2 id="基本排序方法"><a href="#基本排序方法" class="headerlink" title="基本排序方法"></a>基本排序方法</h2><p>冒泡排序：每一次冒泡可以确保第K小的数移动到相应的位置，下一次冒泡只需比较K+1的位置。可以看成每次检索一个最大数，然后将其抽出。</p><p>插入排序：将元素一个个插入排序好的序列，仍然需要进行连续的比较。</p><p>折半插入排序：采用二分查找法确定插入时的位置，但不能保证最差情况，所以复杂度仍然是O(n^2)</p><p>希尔排序：先确定一种子序列排序方法，如直接插入排序。然后对n间隔依次到1间隔进行排序。这里的n间隔指关键字间隔n个。实验表明希尔排序平均移动次数大概是O(n^1.25)</p><p>直接选择排序：每次检索最大数或最小数</p><h2 id="高级排序方法"><a href="#高级排序方法" class="headerlink" title="高级排序方法"></a>高级排序方法</h2><p><strong>快速排序</strong></p><p>思路：任意指定一个数（通常是最末位），然后将其放在正确的位置上：左右指针向中间靠近，使得左右满足左侧小于该数，右侧大于该数，这样指针最后就能找到该数的正确位置。然后对左右侧分别进行操作即可。</p><p>性能：平均来看，可以将快排每次确定的阈值都看作中位数，每次至多对N个元素进行操作，总共有logN层，所以性能为O(NlogN)</p><p><strong>归并排序</strong></p><p>自底而上方法：将N个数看成N个长度为1的序列，然后两两归并（归并指将2个序列合成一个有序的新序列，复杂度O(n)），这样也是自底而上，归并logN层，每层元素有N个，复杂度O(NlogN)</p><p>自顶而下方法：也就是实现从顶部划定了归并调用的结构，然后自底而上归并。</p><p><strong>堆排序</strong></p><p>参考堆的笔记。堆可以做到O(logN)的删除最大值操作。重复抽出N个最大值就得到有序序列。</p><h2 id="特殊情况下线性复杂度排序"><a href="#特殊情况下线性复杂度排序" class="headerlink" title="特殊情况下线性复杂度排序"></a>特殊情况下线性复杂度排序</h2><p><strong>关键字计数排序</strong></p><p>条件：关键字是整数或可与整数关系建立双向映射、取值范围有限</p><p>累计计数：利用整数排列的唯一性，只要映射数的存在性即可得到排列。显然数的存在性是可以在线性时间内获取的。</p><p>推广：只要待排序关键字取值可能数量有限，且关键字之间的比较满足传递关系，那么就将所有可能性预先排序，然后考察存在性即可。如果关键字有附带信息，可以用链表形式存储地址，并且维护一个当前关键字下重复个数</p><p>复杂度计算：假设整数个数为K，空间复杂度O(N+K)，第一次对每个元素检查，O（N），然后从K数组中读取排序后结果, 无附加信息时同关键字不需要分辨，O(K)，总时间复杂度O(N+K)</p><p><strong>桶排序</strong></p><p>假设已知数据的分布情况，给定一个数据，就可以估计其大概在什么位置，于是对所有数据，将其放置在表示大概位置的桶内，再对桶内的数据用其他方法排序。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【算法】拟合与插值+OJ10</title>
    <link href="/2021/01/12/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8B%9F%E5%90%88%E4%B8%8E%E6%8F%92%E5%80%BC+OJ10/"/>
    <url>/2021/01/12/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8B%9F%E5%90%88%E4%B8%8E%E6%8F%92%E5%80%BC+OJ10/</url>
    
    <content type="html"><![CDATA[<h2 id="拟合与插值"><a href="#拟合与插值" class="headerlink" title="拟合与插值"></a>拟合与插值</h2><p><strong>超定方程组</strong></p><p>超定方程组是多次观测得到的结果，无法直接解出，需要拟合。</p><p><strong>线性拟合</strong></p><p>方程组的每一行看作一个数据点，每一列的数据是多项式的项，如x^2+x+1，第一列就是x^2,第2列就是x，第三列是1</p><p>写成如上形式后，就不关注拟合表达式的结构，而全都看作线性拟合（使得每一行的误差满足最小二乘下的最优）</p><p>解的存在性：如果列向量线性无关（即不出现Ax+Bx这种情况），就必定有唯一解</p><p><strong>正规方程法</strong></p><p>正规方程的A’A就是将A（m*n，看作n个m维向量）投影为n个n维向量，其中投影的方式满足m维向量到n维超平面的欧氏距离最短。</p><p>Cholesky分解：就是对A’A有特殊的LU分解，其中U=L’，所以分解后得到的是LL’</p><p>正规方程法得到A’A矩阵相乘复杂度O((mn^2)/2),Cholesky分解复杂度O(n^3/6)</p><p>线性拟合问题的敏感性：</p><p><strong>QR分解</strong></p><h2 id="OJ10"><a href="#OJ10" class="headerlink" title="OJ10"></a>OJ10</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>假设有N个标志，每个标志置0或1，那么最多有2^N个状态，当N较小时，即使M较大，BFS最多搜索的状态数是2^N，多余的状态可以通过减枝删去（状态存储算法？）</p><p>假设有M个塔，就是M个未知量，高斯消元法每次是O(M^3)的。当M较小时，即使N很大，也可以将多余的塔全部置0减少计算量。</p><p>当M和N都较大时，指数增长远大于三次方增长，此时先用高斯消元法，找到真正可变的一组塔，然后以此缩小状态范围，再用BFS搜索得到解。</p><p>若N&lt;9，且M&gt;10时，用BFS。其他情况用高斯消元法。</p><p><strong>BFS</strong></p><p>数据结构是一个struct，三个int，分别存储上一状态的序号、当前标志状态。先添加根节点到队列中。</p><p>每次更新时，从队列取出一个节点，在visited结构中搜索状态是否已经被考察过。若未展开过，分别计算M个相邻节点标志的变化，得到新节点。再对每个节点判断它的标志状态是否已经考察过了，若考察过了，则不再添加到队列中（第一次考察时一定把它的所有子节点展开过了），若未考察过，添加到队列中。最后在visited结构中添加这个取出的节点（所有节点都被访问过了，所以不再考虑它）</p><p>每次更新，更新开始方位的，再更新结尾方位的，最多的步数不超过M/2次（最短路径一定每个点至多踩1次）。结尾方位更新时，计算变化要用“减去”而不是“加上”</p><p><strong>高斯消元</strong></p><p>结构是一个N*(M+1)的矩阵A，其中A[m][n]的值等于第n个标志是否与第m个塔相连。然后解AX=B，其中B是目标状态，X是踩塔的解决方案。扩展M到M+1（把B包含进去），然后高斯消元，消元方式也是异或。</p><p>当存在多种可能性的时候，无法保证找到最优解。也就是当塔的数量大于标志的数量时，解不一定正确。</p><p><strong>改进后高斯消元</strong></p><p>假如在高斯消元后，统计主元列的数量和位置，就可以找到非确定的变量。在非确定变量较少的时候，可以用暴力搜索找到最优值。</p><p>检测点的非确定变量少于5个，搜索次数不会多余32次。可以比较顺利的实现。</p><p>要减枝也有方法：在代入的过程中判断当前的塔个数是否已经大于计算出的最小值。但是这次时间较宽裕，所以不需要。</p><p><strong>debug</strong></p><p>最后2个判例内存不足，而且都是N=M的情况。有4-5个非主元列，暴力搜索最多需要32次.</p><p><strong>小结</strong></p><p>OJ10的工作量和debug难度都不小。BFS方法写起来比较复杂，而且为了查询操作O(logN)的复杂度，需要维护一个动态更新的二叉树。debug方面，有几次是角标、序号等细节错误，<strong>这说明在更改的时候要用查询和替换，不要自己看着代码改</strong>。最后一次是高斯消元写的有问题，应该先对各部分测试。</p><h3 id="判例"><a href="#判例" class="headerlink" title="判例"></a>判例</h3><p>1<br>4 4 1<br>2 -1<br>1 3 4 -1<br>1 4 -1<br>1 2 4 -1<br>1 0 1 1</p><p>1<br>4 4 1<br>1 -1<br>2 -1<br>3 -1<br>4 -1<br>0 0 0 0<br>输出：1 \n 1 1 1 1 -1</p><p>1<br>4 4 1<br>2 4 -1<br>3 1 -1<br>2 4 -1<br>-1<br>0 0 0 0</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【算法】优化初步</title>
    <link href="/2021/01/12/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%BC%98%E5%8C%96%E5%88%9D%E6%AD%A5/"/>
    <url>/2021/01/12/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%BC%98%E5%8C%96%E5%88%9D%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="优化初步"><a href="#优化初步" class="headerlink" title="优化初步"></a>优化初步</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>优化问题</strong></p><p>优化问题就是在给定条件（等式，不等式）下寻找目标函数的最值点</p><p>例如：给定总面积，做一个容积最大的盒子、给定盒子容积，求如何做总面积最小</p><p>若条件和目标函数都是线性的，那么就是线性规划</p><p><strong>凸性</strong></p><p>当优化问题是“凸”的，也就是说：局部最优点=全局最优点（只有一个局部最优点），那么就可以用局部信息找到全局最优点。</p><p>强制：若函数在x极大或极小时都趋近正无穷，那么函数就是强制的。强制的函数在闭区间上一定存在最小值。</p><p><strong>优化条件</strong></p><p>如何判断一个点是局部最优点，也就是n维空间下的局部极小值。</p><p>取偏导数判断：海森矩阵（正定、不定）、拉格朗日函数求极小值</p><p>取所有可行方向：从最优点看，在所有方向上，最优点都是最低点（方向导数大于0）</p><h2 id="一维优化方法"><a href="#一维优化方法" class="headerlink" title="一维优化方法"></a>一维优化方法</h2><p><strong>黄金分割搜索</strong></p><p>对于单峰函数（左边下降，右边上升，只有一个最低点），对于一段a-b的f(x)，取黄金分割的两个点(tau和1-tau)，比较这两个点的大小，最小值只能在较小点所在的区间中（每次能排除一小半的x）</p><p>注意：必须要单峰函数才行。</p><p><strong>牛顿法</strong></p><p>用抛物线拟合一个点的函数值、一阶导和二阶导，然后预测底部，接着跳转底部继续预测。</p><p>好处：初始值比较近时，平方收敛。<br>坏处：可能找到极小值不是最小值</p><p><strong>保护法</strong></p><p>用黄金分割法得到合适的初值，用牛顿法快速收敛到解。</p><p>混合方法，收敛更快，但是也要注意适用于单峰函数。</p><h2 id="多维优化方法"><a href="#多维优化方法" class="headerlink" title="多维优化方法"></a>多维优化方法</h2><p><strong>最速下降法</strong></p><p>可微函数的负梯度总是指向下降最快的方向，所以每次迭代朝着负梯度前进寻找下一个点即可。</p><p><strong>多维牛顿法</strong></p><p>求解线性方程组（？？？）</p><p>缺点：牛顿法对初值相当敏感，</p><p><strong>KKT条件</strong></p><p>先求临界点，再筛选真正的极小值</p><p><strong>障碍法</strong></p><p>将约束条件转化为惩罚函数，使得可以在R^n上搜索结果（即使搜索到了可行域之外的，惩罚函数会使得成本充分大，让无约束问题的最优点等效于原问题）</p><p>会选取特定形式的惩罚函数，分为等式和不等式两种情况。</p><h2 id="凸优化"><a href="#凸优化" class="headerlink" title="凸优化"></a>凸优化</h2><p>凸集合：顾名思义</p><p>线性组合是凸的，非负线性组合是凸的，范数球也是凸集，</p><p>凸函数：全局最优=局部最优</p><h2 id="OJ8"><a href="#OJ8" class="headerlink" title="OJ8"></a>OJ8</h2><p><strong>一维情况</strong></p><p>假设一条路径是最优的，那么它每两个点之间的路径也是最优的。</p><p>对于最优路径上每一个点k，它在0-k范围内也是最优的。</p><p>假设每个点都存储了从0到该点的最优路径经过的点数目f(k)，那么在计算f(k+1)的时候，只要找到比自身位置低的点中f(x)最大的点m，就有f(k+1)=f(m)+1</p><p><strong>一维情况的思路</strong></p><p>先读取所有高度，连同顺序，即ind+H，读到数组A中，然后对A快排（nlogn），再遍历ind（n），得到顺序与高度位置的映射（给定一个顺序，找到高度所在位置），在高度顺序表基础上建完全二叉树，树的节点存储子节点f(m)的最大值，默认为0。</p><p>用顺序到高度的映射依次更新f(m)：每次更新，查找比自己小的高度的对应f(m)的最大值（最多找logn次），找到后即可更新自己的f(k)=max{f(m)}+1，因为其后添加的节点的f(m)都是0，所以不影响结果。</p><p>更新后，依次向上更新max{f(m)}, 最多logn次。单次更新是O(logn)量级，更新所有后，记录最大值。</p><p><strong>二维情况</strong></p><p>在计算f(k+1)的时候，只要找到x,y都不超过自己的点中f最大的点m，就有f(k+1)=f(m)+1</p><p>先用kd树对(sl,sr)区域进行划分，同时非叶子节点存储区域内的max{f(m)}，然后依然用ind-&gt;node映射来依次更新f(k)：</p><p>首先查找x,y都小于自身的区域的最大f(m)的值，不妨将2层合并，假设一次查找4个区域1234，当更新的节点落在不同区域时，要接着深入的区域也不同，但总的来说，一次查找平均能减少1/2的无效区域，同时节点落在每个区域的概率是随机的，所以总查找消耗应该不是n^2级别，但还没法具体计算时间复杂度。</p><p>这种查找方式应该与最近邻有一种形式的等效，可以直接看作sqrt(n)的复杂度？</p><p>在具体实现的时候，用了类似的思路，但是在每次对单层进行操作的时候，需要注意一些细节：在nth_element选择的时候，无法保证每次的中点是<strong>相等的x,y中最晚加入的点</strong>，于是无法保证当该点的值为分界线时，需要检测的点都在一边，所以这个地方的等号不能加。</p><p>如果结合两层判断，就需要在具体到节点的时候再保证一次有效性，但是相反地，在排序的时候就不需要再控制pos的关系。</p><p>实际测量了8次不同N的耗时，发现确实是符合n<em>sqrt(n)的，*</em>这种用数据量来检测时间复杂度的方法也可以用来debug：看自己是不是写出了符合条件的复杂度**</p><p><strong>性能优化</strong></p><p>这次OJ对性能要求非常苛刻，在复杂度O(n*sqrt(n))不变的情况下，对若干细节进行优化，使得最后在N=5E4的速度比最开始的速度快了4倍。</p><p>首先是优化kd树中获取子节点/父节点的函数，先是用数组序号代替引用，然后把多余的调用手动合并掉，再用arr2pow数组计算2的若干次方的结果，这些步骤把耗时从3000ms降到了1000ms</p><p>接着是进一步优化，虽然写了inline，但是速度依然受限，所以用位运算+宏的方式把函数原地展开，这一步把耗时从1000ms降到了800ms左右</p><p>再接着是把scanf用快读代替，这一步能优化几十毫秒，否则scanf会占到100-200ms，对结果影响很大。</p><p>再接着是对一些细节进行优化，比如count计数其实不需要，直接删除。除2和模2都用位运算代替；最后一层可以先判断isleaf，节省一次调用开销（整个创建期间，节省了N次调用开销）；查询的方法参数过多，而且都是bool量，将其合并在一个char里面，用位运算来读取和写入，节省了一些内存复制的开销。</p><p><strong>Debug</strong></p><p>这次OJ的debug也非常困难，具体地说，一是难以构建判例发现错误的逻辑，二是难以跟踪OJ的WA</p><p>有一次RTE是因为数组开的不够大，但是如果用constexpr的话，<strong>数组不够大并不会报RTE而是WA</strong>。理论上虽然完全二叉树只需要2N的空间，但是实际上logN是非整数，完全二叉树的最下一层是默认上面都填满了的，所以需要用2^17来计算而不是2N来计算。</p><p>debug的时候比较困难的是找判例，大多数简单判例并不能找到bug。<strong>这时候用大判例+数量级的判断</strong>就可发现一些问题，或者是<strong>自己随机写一些临界判例，有概率恰好碰到bug</strong>，但是最保守（做完后看来也是非常有效的）的方法<strong>是写一个复杂度劣化的版本，然后用随机数构造判例</strong></p><p><strong>判例</strong></p><p>test1的全部数据输入时，答案是81</p><p>1<br>10<br>18467 41<br>26500 6334<br>15724 19169<br>29358 11478<br>24464 26962<br>28145 5705<br>16827 23281<br>491 9961<br>11942 2995<br>5436 4827</p><p>1<br>5<br>100 100<br>10 10<br>20 20<br>30 10<br>10 50</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OJ优化指南</title>
    <link href="/2021/01/12/OJ%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/"/>
    <url>/2021/01/12/OJ%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="OJ优化指南"><a href="#OJ优化指南" class="headerlink" title="OJ优化指南"></a>OJ优化指南</h1><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><ol><li>scanf和printf代替cin和cout：在一些情况下，加了sync后者也会占用相当长的IO时间</li><li>需要用 #pragma warning(disable:4996) 避免报错</li><li>快读：快读旨在利用已知的输入格式避免读取数据时的逻辑判断（边界、有效值、其他可能情况）</li></ol><h2 id="样例估计"><a href="#样例估计" class="headerlink" title="样例估计"></a>样例估计</h2><ol><li>用assert估计样例规模（二分法），有助于判断一些因为规模太大而WA的情况</li><li>assert估计规模还可以查清实际的时间复杂度与空间复杂度限制（题面的范围有时不可能实现）</li><li>用assert分辨样例特征，可以针对某个样例设计参数，从而可以用不普适的方法AC</li><li>用assert进行预debug：在逻辑中针对某些不可能出现的分支设计assert，从而提高bug的侦测概率</li><li>用assert进行分支执行的检测：在需要检测是否执行了的分支上设置assert，验证猜想</li></ol><h2 id="内存利用"><a href="#内存利用" class="headerlink" title="内存利用"></a>内存利用</h2><ol><li>位段和设置字节对齐：牺牲一定的读取速度换取常数项的减少。</li><li>数组复用：当各阶段解耦时，可以用前一个方法的数组的空间来进行后面的计算</li><li>用组合的方式存储数据、指针实现动态扩容。</li></ol><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ol><li>i++写成++i避免一次返回操作</li><li>inline和register等C++内置的优化方法</li><li>尾递归到循环的优化</li></ol><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><ol><li>用#define来设置一个版本开关，使得改变一行就可直接把本地代码提交且不占运行时间</li><li>release版本可以删除debug版本中一些逻辑检测来优化运行用时。</li></ol><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><ol><li>写测试函数把中间过程输出，便于调试。</li></ol><h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><ol><li>先测试本地小样例，再用OJ结果测试</li><li>检查一个中等复杂样例的所有中间过程</li><li>排除法定位问题，再进行分支预测</li><li>用vs自带的运行分析来优化耗时较高部分</li><li>在多个复杂方法组合时debug, 先写一个劣化的简单方法，然后查看是否仍然WA</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【写作】沉默的大多数（王小波）分析与感想</title>
    <link href="/2021/01/12/%E3%80%90%E5%86%99%E4%BD%9C%E3%80%91%E6%B2%89%E9%BB%98%E7%9A%84%E5%A4%A7%E5%A4%9A%E6%95%B0%EF%BC%88%E7%8E%8B%E5%B0%8F%E6%B3%A2%EF%BC%89%E5%88%86%E6%9E%90%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    <url>/2021/01/12/%E3%80%90%E5%86%99%E4%BD%9C%E3%80%91%E6%B2%89%E9%BB%98%E7%9A%84%E5%A4%A7%E5%A4%9A%E6%95%B0%EF%BC%88%E7%8E%8B%E5%B0%8F%E6%B3%A2%EF%BC%89%E5%88%86%E6%9E%90%E4%B8%8E%E6%84%9F%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="沉默的大多数"><a href="#沉默的大多数" class="headerlink" title="沉默的大多数"></a>沉默的大多数</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个笔记有两个目的：第一是分析杂文的写作风格，包括逻辑、结构、情绪、用词等，是对文章的分析；第二是分析杂文的思想，与当今的现状进行对比，完成对思想的批判。</p><p>以下是写作风格的细分：</p><p><strong>结构</strong></p><p>精彩的开头、精彩的结尾</p><p><strong>逻辑</strong></p><p>如何给出定义、如何进行论证、如何巧妙的引导读者</p><p><strong>情绪</strong></p><p>如何调动读者情绪、如何避免与读者对立</p><p><strong>用词</strong></p><p>如何避免过于通俗的用词、如何避免过于书面化的用词</p><h2 id="《沉默的大多数》"><a href="#《沉默的大多数》" class="headerlink" title="《沉默的大多数》"></a>《沉默的大多数》</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><blockquote><p>人要永远做小孩子虽办不到，但想要保持沉默是能办到的。</p></blockquote><p>开头先讲故事，再类比推出主题，同时注意语序“XX是能办到的”，而不是“但是可以保持沉默”，就强调了这个动作的特殊性。</p><blockquote><p>往往有一种交流信息的独特方式，甚至是特有的语言，有一些独有的信息，文化可以传播，等等。这才能叫作文化</p></blockquote><p>为了解释沉有别于一般“动作”的特殊性，先定义了文化这个东西，采用的是反例修正的方式，即“满足XX才是”，<strong>避免了无效的名词解释</strong>。</p><blockquote><p>冲上阳台，朝全世界放声高呼：我们家吃大鱼大肉了！</p></blockquote><p>王小波的夸张体现在字词的选用上，<strong>用小主体搭配大动作，或者相反，体现戏剧效果或讽刺效果</strong></p><blockquote><p>据我所知，那个圈子里常常犯着贫乏症</p></blockquote><p>王小波在“说话-掌握话语权”和“沉默-学到人性”中站队后者，那自然要论述前者的不好。首先就是一个词的<strong>高度概括</strong>。好处是：<strong>简洁有力，而且吸引读者继续阅读，相当于把握了主场</strong></p><blockquote><p>我希望自己朴实无华，说起话来，不要这样绕嘴，这样古怪，这样让人害怕。</p></blockquote><p>让别人赞同自己的观点的时候，如果没有情感烘托，就不需要表现出自己抨击的猛烈性。相反，<strong>古怪，让人害怕</strong>这样的话可以更好地与读者共鸣（前面的就是一个“古怪”的故事）。</p><blockquote><p>中国人有句古话：敬惜字纸。这话有古今两种通俗变体：古代人们说，用印了字的纸擦屁股要瞎眼睛；现代有种近似科学的说法：用有油墨的纸擦屁股会生痔疮。其实，真正要敬惜的根本就不是纸，而是字。文字神圣。</p></blockquote><p>核心观点无疑是“文字神圣”，但是不能用敬惜字纸来直接论证，<strong>直接把别人的话当作自己观点的第一证据，显得没有主见，削弱了影响力</strong>。</p><p>两个古今的解释一定上论证了古话的科学性，然后以一种相似的方式，<strong>用一个角度的正确让人相信自己阐述的另一个角度也是科学正确的</strong></p><blockquote><p>我只敢说我厌恶自己说自己神圣，而且这也是实情</p></blockquote><p>作者举了爱人的例子来说明话语太过神圣，从而是反人性的。<strong>作者的目的是在这种假严肃假庄重的文学圈子里写一些反映真实人性的东西</strong></p><h3 id="余论"><a href="#余论" class="headerlink" title="余论"></a>余论</h3><p>王小波关于的话语权神圣性的讨论在现在大概难以引起共鸣了，但是话语圈和沉默的群体在现实中确实存在。话语和沉默产生于群体，又反过来控制群体，以至于便于交流的东西被贴上神圣的标签。一部分人因为别人的沉默而也放弃了自己的权力。</p><h2 id="《思维的乐趣》"><a href="#《思维的乐趣》" class="headerlink" title="《思维的乐趣》"></a>《思维的乐趣》</h2><blockquote><p>这正是因为在那些年代，有人想把中国人的思想搞得彻底无味</p></blockquote><p>大一统的官方思想落实不够科学，本来是强调革命精神，执行到底层就变成了杜绝其他精神</p><blockquote><p>假如一个人每天吃一样的饭，干一样的活，再加上把八个样板戏翻过来倒过去地看，看到听了上句知道下旬的程度，就值得我最大的同情。</p></blockquote><p><strong>避免卖惨式的叙述</strong>，这里采用假设的方式叙述自己的经历，更加委婉和有趣</p><blockquote><p>胡思乱想并不有趣，有趣是有道理而且新奇。</p></blockquote><p>反例修正，补充论点</p><blockquote><p>在这个名单的末尾是一些善良的军代表，他们想把一切从我头脑中驱除出去，只剩一本270页的小红书。</p></blockquote><p>善良在这里是讽刺，小红书是毛思想的具象化，也是刻板强力灌输的思想的象征。<strong>具象化的东西总要比抽象的生动</strong></p><blockquote><p>我认为脑子是感知至高幸福的器官，把功利的想法施加在它上面，是可疑之举</p></blockquote><p>用词很好，“可疑之举”既没有直接表达的弊端，也有一定的客观性。</p><blockquote><p>当然，如果有人乐意这样来对待自己的孩子，那不是我能管的事，我只是对孩子表示同情而已.</p></blockquote><p><strong>避免权力越界</strong>是写作需要注意的，<strong>作者只能通过文字影响读者，再让读者自己产生“应该”与“好坏”的价值观，如果直接灌输观点，就会引起读者的不适和反抗。</strong></p><blockquote><p>假如说，思想是人类生活的主要方面，那么，出于功利的动机去改变人的思想，正如为了某个人的幸福把他杀掉一样，言之不能成理。</p></blockquote><p>类比论证，推出显著的谬误</p><blockquote><p>倘若去掉一部分，我是谁就成了问题。</p></blockquote><p>没有采用“我就不是我了”这种简单的论断，<strong>而是倒换语序</strong>，让“问题”变成重点</p><blockquote><p>人既然活着，就有权保证他思想的连续性</p></blockquote><p>朴素的人权观念</p><blockquote><p>假如我全盘接受，无异于请那些善良的思想母鸡到我脑子里下蛋，而我总不肯相信，自己的脖子上方，原来是长了一座鸡窝</p></blockquote><p>用形象的比喻引导读者关注自身思想独立的权力，<strong>从受尊重权过度到思想独立权</strong></p><blockquote><p>所以这种脑移植带给我的不光是善良，还有愚蠢。</p></blockquote><p>被迫接收思想的危害性之三，之一是与其他思想隔绝，之二是丧失独立人格</p><blockquote><p>领导上硬要我去，我还得去，但是这以后挖坏了青山、造成了水土流失等等，就罪不在我</p></blockquote><blockquote><p>所以，质朴的人们假如能把自己理解不了的事情看作是与己无关的事，那就好了</p></blockquote><p><strong>讽刺是站在自己的视角进行观察的，而且要让读者接受，不能直接给出观点</strong>, 给出感受而不是批判，给出期望而不是指控。</p><h2 id="中国知识分子与中古遗风"><a href="#中国知识分子与中古遗风" class="headerlink" title="中国知识分子与中古遗风"></a>中国知识分子与中古遗风</h2><h3 id="摘要-1"><a href="#摘要-1" class="headerlink" title="摘要"></a>摘要</h3><blockquote><p>首先表现在受约束上</p></blockquote><p>同样地，先给出一个高度概括的词，然后分析。</p><blockquote><p>另一类是踩着地雷断了腿的同类</p></blockquote><p>这里用同类而不是知识分子，<strong>用批判对象冲突的特征来称呼对象，本身就是一种讽刺和批判</strong></p><blockquote><p>还有一个爱说的话题就是别人“格调低下”</p></blockquote><p>引出观点也要站在自己的观察者角度，<strong>“爱说”和“认为”前者是客观观察，后者是主观意志，作者不能反客为主，只能道出自己的感受</strong></p><blockquote><p>除了树立形象，还该树立个森严的道德体系，把大家都纳入体系，从道德上说事，就人人都能被说着了。</p></blockquote><p>群体价值观的建构与内部利益分配有关</p><blockquote><p>也不像现代欧美知识分子跨价值观的立论（价值中立）。最爱干的事是拿着已有的道德体系说别人</p></blockquote><p>批判中国知识分子的“中古遗风”，<strong>在论点句用通俗的语言，在其他无关紧要的地方用专业术语，倒置引起反差</strong></p><blockquote><p>，“脱裤子割尾巴”地混了这么多年，才混到工人阶级队伍里，可谓“心比天高，命比纸薄”！在这种情况下，我建议咱们把“士”的传统忘掉为好</p></blockquote><p>这里建议的手法很巧，<strong>首先站在批判对象的角度，给出反对的“代价”，然后给出建议，最后给出评价</strong>，这里的评价也很中肯，是“也未必见得不好”，双重否定增强委婉程度，“见得”强调大众角度，容易受大众支持。</p><h3 id="余论-1"><a href="#余论-1" class="headerlink" title="余论"></a>余论</h3><p>只给现象，对原因的分析较少。总的来说只有一个历史惯性。并且给出一个改革方案。</p><p>上地</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【算法】动态规划</title>
    <link href="/2020/12/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2020/12/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><p>对于一个问题，若满足如下3个条件，则可以用动态规划方法解决：</p><p><strong>具有最优子结构</strong>：任意找一个中间状态，若这个解要成为全局最优解，那么从该状态到末状态的决策必定是该状态下的最优解</p><p>注：若最优解能推导出从初始状态到中间状态的解也是最优的，那么就可以用贪心法。不需要DP</p><p><strong>无后效性</strong>：一个状态即包含后续决策所需的所有前置信息。过去决策无法直接影响未来决策，而必须通过当前状态传递信息。</p><p><strong>重复子问题</strong>：在求解时若用蛮力法会对相同问题重复求解，这也是DP能优化速度的原因所在。</p><p>用DP方法时，有如下步骤：</p><ol><li>定义阶段和各阶段下的最优值</li><li>从初始状态开始逐个计算最优值，每次计算时，遍历前阶段最优值</li></ol><p><strong>状态转移方程</strong>：在计算阶段K+1的时候，使用前K阶段的状态来计算得到K+1阶段的最优策略的方程</p><p><strong>多维动态规划</strong></p><p>动态规划一般会记录一个表，只要把这个表从小到大算一遍就能算出答案</p><p>二维动态规划就是填一个二维的表，适用于有2个独立的阶段约束的情况（一般来说，数据规模也是二维的）</p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><p>描述：给出N件物品，每件价值不同，重量不同，给定总重量W，求解总价值最大的装载方案。</p><p><strong>分析</strong></p><p>直观地，选定W为阶段数，总价值为最优值。状态即是当前装载的物品列表。</p><p>先考察最优子结构，对于最优的装载方案，给定中间的某个装载列表，则从剩余的物品中选择必定要选最优的组合，如果不选最优，可以用最优的替代，则原方案非全局最优方案。</p><p>再考察无后效性：给定一个装载列表即可知道剩余的物品，也可知道当前重量，于是包含了所有前置信息。对于重量为W的方案，需要考察重量小于W的方案，因此满足重复子问题</p><p>解决时，先从W=1开始，每次推导W+1阶段时，假设至多能添加一个新的物品（这个假设一定能覆盖到W+1的最优解的上一状态，且方便计算最优决策），遍历各个之前的状态，计算总和最大的一个状态。</p><h3 id="钢条切割问题"><a href="#钢条切割问题" class="headerlink" title="钢条切割问题"></a>钢条切割问题</h3><p>描述：给定不同长度钢条的价格，再给一段长L的钢条，求解总价值最大的切割方案</p><p><strong>分析</strong></p><p>直观地，L是阶段数，总价值是最优值。状态是已经切完的长度L_0（为什么与01背包不同，因为物品拿走了就不能再拿，具有全局性，而钢条可以随意切割）</p><p>最优子结构：假设前L_0的钢条已经切完了，那么从L_0到L的钢条必定也要切成最优方案。</p><p>无后效性：只要得知L_0的钢条切割完，后续L_0到L的切割方式就可以随意制定，与L_0是怎么切割的无关</p><p>解决时，先从L=1开始，每次假设只能多切一整段的钢条，所以L-L_0的部分直接卖出，而L_0的价格取之前计算的最优值。</p><p>这个假设还是可以验证：若L长度的钢条切割方案卖得最好，那它必定能分解成L_0和L-L_0的单独段钢条，至于L-L_0有多长无法得知，但是只要遍历所有的单独段钢条，就一定能覆盖到最优方案。</p><h3 id="股票交易（买卖股票最佳时机IV）"><a href="#股票交易（买卖股票最佳时机IV）" class="headerlink" title="股票交易（买卖股票最佳时机IV）"></a>股票交易（买卖股票最佳时机IV）</h3><img src="/2020/12/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2020-12-24-11-00-18.png" srcset="/img/loading.gif" class=""><p><strong>分析</strong></p><p>直观地，k是阶段数，总利润是最优值。</p><p>先作一些预处理：将股票价格写为2日之差的形式，买卖就等效为寻找最大和子序列。那么阶段就等效为当前可交易的日期的数据（总数据抛去交易中的数据）</p><p>最优子结构：假设已经进行了k_0笔交易，把剩下的天数抽出来重排，后续的交易在剩下的天数里必然也是能最大盈利的。</p><p>无后效性：只要得到可以交易的天数的数据，前面的k_0笔交易无影响。</p><p>注：假设一笔交易完全覆盖了之前的交易日期，也就是横跨了被截取的日期，那么之前的那笔交易就不是进行k_0笔交易时的最优交易，若横跨2个交易，也可以选择一次不交易。总之新的交易不会跨过之前交易的日期，进行日期合并是安全的。</p><p>解决时，先默认k-0时利润为0，然后从k=1开始，每次先加载前k_0项交易，然后对处理过的数组寻找最大子序列，这是个O(n)的操作。</p><p>附：最大和子序列问题：从第一个值累加，累加结果小于等于0时，舍去前面的结果。记录最大的累加结果就是最大和。</p>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】图搜索</title>
    <link href="/2020/12/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%BE%E6%90%9C%E7%B4%A2/"/>
    <url>/2020/12/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%BE%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="图搜索"><a href="#图搜索" class="headerlink" title="图搜索"></a>图搜索</h1><h2 id="组合优化"><a href="#组合优化" class="headerlink" title="组合优化"></a>组合优化</h2><p><strong>非数值优化问题</strong>：给出一些条件，选取一种最优的“状态”。每个状态之间是有关联的，所以可以用图或者树的方式将状态联系起来。</p><p>注：局部解就是一个不完全的解，类似于八皇后只给出4个皇后的位置</p><p><strong>回溯法</strong>：类似深度优先搜索，只要局部解有可行性就继续深入，直到解不可行再回溯到可能可行的局部解</p><p><strong>分支界限法</strong>：类似广度优先搜索，先计算出不可行的点的范围，再对可行的范围按照解最可能存在的顺序一一搜索。</p><h3 id="剪枝策略"><a href="#剪枝策略" class="headerlink" title="剪枝策略"></a>剪枝策略</h3><p>2种方法都需要剪枝。</p><p>对最优问题，先存储当前找到的全局最优解，只要局部解已经确定不优了，就不用搜索。</p><p>必要条件剪枝：不满足最优的必要条件的，一定不是最优，这种检测方法比较简单。</p><h3 id="任务分配问题"><a href="#任务分配问题" class="headerlink" title="任务分配问题"></a>任务分配问题</h3>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】随机算法</title>
    <link href="/2020/12/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    <url>/2020/12/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>随机性</strong>：算法中引入随机数，多次运行，结果可能不同。</p><p><strong>线性同余法</strong>：用于产生伪随机数，思路把上一个随机数变成ax+b，然后对M取余。要求M必须很大（这样分布才广），第一个数称为种子。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="计算圆周率、计算函数定积分"><a href="#计算圆周率、计算函数定积分" class="headerlink" title="计算圆周率、计算函数定积分"></a>计算圆周率、计算函数定积分</h3><p>随机算法相当于近似地取面积，对于精度要求不高的情况很合适。</p><h3 id="随机搜索非线性方程的解"><a href="#随机搜索非线性方程的解" class="headerlink" title="随机搜索非线性方程的解"></a>随机搜索非线性方程的解</h3><p>用满足正态分布或均匀分布的方式搜索。</p><h3 id="舍伍德算法"><a href="#舍伍德算法" class="headerlink" title="舍伍德算法"></a>舍伍德算法</h3><p>思想：随机化输入/中间取值，以避免不好的样例对复杂度的恶化。</p><p>舍伍德法优化快排：随机找一个元素作为划分元素，或随机找三个元素，取中间位置的元素作为划分元素。</p><p>优化二叉树：对待建树的元素进行随机洗牌。</p><p>注：随机洗牌Fisher–Yates算法：</p><blockquote><p>每次随机选取一个数，然后将该数与数组中最后(或最前)的元素相交换(如果随机选中的是最后/最前的元素，则相当于没有发生交换)；然后缩小选取数组的范围，去掉最后的元素,即之前随机抽取出的数。重复上面的过程，直到剩余数组的大小为1，即只有一个元素时结束。</p></blockquote><h3 id="拉斯维加斯算法"><a href="#拉斯维加斯算法" class="headerlink" title="拉斯维加斯算法"></a>拉斯维加斯算法</h3><p>思想：随机构建一部分答案，然后尝试解出符合要求的结果，若能解出就一定正确。随机构建的部分越多，就越容易进入无解的空间，随机构建越少，搜索解的范围就越广，速度就越慢。</p><p>n皇后问题：先随机摆放一部分皇后，然后求解另一部分</p><p>整数的质因数分解：构建随机数序列相邻2项之差，然后与n求最大公约数（公因数）</p><h3 id="蒙特卡洛方法"><a href="#蒙特卡洛方法" class="headerlink" title="蒙特卡洛方法"></a>蒙特卡洛方法</h3><p><strong>p正确</strong>：一个算法，若在所有情况下，单次运行得到正确解的概率是p，这个p大于0.5，就是p正确。p-0.5称为“优势”</p><p><strong>一致</strong>：若对同一个实例，算法若给出正确解就必定是唯一的解，那么这个算法是一致的（总是给出唯一正确的解）。</p><p><strong>偏真</strong>：对于判断问题，若给出真的时候一定正确，那么就是偏真的。</p><p>思路：若有一个一致的或偏真的算法，且是p正确的，多次调用就一定能减少出错的可能性<br>理解：对真假问题，连续判断为真实际为假的概率极小。对给出解的问题，若只有唯一的正解，运行若干次后正解一定占p的比例，剩下1-p的比例被若干错误解瓜分，显然连续给出同一个错误解的概率就更小了。</p><p><strong>应用：主元素问题</strong>：寻找序列中是否有出现次数大于序列长度的一半的元素，即主元素。显然可以随便选一个元素，然后扫描一遍，可以证明这个方法是有效的。</p><p><strong>应用：素数判定算法</strong>：用必要条件（费马小定理）检测，若检测多次依然正确，则大概率是素数。</p><h2 id="智能随机算法"><a href="#智能随机算法" class="headerlink" title="智能随机算法"></a>智能随机算法</h2><p>模拟退火算法（没展开讲）</p><h2 id="关于OJ1"><a href="#关于OJ1" class="headerlink" title="关于OJ1"></a>关于OJ1</h2><p>蒙特卡洛方法可以用于判断矩阵乘法是否正确，多次运行一个偏假的方法，用于有效简化复杂度。</p>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】算法优化策略</title>
    <link href="/2020/12/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/"/>
    <url>/2020/12/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="算法优化策略"><a href="#算法优化策略" class="headerlink" title="算法优化策略"></a>算法优化策略</h1><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>采用特定存储结构可能带来某一操作更优的性能（比如堆可以直接找到最值，线性表可直接按下标访问）</p><h2 id="时间空间复杂度互换"><a href="#时间空间复杂度互换" class="headerlink" title="时间空间复杂度互换"></a>时间空间复杂度互换</h2><p>若求解较大N时需要用到较小N的结论，则适合顺序求解。将逆序求解改为顺序求解可以极大减少重复计算次数。代价只是存储了多余的结论</p><p>散列，牺牲空间复杂度来换取接近理想的时间复杂度</p><h2 id="算法的组合"><a href="#算法的组合" class="headerlink" title="算法的组合"></a>算法的组合</h2><p>快排改进：当N较小时用插入排序，或者不排序而在最后用一次插入排序。</p><p>非线性方程的求解：大范围用二分法缩小解的范围，小范围用牛顿法、割线法获取更大收敛速度。通常用黄金分割搜索+反二次插值。</p><h2 id="问题预处理"><a href="#问题预处理" class="headerlink" title="问题预处理"></a>问题预处理</h2><p>用数学手段优化：直接给出表达式</p><p>计数排序、KMP算法</p><p><strong>Horspool模式匹配算法</strong></p><p>（有详细解释，待补充）</p>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】非线性方程组</title>
    <link href="/2020/11/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B/"/>
    <url>/2020/11/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="非线性方程组"><a href="#非线性方程组" class="headerlink" title="非线性方程组"></a>非线性方程组</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>病态问题：若函数在零点附近切线接近水平，则求根问题病态：切线y的变化会造成x的剧烈变动。</p><p>收敛速度：假设迭代进行很久以后，每一步迭代的误差都是上一步误差的r阶量，则称为r阶收敛（一阶=线性，二阶=平方，三阶以上=超线性）</p><p>判停：一般通过固定的迭代步数、每一步的误差变化、残差（？）</p><h2 id="非线性方程的解法"><a href="#非线性方程的解法" class="headerlink" title="非线性方程的解法"></a>非线性方程的解法</h2><p><strong>二分法</strong></p><p>条件：需要知道解的区间、方程连续（适用于介值定理）<br>思路：对区间用介值定理不断二分<br>性能：线性收敛，每次迭代增加一个二进制有效位，迭代步数与方程无关<br>缺陷：二分法截止采用两次迭代之差，但是若真值接近0，<strong>则迭代结果只保证绝对精度，无法保证有效数字</strong>，若采用相对误差，则可能会产生除0问题。</p><p><strong>试位法</strong></p><p>条件：与二分法一致<br>思路：将二分法的二分替换为线性拟合：当已知两点符号相反时，可知至少有一个根，然后认为方程就是过这两点的一条直线，计算出直线的零点，代入检验，若不对，则继续细分。<br>性能：因为计算零点时用到了函数的性质，当函数一部分平坦一部分陡峭的时候，收敛会变得非常缓慢</p><p><strong>不动点迭代</strong></p><p>不动点的唯一性：对g(x)=x的理解可以是：当g(x)斜率绝对值不超过1时，g(x)在y=x下面的点不可能跑到上面去，所以必定只有一个分界点。</p><p>不动点法的收敛性：在每一个点作切线，这个切线与y=x形成一个矩形，迭代下一个x只能在矩形内部，且g(x)把长映射到宽，也就是说每次迭代的矩形必定是嵌套的。嵌套有传递性，且嵌套的程度取决于g’(x)，当g’(x)绝对值不逼近1时，逼近每次都有个下界，所以必定能得到结果。</p><p>当|g’(x)|&lt;1不满足时，只能期望迭代后能够进入到满足条件的小矩形中。当g(x)=x不满足条件的区间不够长时（总有收敛区域承接，而不是在两个发散区域内“反射”），就不足以导致发散。</p><p>缺陷：不满足条件时不一定收敛。</p><p>不动点定理也可以用来求收敛性。</p><p><strong>牛顿法</strong></p><p>思路：一种理解是从切线角度理解，即每次迭代都将方程局部近似线性化。另一种是将其理解为规范化的不动点函数，即每次按照一定规则选取不动点函数</p><p>性能：如果收敛，则简单根至少平方收敛，重根线性收敛。不收敛可能有：振荡（两个点之间反复迭代），极小值发散。简单来说就是用不稳定性换收敛速度。</p><p>改进牛顿法：主要针对重根进行改进，构造零点相等的f(x)/f’(x)，将上下的m-1阶极小抵消，就能保证平方收敛。</p><p>改进牛顿法需要事先知道根的阶数。</p><p><strong>割线法</strong></p><p>思路：主要是在牛顿法上改进：将求切线转化为求前2步的点形成的割线，当前两步相差较小时，总能逼近切线。</p><p>性能：收敛阶数1.618，相比牛顿法，放弃了收敛速度换得计算复杂度</p><p><strong>反插法</strong></p><p>思路：在y-x平面上，先测三个点，然后认为非线性方程是三个点拟合出来的二次函数，接着求出交点，继续验证并拟合。为了确保预测的存在性，拟合函数为x=g(y)</p><p>性能：收敛阶数1.839</p><h2 id="解法小结"><a href="#解法小结" class="headerlink" title="解法小结"></a>解法小结</h2><p>所有解法都是利用局部性质或整体性质。当非线性方程连续的时候，它在零点局部有很好的性质，即局部可以线性化，在整体上也有很好的性质，就是介值定理。二分法和试位法是比较保守的思想，就是先确定解的范围，然后高效地“挨个”搜索。不动点迭代利用了函数的性质，在限定条件下适用的较激进解法。牛顿法完全利用局部性质，把局部性质完全套在整体性质上。所以不一定收敛，但是寻找的速度比较快。</p><p>利用局部性质预测，越接近零点预测越准（函数局部线性化），收敛速度就越快。利用整体性质预测，在远离零点的时候也能利用有效信息（符号），但是符号提供的信息有限，收敛速度只有一个整体下界。</p><h2 id="OJ8"><a href="#OJ8" class="headerlink" title="OJ8"></a>OJ8</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>根据文献，采用单隐藏层，300隐藏节点的多层感知机。预处理后可以得到1.6%的错误率。</p><h3 id="样例和通过记录"><a href="#样例和通过记录" class="headerlink" title="样例和通过记录"></a>样例和通过记录</h3><p>样例2，4，7，8，9的样本都小于1000<br>样例1，5，6样本大于1000但是小于3000<br>样例6样本大于1000小于2000<br>样例10样本N=3000<br>样例3样本大于3000</p><p>训练次数6000，能过234789样例，但6一直无法过<br>1，5，10在训练2000次时满足acc小于0.1，但是依然WA,可能是过拟合<br>1，5在训练1000次时通过，<br>样例6数据量在1000到2000之间，样例10<br>训练量2000的时候样例10能过</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>OJ8的主要问题是debug，首先MLP这个东西就充满了不确定性，在此基础之上，网络性能受到多个参数影响，还有潜在的代码错误问题。</p><p>在结构层面上，参考前人所写的结构，这就有了个准确度上限的参照。用MNIST可以忽视数据集的影响：避免样例的过拟合与欠拟合导致的WA。在参数设计上，若MNIST上跑出理想的模型，就只需要根据数据集进行特化的调整。</p><p>可以看出，在NN设计中，一套合理可靠的评价体系直接决定了参数的可靠性和网络的鲁棒性。同时也有一个思路，<strong>就是模仿样例的设计，先从二分类的简单情况开始测试，逐渐过度到多分类情况</strong></p><p>测试结果的图形化表示也是问题。图形化表示有助于找到数据的趋势，同时便于人手动优化参数。<strong>原则上，一切呈现给人的复杂数据都应当是图像化的</strong></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数值计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】线性方程组</title>
    <link href="/2020/11/18/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
    <url>/2020/11/18/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="解线性方程组"><a href="#解线性方程组" class="headerlink" title="解线性方程组"></a>解线性方程组</h1><h2 id="高斯消元法"><a href="#高斯消元法" class="headerlink" title="高斯消元法"></a>高斯消元法</h2><h2 id="OJ7"><a href="#OJ7" class="headerlink" title="OJ7"></a>OJ7</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>a^b=c可以推出a=b^c 由此将线性方程组的加法和减法都映射到异或运算</p><p>两个矩阵：一个点是否使用刷子（矩阵A）和一个点的颜色（矩阵B）</p><p>设前两行是否用刷子为未知量，可以递推求出所有点是否使用刷子的表达式。只要在前两行的每个点作十字，可以发现只有一个位置是不确定的，利用异或性质即可得到方程。</p><p>因为递推式根据前两行的“假设”推出A的所有点，每一行的假设都可以让向前第二行的假设符合实际，所以最后两行的假设应当根据实际情况验证。</p><p>因为总共2N个变量，恰好最后也是2N个点，而且用上了全部的数据，必定能得到满秩矩阵</p><p>推表达式时，每个点最多用2N+1个变量表示，需要存储全部节点，因为最后输出矩阵时需要用全部数据来计算</p><p>空间复杂度：O(10N^2), 100行数据大约需要10^5bit,也就是12KB</p><p>最后的表达式也是2N个方程，每个方程用一个2N+1大的数组存储，总空间复杂度在一个量级。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>创建了一个MatA，最后一列是常数列，这样就能直接算得结果</p><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p><strong>样例1</strong></p><p>5 5<br>0 0 1 0 0<br>0 0 1 0 0<br>1 1 1 1 1<br>0 0 1 0 0<br>0 0 1 0 0</p>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】数值计算</title>
    <link href="/2020/11/10/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"/>
    <url>/2020/11/10/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>适定/不适定问题：给定条件是否能求出唯一的、稳定的、连续依赖于条件的解</p><p>病态问题：条件的微小波动导致解的极大波动，就是病态的</p><p>有效数字：绝对误差小于0.05，则精确到小数点后1位，即0.1,有效数字是从0.1开始（包括0.1）向前的数字（开头0.00的部分不算）</p><p>截断误差：算法层面上，无限求和截断成有限求和，无限细分近似有限细分而产生的误差</p><p>舍入误差：计算层面上，无限精度小数舍入为有限精度得到的误差</p><p><strong>截断误差与舍入误差相互制约</strong>：在求导这种上下取极限的操作上，差分间隔h越细，理论上算法的精度就越接近真实的结果，截断误差就越小，但是差分间隔越细，上下的数就越小，小数点N位后细微的舍入误差的占比就越大，所以结果由舍入误差带来的偏差就越大。</p><p>向后误差：f(x)相等时x的误差；向前误差：x相等时f(x)的误差</p><p>条件数：用向前误差和向后误差估计得到解对初值的敏感程度</p><p>舍入原则：就近舍入和最近舍入，是两种用浮点数表示一个真实数的近似策略</p><h2 id="机器计算的误差分析"><a href="#机器计算的误差分析" class="headerlink" title="机器计算的误差分析"></a>机器计算的误差分析</h2><p><strong>抵消：大数相减</strong></p><p>大数相减，尾数的有效数字就减少。只能避免这种情况的发生</p><p><strong>大数加减小数，完全丢失</strong></p><p>浮点数加减过程中，要先统一指数部分，这就会让小数的有效数字几乎全部丢失</p><hr>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数值计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】单源最短路径dijkstra算法</title>
    <link href="/2020/11/08/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84dijkstra%E7%AE%97%E6%B3%95/"/>
    <url>/2020/11/08/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84dijkstra%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="dijkstra算法以及第七周OJ"><a href="#dijkstra算法以及第七周OJ" class="headerlink" title="dijkstra算法以及第七周OJ"></a>dijkstra算法以及第七周OJ</h1><h2 id="dijkstra算法理解"><a href="#dijkstra算法理解" class="headerlink" title="dijkstra算法理解"></a>dijkstra算法理解</h2><h3 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h3><p>运行一次dijkstra算法只能求出给定点到图中所有点的最短距离以及最短路径。</p><p>假设一个顶点数为n、边数为e的图，需要两张表：第一张表大小为n，<strong>记录给定点到图中所有点的最短路径</strong>，这张表在过程中会不断更新；第二张表是最短路径树SPT，在单源情况下，这个树只是从起点到n个节点的二层带权n叉树，被添加的最短路径都是确定的路径，不会被更改。</p><p>首先更新最短路径表，只将起点的邻接点更新到表中，其余置INF(无穷大)。</p><p>每一步开始时，先考察最短路径表中还没确定的点，也就是SPT以外的点，访问其中最短距离对应的点B，<strong>这个点是不确定点中最短的一条，对所有路径，它们只能从A出发，而表中至少包含A所有的邻接点的路径，任何从A到B的点的路径都至少有一段被包含在表中，也就是任何可能路径都不会比表中最短路径还要短</strong>，我们找的这个B恰好能利用这个信息：全图任何从A到B的可能路径，都不会比表中最短路径（一个从A到B的路径）短，那么表中的最短路径就是全图上的最短路径。</p><p>每一步结束时，总能得到一个B，将这个B添加到SPT中。然后要用B更新最短路径表：因为B已经被加在了SPT中，所以必须添加新的备选最短路径使得最短路径表中总能找到新的最短路径，而这个添加过程就引入了所有与B相关的路径：</p><p>假设其他路径都不是最短路径，那么B更新了邻接点后，必然会更新到最短路径：<strong>这是因为，假设路径表中有一条n+1步的路径，那么它包含的n步的路径必定是最短路径，否则它不会被更新到。当所有与SPT的邻接点都被更新到最短路径表中时，假设一个路径是到达邻接点的最短路径，那么它后退一步的路径必然是最短路径，我们已知这样的路径的所有邻接点都被更新，那么这个路径必然被包含在表中</strong></p><p>每次更新可能更新多个最短路径，但是每次只接收一个。</p><h3 id="优化策略：配对堆"><a href="#优化策略：配对堆" class="headerlink" title="优化策略：配对堆"></a>优化策略：配对堆</h3><p>见堆相关blog</p><p><strong>顶点查找</strong></p><p>利用dijkstra算法运行中不会扩增线性表的特点，构建堆的时候，只改变每个节点的指针，不改变节点存储的位置。也就是依然可以用下标搜索到特定node，然后搜索到其邻接表.虽然node不存储自身位置，但是可以取地址相减获得序号</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><strong>时间复杂度</strong></p><p>因为每次SPT只增加一个点，所以必定要迭代n次，每次迭代的耗时分析：</p><ol><li>要找到路径表中除了SPT以外的点的最短路径</li><li>将其添加到SPT中，并更新路径表中邻接节点的路径<br>如果我们用配对堆维护最小路径，每次取出堆顶是O(logn)的耗时，但每次更新路径是O(1)的操作，所以总耗时是O(nlogn + e)<br>对于稀疏图，用邻接表存储，查找邻接节点就是O(1)，总共需要O(e)次，不影响复杂度</li></ol><p><strong>空间复杂度</strong></p><p>SPT需要空间为n，建堆空间为n，最短路径表的空间为n（单源）</p><h2 id="OJ分析"><a href="#OJ分析" class="headerlink" title="OJ分析"></a>OJ分析</h2><p>OJ的问题主要在于：找所有最小路径数和空白区域划分。</p><h3 id="路径记录"><a href="#路径记录" class="headerlink" title="路径记录"></a>路径记录</h3><p><strong>根据最短路径的各个子路径也一定是最短路径</strong>的原理，只需要记录每个点到A点的最短路径的前一个点即可，在更新路径的时候，如果待更新路径与原路径相等，那么就同时记录两个点，所需空间复杂度就是邻接表的复杂度，即O(e)</p><h3 id="零权重分布"><a href="#零权重分布" class="headerlink" title="零权重分布"></a>零权重分布</h3><p>一个思路：例如给定10个置0权重，就构建10层的图，每层图都一样，但是层之间的路径是单向的：<strong>第一层的A节点用有向的0权重连接到第二层的A的邻接点</strong>，也就是说，算法可以选择在第一层到达终点，也可以选择通过0权重到达第二层，但是每次上升就无法下降，<strong>将二维图扩展到3维，就覆盖了所有可能的置0路线</strong></p><p>但是也有不严谨的地方：如果路径长度比置0数还要短，最短路径就是0，此时这个长度就没有用上。</p><h3 id="零权重复杂度分析"><a href="#零权重复杂度分析" class="headerlink" title="零权重复杂度分析"></a>零权重复杂度分析</h3><p>将倍数代入复杂度，log(aN)被线性化，而ae也是线性增长的，因此整个时间复杂度增长速度近似线性增长。</p><p>因为每层图都是一样的，0权重连接也可以通过邻接表查询到，所以权重存储空间与a无关。最短路径表和SPT会增长到aN，在第一次检测后，将最短距离减去最大权重依然大于当前最短距离的点看作不存在，当需要检测A层时，只需要存储可能经过的点的位置。</p><p>也可以同时以起点和终点进行2次最短路径检测，然后对每一条边进行比对，就可以得到经过某条边到达终点的路径长度，如果大于最小路径减去最大权重的a倍，就删掉该条边（一定不会经过这条边），然后再删除孤立点</p><h3 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h3><p><strong>样例1</strong><br>8 8 1<br>1 2 1<br>1 3 1<br>2 4 1<br>3 4 1<br>4 5 1<br>4 6 1<br>6 7 1<br>5 7 1<br>1 7</p><p>输出 3 16</p><p><strong>样例2</strong></p><p>8 9 0<br>0 1 1<br>1 3 2<br>1 5 1<br>1 2 1<br>3 4 3<br>4 2 0<br>2 5 1<br>4 5 1<br>0 3 1<br>3 2</p><p><strong>样例3</strong></p><p>8 8 0<br>1 2 1<br>1 3 1<br>2 4 1<br>3 4 1<br>4 5 1<br>4 6 1<br>6 7 1<br>5 7 1<br>1 7</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>马恩选集笔记：社会主义从空想到科学的发展</title>
    <link href="/2020/11/08/%E9%A9%AC%E6%81%A9%E9%80%89%E9%9B%86%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E4%BB%8E%E7%A9%BA%E6%83%B3%E5%88%B0%E7%A7%91%E5%AD%A6%E7%9A%84%E5%8F%91%E5%B1%95/"/>
    <url>/2020/11/08/%E9%A9%AC%E6%81%A9%E9%80%89%E9%9B%86%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E4%BB%8E%E7%A9%BA%E6%83%B3%E5%88%B0%E7%A7%91%E5%AD%A6%E7%9A%84%E5%8F%91%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="社会主义从空想到科学的发展"><a href="#社会主义从空想到科学的发展" class="headerlink" title="社会主义从空想到科学的发展"></a>社会主义从空想到科学的发展</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><blockquote><p>不能把思想同思维着的物质分开</p></blockquote><p>人可以假定上帝存在、思想存在，但是思想和上帝都是观测不到实体的，那么思想是否可以独立于肉体存在呢？诚然我们有抽象的思想概念，但它只存在于“人”的印象中，而不能被科学地观测到。同命运、上帝一样，不可知的东西是不能在其上构建理论的。</p><blockquote><p>不可知论断言人的认识能力不能超出感觉经验或现象的范围，不能认识事物的本质及发展规律。</p></blockquote><p>不可知论本身论述的证明或证伪都可以用其循环的逻辑解释，核心在于“XX是否是事物的本质及发展规律”这个命题无法证实或证伪，这就与科学有根本的区别。</p><p>当然可以继续对“科学”这种概念进行质疑，这样质疑下去可以对所有概念是否有意义提出怀疑，甚至可以对“无法证实且无法证伪”这一论断进行怀疑。在这个问题上，<strong>需要一些无理由也不需要理由的假设</strong>，这里假设值得研究的范围仅限于与人所感受的现实相关的东西，也就是：</p><blockquote><p>可是，如果我们达到了我们的目的，发现事物符合我们关于该事物的观念，并产生我们所预期的效果，这就肯定地证明，在这一范围内，我们对事物及其特性的知觉符合存在于我们之外的现实</p></blockquote><p>所谓“经世济用”并不排斥抽象物，而是排斥不能证明也不能证否的、与其他物没有关联的抽象物。再此基础上利用推理、验证等手段可以证明一些感知是否正确，也就可以认为认识到了事物的“客观本性”</p><blockquote><p>这种观点认为，一切重要历史事件的终极原因和伟大动力是社会的经济发展，是生产方式和交换方式的改变，是由此产生的社会之划分为不同的阶级，是这些阶级彼此之间的斗争。</p></blockquote><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><blockquote><p>在形而上学者看来，事物及其在思想上的反映即概念，是孤立 的、应当逐个地和分别地加以考察的、固定的、僵硬的、一成不变的研究对象。</p></blockquote><p>静止不光是运动的一部分，实际上绝对的静止是不存在的，这就和运动有相当大的区别：绝对的静止并不存在，所以以静止为前提研究得出的结论就可能带有一些“未可知”的成分。</p><blockquote><p>辩证法在考察事物及其在观念上的反映时，本质上是从它们的联系、它们的联结、它们的运动、它们的产生和消逝方面去考察的。</p></blockquote><p>这类似于黑箱的概念，事物的联系也就是人接触事物的途径，如果两个事物在人所能观察到的范围内都是一致的，那么这两个事物应当被看作同一事物。而人赋予的名字等都是符号，没有额外的内涵。</p><p><strong>唯心主义</strong></p><blockquote><p>客观唯心主义认为，在现实世界之外独立存在着一种客观精神，它是世界的本源，世界万物是由它产生（派生）出来的。其著名代表人物，有中国的朱熹、古希腊的柏拉图和德国的黑格尔等。</p></blockquote><blockquote><p>主观唯心主义是把人的主观精神（意识、观念等）作为认识世界的出发点，存在主观精神之中的是认知上的世界，是主观精神的产物，而并非真正客观上的世界。主要代表人物，有中国的陆九渊和王守仁，和德国的费希特等。</p></blockquote><p>极端唯心主义可以称为唯我主义。唯心和唯物的根本分歧在于物质和精神哪个是第一性质，哪个是第二性质。</p><p>从唯物主义角度解释精神，可以解释为一种局部混沌、整体却有规律的大脑活动。不同于机械决定论的观点，脑的活动是无法预知的，但这和不可知论者的观点又有区别：脑的活动尽管无法预知，但是精神实在地影响了客观世界，精神的存在是可以验证的，又因为不在不可知的领域构建理论，这里应当排除第一性的精神，于是唯物主义与唯心主义的对立就成立了。</p><h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><blockquote><p>以往的全部历史，除原始状态外，都是阶级斗争的历史；这些 互相斗争的社会阶级在任何时候都是生产关系和交换关系的产 物，一句话，都是自己时代的经济关系的产物。</p></blockquote><p>阶级当然存在于历史中，但是不能这样就论断是“阶级斗争的历史”。在研究历史发展的规律的时候，历史中的各个事件是不等权的，这种权重变化是人赋予历史的而不是历史自身的属性。从客观上来讲，一场雨和一场革命没有区别，只是前者充满偶然性，后者暗含历史必然规律。</p><p>这里我倾向于认为：阶级斗争在历史发展中有其必然规律，因此从实用的角度，可以解释为“阶级斗争的历史”。</p><h2 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h2><blockquote><p>唯物主义历史观从下述原理出发：生产以及随生产而来的产品交换是一切社会制度的基础；在每个历史地出现的社会中，产品分配以及和它相伴随的社会之划分为阶级或等级，是由生产什么、怎样生产以及怎样交换产品来决定的。</p></blockquote><p>历史规律必然要排除偶然性，即研究群体性的东西。可以假定每个时代的“人”作为一种生物是基本不变的，古代人放到现代社会经过现代化教育也与现代人无差异。那么个体的因素不变，个体差异又被抹去，只剩下个体之间的联系，即群体性的东西。</p><p>先承认一种稳定性假设：大多数人没有足够的时间和精力在一生中同时从事很多层面的工作。在货币发挥作用的时代，生产和交换确实是社会制度的分类依据，但是如果没有货币呢？</p><p>可以假设人们不需要衡量不同物品间的价值，也不能用一个物品与另一个物品交换。可一定要面对物质需求不能满足人们需要的情况，这就要求物质需求极大满足。或者是在赛博空间中得以实现。</p><blockquote><p>一部分人的过度劳动成了另一部分人失业的前提</p></blockquote><p>推理过程如下：机器生产让劳动力多出来，但是机器生产的东西却需要所有人都消费，于是这些人就变成了“后备军”，此时生产对劳动力的需求大于市场对消费者的需求，劳动力永远是过剩的，而消费者永远是欠缺的。这就导致两个情况：劳动力互相挤压工资，也就是内卷化，和商品滞销，也就是市场经济萎靡。</p><blockquote><p>我们已经看到，现代机器的已经达到极高程度的改进的可能 性，怎样由于社会中的生产无政府状态而变成一种迫使各个工业 资本家不断改进自己的机器、不断提高机器的生产能力的强制性 命令。</p></blockquote><p>在买方市场下，生产产品质量越好、规模越大越能盈利，从而越能提升机器效能。通过交易的形式，资本环境下的优胜劣汰完全由盈利决定，于是发展到最终的企业一定是盈利效果最好的企业：对于劳动力市场，必须提高员工可替代性，让每个员工成为“螺丝钉”，从而最大化利用劳动力市场压低劳动力价格；其次，对于消费者市场，必须对市场进行垄断从而让消费者只能购买其产品。企业的扩大生产只是加剧了整个周期的进行速度。</p><blockquote><p>在危机中，社会化生产和资本主义占有之间的矛盾剧烈地爆发出来。商品流通暂时停顿下来；流通手段即货币成为流通的障碍；商品生产和商品流通的一切规律都颠倒过来了。经济的冲突达到了顶点：<strong>生产方式起来反对交换方式</strong>。</p></blockquote><p>生产方式指工厂机器生产，交换方式指商品交换。机器生产使得少部分人获得大部分利润，交换方式使得大部分人需要提供大部分的消费，显然两者是冲突的。</p><blockquote><p>支配商品生产的规律日益显露出来，它们的作用日益加强。竞争不可遏止。个别工厂中的社会化组织和整个生产中的社会无政府状态相矛盾</p></blockquote><blockquote><p>机构和交通机构起初由股份公司占有，后来由托拉斯占有，然后又由国家占有。资产阶级表明自己已成为多余的阶级；它的全部社会职能现在由领工薪的职员来执行了</p></blockquote><blockquote><p>无产阶级将取得公共权力，并且利用这个权力把脱离资产阶级掌握的社会化生产资料变为公共财产。</p></blockquote><p>这是恩格斯总结的历史发展规律，但是无产阶级取得公共权力的过程说的不是很清楚：从股份公司发展到托拉斯这一步可以在完全竞争的理想化市场下实现，如互联网公司的兼并最终形成少数“大厂”，从托拉斯到国家的这一步就不是很明显。改革开放的原因就是要促进经济活力，如果大公司集体转编制，宏观上的体现就是回归计划经济时代，人人大锅饭使得每个人劳作意愿下降。</p><p>应当看到国家与个人之间平衡是在各层次权力的博弈中达到稳定的。如果阶级对立消失，<strong>个人与社会的矛盾是否会代替阶级之间的矛盾成为新的社会冲突点？</strong>。如果结团体的利益高于保持个体的利益，社会会朝着阶级化的方向前进。反之，社会关系会逐渐原子化，回归到个体与个体间的关系。</p><p>如果人人都能“不劳而获”，那么势必大多数人都不会劳动，拿低保度日。下面是关于北欧高福利制度的介绍</p><p><strong>北欧高福利制度的支撑</strong></p><p>来源：<a href="https://www.zhihu.com/question/58173613/answer/676810895" target="_blank" rel="noopener">https://www.zhihu.com/question/58173613/answer/676810895</a></p><blockquote><p>聚焦高附加值，低发展速度产业</p></blockquote><p>这一条是基本的：高附加值理论上可以带来高社会福利，低发展速度代表可以“吃老本”而不用担心996.<strong>丹麦发展畜牧业、生物制药、基础材料、艺术设计</strong></p><blockquote><p>他们得以保持竞争力的，往往已经不是难以逾越的“绝对技术壁垒”，而是以用“低市场增长”（而且大部分行业市场也不大）+“较高技术门槛”成的一圈“黑域”</p></blockquote><p>市场太小决定了北欧的高福利制度是不可大范围推广的，这种高技术门槛、低市场增长的产业不会太大，就比如圆珠笔芯这个产业。之所以没有后来者愿意跟进，是因为这些产业拥有十足的<strong>先发者优势</strong>，先积累的排斥后积累的，加上自身获利实在不多，因此得以保全。</p><blockquote><p>只要社会总劳动所提供的产品除了满足社会全体成员最起码的生活需要以外只有少量剩余，就是说，只要劳动还占去社会大多数成员的全部或几乎全部时间，这个社会就必然划分为阶级。</p></blockquote><p>劳动时间与生产力发展在现阶段不一定有直接联系：互联网行业是先进生产力，但是员工依然996。在现在生产力比较发达的时代，为了维持金融体系稳定，大量时间被用于偿还过去的借债。比如说房地产行业，大量卖地资金由百姓承担，相当于政府向人民借钱发展经济，而且地价提升带来买房刚性需求受阻，大多数人被迫为了房贷工作。</p><p>当人民无法享受到生产力发展带来的物质丰富时，劳动时间也就无法随着生产力发展而下降。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【算法】堆</title>
    <link href="/2020/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%A0%86/"/>
    <url>/2020/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="堆的分类"><a href="#堆的分类" class="headerlink" title="堆的分类"></a>堆的分类</h2><p>大根堆指堆顶是最大元素，小根堆指堆顶是最小元素。但是两者都要求数据以有序的结构存储、读取，这个结构就是根节点与子节点的大小关系一致。</p><h2 id="自底而上建立堆"><a href="#自底而上建立堆" class="headerlink" title="自底而上建立堆"></a>自底而上建立堆</h2><p>首先将存储数据的一维数组看作一个完全二叉树，然后从右向左，从叶子节点开始遍历，<strong>因为完全二叉树的存储位置都是固定的，所以每次排序可以O(1)地搜索到位置</strong>，同时因为每次排序时都将数组后面的元素调整到前面，所以只需一次遍历即可构建堆，复杂度O(n)</p><h1 id="配对堆"><a href="#配对堆" class="headerlink" title="配对堆"></a>配对堆</h1><h2 id="原理简述"><a href="#原理简述" class="headerlink" title="原理简述"></a>原理简述</h2><p>配对堆用指针的方式将一个复杂结构线性化存储到内存中。一个节点包含3个指针，一个指向第一个孩子，一个指向左侧兄弟（最左侧的指向父亲），一个指向右侧兄弟。</p><h2 id="操作简述"><a href="#操作简述" class="headerlink" title="操作简述"></a>操作简述</h2><p><strong>查找最小值</strong></p><p>对于小根堆，返回堆顶即可，复杂度O(1)</p><p><strong>合并两个堆</strong></p><p>合并到根节点，对于小根堆，将较小的根作为合并后的根，只需要拉一根线（指针）即可，复杂度O(1)</p><p><strong>插入</strong></p><p>插入也是插入到根节点，同理，O(1)</p><p><strong>decrease-key（修改节点并重新调整）</strong></p><p>decrease指的是修改一般是往堆顶的方向修改，即只会增大/减小。修改方法是将其与父节点的连接断开，然后将其作为新节点添加到根节点处。</p><p><strong>删除堆顶</strong></p><p>删除堆顶是为了取出最小值，这也是堆的限制：只能从堆顶删除，从而便于单一地维护堆结构。为了重新构建新堆，删除后会剩下若干子堆，将它们先两个两个合并，然后再对合并后的堆进行合并，直到所有节点都合并到根节点为止。</p><p>合并的总次数可能会退化到O(n)，但如果配对堆的结构保持住，就是O(logn)的复杂度</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>删除堆顶的操作平摊复杂度是O(logn)，修改节点操作认为是O(loglogn)，在n不很大的时候都可以看作常数。</p><h2 id="实现简述"><a href="#实现简述" class="headerlink" title="实现简述"></a>实现简述</h2><p>自底而上构建堆即采用完全二叉树的方式，此时数据是顺序存储的，但是多叉树必定是乱序的，因此需要用3个指针，确保同层兄弟互相指向，同父节点至少一个指向父亲，且父亲指向第一个儿子。</p><p>在修改节点的时候，源数据的位置并不会变，只是指针会变。<strong>这就要求源数据在第一次建堆以后不能添加新值，只能修改和删除</strong></p><p>在修改节点时，若删除的是第一个儿子，就需要同时修改父亲处的指针，因为第一个儿子与父亲是双向连接的，所以容易修改。若修改非第一个儿子，则需要将左右兄弟连接，这也是O(1)的。</p>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】递归与递归消去</title>
    <link href="/2020/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E5%BD%92%E6%B6%88%E5%8E%BB/"/>
    <url>/2020/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E5%BD%92%E6%B6%88%E5%8E%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="递归与递归消去"><a href="#递归与递归消去" class="headerlink" title="递归与递归消去"></a>递归与递归消去</h1><h2 id="递归的复杂度"><a href="#递归的复杂度" class="headerlink" title="递归的复杂度"></a>递归的复杂度</h2><p> 当调用栈较多时，对栈空间的影响较大，同时调用栈也有时间花销。</p><p> 当重复计算某些问题时（菲波纳契数列），递归不能利用已知的问题的解，时间复杂度与非递归算法有本质上的差异。</p><h2 id="消除递归"><a href="#消除递归" class="headerlink" title="消除递归"></a>消除递归</h2><p> 尾递归可以直接用循环代替，减小栈空间开销。</p><p> 对非尾递归的情况，可以显性模拟一个递归调用栈，然后进行结构上的优化。</p>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】线性表</title>
    <link href="/2020/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2020/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="分类和概念介绍"><a href="#分类和概念介绍" class="headerlink" title="分类和概念介绍"></a>分类和概念介绍</h2><p>队列分为顺序队列、循环队列、链式队列，没有本质区别。两者都实现的是：<strong>存储了入队操作顺序，实现先进先出</strong>，结构上，队列有个头指针和尾指针，有入队和出队操作，为了在有限的空间上实现不限次的入队出队操作，必须使得队列元素前后顺序与存储顺序无关，所以引入循环队列（虚拟一个循环的空间）和链式队列（在存储位置上离散化）。</p><p><strong>优先级队列</strong></p><p>优先级队列给每个点定义一个优先级，入队没有变化，优先级高的先出队。<strong>因为线性存储结构只能存放局部信息，所以无法实现全局范围内优先级的自动查找</strong>，无论用有序/无序、链表/顺序表，都至少在一个操作上有O(N)的复杂度。</p><h1 id="线性表的应用"><a href="#线性表的应用" class="headerlink" title="线性表的应用"></a>线性表的应用</h1><h2 id="栈实现自然表达式运算"><a href="#栈实现自然表达式运算" class="headerlink" title="栈实现自然表达式运算"></a>栈实现自然表达式运算</h2><p>由两个栈组成：一个符号栈，一个操作数栈。</p><p>实现原理：<strong>从左往右检测，当后一个运算符比前一个运算符等级低的时候，必定可以先对前面计算</strong></p><p>为了确保每一个高优先级运算符都能检测到一个低优先级运算符，将结尾加一个符号<code>;</code>来通知截止。</p><p>所有运算表达式都存在一个第一个计算的位置，这个位置有如下规律：操作数优先级一定不低于右边，否则右边先计算；操作数优先级一定高于左边，否则左边先计算。</p><p>在运算表达式中，只要先计算这样的位置，就一定能符合运算顺序。因此入栈时先比对进入的是否高于左边，高于左边才入栈，否则当前元素就满足栈顶元素的“右边”，栈顶先计算。</p><p>另外，括号的表达式应当尽量低，这是因为括号给定了一个局部最低优先级，使得其内部的数只能先计算再与括号计算。括号本身的计算就是消去，对结果无影响，其低优先级的特性才对运算顺序有影响。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>线性表反映的是一种时间复杂度和空间复杂度交换的技术。当我们预设一种存储方式，就在其中包含了一维的存储信息。用链表的方式实现O(1)的相邻信息存储；用顺序表的方式实现O(1)的随机读取；用队列实现先进先出的顺序；用栈实现后进先出的顺序。</p>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】字符串查找KMP算法</title>
    <link href="/2020/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BEKMP%E7%AE%97%E6%B3%95/"/>
    <url>/2020/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BEKMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><p>为了解决重复配对问题，KMP算法的思路就是<strong>利用子串的信息，每次匹配让子串移动最大的距离</strong>。</p><p>这就涉及到如何不重复：<strong>先找出模式串（用来比对的子串）每个位置上往前读的最长相等后缀，这个相等是与从一开始往后读的进行比较</strong>, 那么比对第一位就失败，就移动一位；如果比对K位的时候失败，就找K位前的字符串是否能作为开头，预处理已经对每一位这样的情况进行了分析，现在用的时候就不需要重复比对，节省了时间。</p><p>预处理中，记开头比对的地方为i，对于j位的匹配，它前面j-1位的匹配最长长度已经知道了，只要将i往后移一位就可以知道j位是否还匹配。如果匹配就继续移，如果不匹配，那么检查一下前面可能匹配的点，注意此时i不动，i前面的串和j前面的一致，而j前面的串又和j-1的最大匹配串一致，所以去找前面还有没有可能匹配上的，如果没有，就迅速跳转到第一位，重新开始比对。</p><p><strong>解释2</strong></p><p>1.next函数：开始的n[i]的值就是匹配的最大长度，所以一定是准确的。遇到j处失配的时候，j前面的匹配串一定都被计算完了，且j-1处还是与i-1处匹配，j-1处最大匹配长度是nxt[j-1]，而nxt[j-1]也是相等的字符串在开头的结束位置，所以要跳转到nxt[j-1]，就是跳转到下一个可能相同的匹配点，再去看能不能作为i处的匹配点。当跳转到j=0的时候依然找不到，就只能认为i处无法匹配，所以n[i++]=0，注意i++是先返回再加1<br>2.KMP函数：j是子串P的比对点，i是父串T的比对点，当j失配时，j前面的都没失配，所以找到nxt[j-1]的位置，这个位置是j能左移的最大位置：满足左移后仍然有nxt[j-1]个点匹配，然后继续检测i。如果j移到0处依然不能匹配，就说明i处无法匹配了，只能从i+1处继续从头比对。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>比对一次，失配，子串滑过一段距离，下一次比对如果再失配，子串已经把最大可“滑”距离用完了，无法再移动，就只能换下一个位置比对，所以每个点最多比对2次。预处理中，检查匹配只需要检查一次，如果不行就从开头比对，每个点最多比对2次，因此复杂度是2m,总时间复杂度为O(m+n)</p>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>马恩选集笔记：关于费尔巴哈的提纲</title>
    <link href="/2020/10/05/%E9%A9%AC%E6%81%A9%E9%80%89%E9%9B%86%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%85%B3%E4%BA%8E%E8%B4%B9%E5%B0%94%E5%B7%B4%E5%93%88%E7%9A%84%E6%8F%90%E7%BA%B2/"/>
    <url>/2020/10/05/%E9%A9%AC%E6%81%A9%E9%80%89%E9%9B%86%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%85%B3%E4%BA%8E%E8%B4%B9%E5%B0%94%E5%B7%B4%E5%93%88%E7%9A%84%E6%8F%90%E7%BA%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="关于费尔巴哈的提纲"><a href="#关于费尔巴哈的提纲" class="headerlink" title="关于费尔巴哈的提纲"></a>关于费尔巴哈的提纲</h1><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><blockquote><p>人的思维是否具有客观的真理性，这不是一个理论的问题，而是一个实践的问题</p></blockquote><p>这个论述强调的核心是基于现实而非理念上的唯物主义。从现实来说，讨论“理想”的人是没有意义的，因为理论的东西无法干涉现实。相反，<strong>讨论现实中人的思维是否具有理想的真理性是有意义的</strong>，因为这个基础是现实的人，也就有了现实的作用。因此这个问题是实践的，也就是需要在现实中寻找答案的。</p><blockquote><p>关于环境和教育起改变作用的唯物主义学说忘记了：环境是由人来改变的，而教育者本人一定是受教育的。因此，这种学说必然会把社会分成两部分，其中一部分凌驾于社会之上。</p></blockquote><p>这是在其理论中剥离出“理念”的部分。不存在脱离于现实的环境和教育，也就不存在理想化的、理念的环境与教育，这势必造成环境和教育与人互相作用，甚至不能把它单独看作一个独立于人的客体来研究。</p><blockquote><p>他(费尔巴哈)做的工作是把宗教世界归结于它的世俗基础。</p></blockquote><p>马克思否认宗教世界理念的存在性，这个和费尔巴哈是一致的，但是马克思又认为宗教世界是世俗基础自身的异化，也可以说是世俗世界选择的分裂。因此宗教世界也不是和世俗世界并列的东西，而是被包括在内的。</p><blockquote><p>他把感性不是看做实践的、人的感性的活动。</p></blockquote><p>感性的意思大概是人的感知，这是被自然地包括在实践中去了，而不是单独地抽象出一个过程。</p><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><p>实践本质论虽然有进步意义，但是依然有缺陷：在实践之前，世界就没有本质了吗？为了建立宏观的结构体系，我们必须做出很多基本的、无需认证的假设，比如说一个理论必须逻辑自恰等，否则就会陷入虚无主义而无法开展研究。我认为所有理论应当有一个“经世济用”的假设，也就是说，不包含任何不可知的、形而上的东西，且不做出任何从概念到概念的论证，因为这些论证都是对实践无帮助的。相反，可以做出从概念到概念的总结，与论证不同，总结能让人更加深入地把握一个理论，具有实用的价值。</p><p>对于实践本质论，我提出几个问题：实践的定义是什么？本质是否是永恒不变的？实践本质论是可知的吗？</p><p>第一个问题涉及到语言的模糊性，一个例子是特修斯之船，深究下去，“实践”的范围是不清楚的，这就意味着一部分行为是处于模糊状态，而这部分行为是否是本质呢？本质也是没有明确标准的。事实上，所有试图在现实世界中寻找标准，也就是永恒真理的尝试，都不可能取得成功。<strong>人处在现实之内，不可能触摸到脱离现实的任何东西、概念、形体，那么因果、标准、逻辑、道德是否存在，对人而言都是可以随意假设的。</strong></p><p>关键在于，人所研究的理论应当是经世济用的理论，这个动力是先验的、无理由的。在此基础上提出认识世界的逻辑：</p><p>首先肯定客观世界的存在，否则无法将诸多规律独立于主体之外，规律也就失去效用。然后承认逻辑自恰的标准，这也是规律能够存在的条件之一。最后将若干规律视为“公理”，即无法验证真伪，但是又在当前视角下符合现实情况的规律。这些规律是不需要理由证明的，也是无法证明的。</p><p><strong>此时可以归纳地说：实践是本质的</strong>，这个结论建立在上述不需要理由的假设上，本身是上述结论的总结，不能作为其他结论的理由，也不应该作为其他结论的理由。</p><p>实践的本质性在于，所有公理依靠实践检验，一旦没有经世济用的作用，公理就失去意义。只要承认经世济用的前提，公理本身不应被人作为独立于客观世界的存在，此时公理就脱离了实践。</p><p>此时再来看“实践”和“本质”定义的模糊性：这两个词是总结性的，但是不能作为原因，这个结论存在的前提是这种解释能够达成特定的效用，也就是它所总结的规律是有效的，而就其本身的范围，实践的范围当然包括很多模糊的东西，但这并不影响它的正确性：<strong>不存在某个真理要求一个结论必须是逻辑自恰的，对于总结性的结论，只要它能单向地包括所指的性质（或者只是大部分性质），就可以说它拥有了实践上的意义</strong></p>]]></content>
    
    
    <categories>
      
      <category>哲学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>马克思</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【读书笔记】算法导论</title>
    <link href="/2020/10/04/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    <url>/2020/10/04/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="算法导论-读书笔记"><a href="#算法导论-读书笔记" class="headerlink" title="算法导论-读书笔记"></a>算法导论-读书笔记</h1><h2 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h2><p>在写OJ的时候发现自己对算法的理解相当不足，遂产生系统地学习算法的想法。这本书相当厚，在第一遍看的时候一定没法做到每道题都写完并且AC。我试想在阅读的过程中总结那些新的、巧妙的设计思想，也就是脱离编程语言的、脱离具体问题的一些普适性的算法设计和优化思路。所以在记录的时候也不会具体到某一道题，<strong>而是着重分析算法对现实世界的抽象原则以及优化思路</strong>，当然一些典型问题会记下用于解释说明。</p><p>因为不涉及具体的解题实践，这种练习被移到OJ中完成。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>一般来说，对于四则运算、数据移动、条件判断、方法调用这些指令，都是需要常量时间完成的。如果涉及内存数据的存储，那么存储花费的时间可能远多余计算所用时间。</p><p>一些指令在特定条件下会被简化：如幂乘运算在用移位法乘2的n次方的时候只需要常量时间。</p><p>一般只分析最坏情况，因为最坏情况通常和平均情况相差不大，且有时候经常出现最坏情况（数据库查找不存在的数据）</p><h2 id="分冶法：将大规模问题拆分成小规模问题"><a href="#分冶法：将大规模问题拆分成小规模问题" class="headerlink" title="分冶法：将大规模问题拆分成小规模问题"></a>分冶法：将大规模问题拆分成小规模问题</h2><h3 id="分解，解决，合并"><a href="#分解，解决，合并" class="headerlink" title="分解，解决，合并"></a>分解，解决，合并</h3><p>分冶法使用有些条件：</p><ol><li>所拆分的问题必须是独立的，互相不能依赖</li><li>子问题和母问题之间是线性组合的关系，这样能在O(N)的时间内从子问题的解得到母问题的解。</li><li>子问题和母问题必须能用同一形式表述，可以用统一的方法解决。</li></ol><p>需要处理的有两种情况：递归情况和基本情况，分别对应递归方法的继续递归选择和返回值选择。</p><h3 id="主方法求递归式的时间复杂度"><a href="#主方法求递归式的时间复杂度" class="headerlink" title="主方法求递归式的时间复杂度"></a>主方法求递归式的时间复杂度</h3><h3 id="矩阵乘法的Strassen算法"><a href="#矩阵乘法的Strassen算法" class="headerlink" title="矩阵乘法的Strassen算法"></a>矩阵乘法的Strassen算法</h3><h2 id="贪心法："><a href="#贪心法：" class="headerlink" title="贪心法："></a>贪心法：</h2><h3 id="最大子数组问题"><a href="#最大子数组问题" class="headerlink" title="最大子数组问题"></a>最大子数组问题</h3><p>最大子数组问题：在一个数的序列里面，寻找一个序列和最大的连续序列。</p><p>这个问题可以找出一个具有全局性质的指标：假设<code>a_i</code>是最大子数组左侧角标，那与<code>a_i</code>相连的任意左侧子数组都不可能有正和，任意右侧子数组都不可能有负和（在右侧角标左边的数组），于是对于左侧角标，它能被贪心算法命中一次，且此时全局最优解一定能被遍历一次，然后用擂台法就可以得到结果了。</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>opencv基础学习</title>
    <link href="/2020/08/10/opencv%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/08/10/opencv%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="opencv基础学习笔记"><a href="#opencv基础学习笔记" class="headerlink" title="opencv基础学习笔记"></a>opencv基础学习笔记</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在硬设开发的期间需要用到图像识别的功能，于是安装了opencv试图利用现成的库来实现。虽然只是调库，但是基本的概念还是得弄清楚，否则在其之上的修改就没法做了。这篇笔记主要记录opencv的基础概念，参照的是官方的tutorial，做的是一个总结式的笔记。和之前的笔记一样，也是重思想不重细节。</p><h3 id="Mat-图像的C-类抽象"><a href="#Mat-图像的C-类抽象" class="headerlink" title="Mat 图像的C++类抽象"></a>Mat 图像的C++类抽象</h3><p>mat组成就是一个代表灰度的矩阵+header,其中header存储矩阵大小、内存位置等信息。但是图像抽象并非如此简单：mat考虑到了内存管理问题，引入了counting system，并且对cv程序中的常用场景（图像传递）进行优化，减少大量复制带来的性能损耗。</p><p><strong>counting system</strong></p><p>多处引用带来一个问题：谁来释放这片内存？在reference counting mechanism的机制下，<strong>当程序中没有任何指针指向这片内存时，就代表它可以被释放了</strong>，没有指针指向内存，代表程序在这个时候是看不见这片内存的，也就无法利用其中的信息。reference counting并非要记录最后剩下的是“哪个”引用，因为哪一个都是无所谓的。这就像游乐园进场的数数一样，每进去一个就数一个数，在数到满员的时候让下一个游客等待下一轮再进去。</p><p><strong>color space</strong></p><p>不同色域的区别有两个：储存在矩阵中数值的范围和各层间的呈色方式。影响矩阵的只有前者，但是这也代表指定mat的时候就要指定颜色的分解方式。</p><p>另外，mat也提供了对图像的一个部分引用，或者是对图像中的颜色进行整体替换的功能。</p><h3 id="Feature-Matching-图像特征匹配"><a href="#Feature-Matching-图像特征匹配" class="headerlink" title="Feature Matching 图像特征匹配"></a>Feature Matching 图像特征匹配</h3><p>突然跳到这里是因为目前需要先理解这部分的内容。</p><p><strong>Matcher</strong></p><p>特征匹配简单地来说，就是选取图像的一部分计算出一个“特征”，这个特征进入到特定的数学空间中，此空间可以具有抗旋转、抗缩放、抗亮度变化等特性，也就是说这些变换并不会使同一个特征偏离太远。这个“距离”也是由数学空间所定义的。</p><p>Matcher操作的元素是Descriptor，也就是描述符，测量的量是两者的距离，操作的方式是逐一测量，并选出最接近的两个描述符（Brute-Force Matcher），距离的描述方式不一，可以是L1范数，也可以是L2范数。</p><p>一个DMatch Object抽象的是一对匹配的特征符，存储了特征符的序号、距离、图像序号。</p><p><strong>Descriptor</strong></p><p>matcher本身并不包含技术性的东西，特征符的选取和其在数学空间的位置都是由算法决定的，这个算法就是SIFT, ORB等。不同算法的选取方式不同，但不同的descriptor都在线性空间中，这就为Descriptor和matcher的解藕提供了基础。</p><p>descriptor在opencv中表现为一个高维向量，descriptor和key point共用一个序号来代表一个特征点的性质</p><p><strong>Key point</strong></p><p>关键点包括3个内容：位置、尺度、方向。位置指关键点在图像上的位置，这里的图像是经过尺度变换得到的。方向是关键点具有旋转不变性的原因：同一组关键点的方向应该是一致的，因此统计出整个图像的方向后，就可以还原出图像被旋转的角度（如果整个图像方向为0，那就类似圆形）。</p><p>Test: origin to scale_up:<br>– Max dist : 0.614476<br>– Min dist : 0.023140<br>normalized delta x=0.0046309<br>normalized delta y=0.0441643<br>normalized center=-0.0114116<br>Test: origin to left:<br>– Max dist : 0.593219<br>– Min dist : 0.025086<br>normalized delta x=-0.187185<br>normalized delta y=-0.0130463<br>normalized center=0.0207472<br>Test: origin to right:<br>– Max dist : 0.628698<br>– Min dist : 0.021708<br>normalized delta x=0.141781<br>normalized delta y=-0.0297364<br>normalized center=-0.0214759<br>Test: origin to up:<br>– Max dist : 0.679967<br>– Min dist : 0.036778<br>normalized delta x=-0.037491<br>normalized delta y=-0.216021<br>normalized center=0.0254128<br>Test: origin to down:<br>– Max dist : 0.537027<br>– Min dist : 0.024740<br>normalized delta x=0.00706097<br>normalized delta y=0.0883386<br>normalized center=0.0443451</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自平衡小车开发笔记</title>
    <link href="/2020/07/26/%E8%87%AA%E5%B9%B3%E8%A1%A1%E5%B0%8F%E8%BD%A6%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/07/26/%E8%87%AA%E5%B9%B3%E8%A1%A1%E5%B0%8F%E8%BD%A6%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="陀螺仪模块"><a href="#陀螺仪模块" class="headerlink" title="陀螺仪模块"></a>陀螺仪模块</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>MPU6050是一个陀螺仪模块，最近在做单片机的时候需要用到姿态估计，但是这个东西内部机理比较复杂，而且搜了一圈没有找到详细的教程，这个笔记包括硬件接口的解读和信号处理，因为做的项目是平衡车，所以会牺牲刷新率和角度范围来尽量提高精度。</p><h3 id="加速度计"><a href="#加速度计" class="headerlink" title="加速度计"></a>加速度计</h3><p>首先要明确加速度计测的是什么：加速度计的等效模型是一个铁球在正方体盒子中达到与正方体保持相对静止时与各个面的压力（规定正方向，一对面的压力就有了符号），这也就是说，铁球加速度时刻等于盒子加速度（不然他俩无法保持相对静止），铁球被封闭在盒子内，接触力只有压力，非接触力有重力、磁力等，但是在实际的加速度计中，是没有铁球的，也就没有磁力。</p><p>那么，可以推出：</p><p><strong>传感器加速度=测量加速度+重力加速度</strong></p><p>这里的三个加速度要转换到同一坐标系</p><img src="/2020/07/26/%E8%87%AA%E5%B9%B3%E8%A1%A1%E5%B0%8F%E8%BD%A6%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/2020-07-26-20-14-32.png" srcset="/img/loading.gif" class=""><p>我们需要用测量加速度得到传感器姿态，也就是传感器坐标系到地面坐标系（重力加速度所在坐标系，也是人观察的坐标系）的映射规律，3个已知量解出3个未知量，这就要求传感器加速度已知。这个要求是加速度计自身办不到的，需要借助其他模块。</p><p>但是，平衡车这一例子上，可以借助结构带来的额外条件用加速度额外解出角度。</p><p>当加速度计被绑定在平衡车上时，我们假设在短时间内平衡车车轮制动，那么整个车体相当于一个木杆，加速度只能有一个方向：与杆垂直的方向。我们将传感器的总加速度加上重力加速度，也就得到测量加速度。<strong>这个加速度在Z轴上的投影大小等于重力加速度在Z轴上投影的大小</strong>，用反余弦直接就可以解出角度。</p><p>为此，需要的条件是：短时间内维持车轮制动，在短时间达到近似静止或匀速运动，并对传感器高速采样，得到足够精确的结果。</p><h3 id="角速度计"><a href="#角速度计" class="headerlink" title="角速度计"></a>角速度计</h3><p>在非平衡状态时，加速度计就不可用（其实也可以作核算），这时对角度的计算就用角速度的积分。</p><h1 id="电机控制"><a href="#电机控制" class="headerlink" title="电机控制"></a>电机控制</h1><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>步进电机在调试后暴露出的缺点是：速度太快，加速减速算法太复杂，而且静止状态会过热。改进的方法是选用A4988，并采用16细分模式。利用A4988的最大电流控制，将静止电流设置在0.7A左右，这样基本就不会发热。剩下的技术难点就是pwm调频进行速度控制。</p><h3 id="pwm底层调频"><a href="#pwm底层调频" class="headerlink" title="pwm底层调频"></a>pwm底层调频</h3><p>步进角1.8度，16细分后一圈是3200步。uno主频16MHz, 预除数1，8，64，256，1024，timer1支持计数器到65535, timer2支持到256, 两者最低pwm频率分别是0.23Hz和61Hz。</p><p>轮子直径5cm, 换算成线速度，timer2支持的最小线速度是0.31cm/s，在不改变scale的时候最大线速度是80cm/s左右，完全支持所有使用情景。</p><p>得出公式：c = (5000 * pi * d) / (p *s); 其中c是比较器上限(0-255)，d是轮子半径，p是preScale大小，s是轮子线速度。d和s的长度单位统一，时间单位是秒。默认16细分。</p><p>如果只计算赫兹数的话，c = 16 * 10^6 / (p * f); 其中f是输出频率。</p><p>为了让速度的离散分布尽量均匀，我们预先对不同速度进行分区。先作出不同预除数的可能</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>这里记一下位运算的结果：</p><pre><code class="hljs plain">   &#x2F;&#x2F; turn on CTC modeTCCR1B |&#x3D; (1 &lt;&lt; WGM12);&#x2F;&#x2F; Set CS10 and CS12 bits for 1024 prescalerTCCR1B |&#x3D; (1 &lt;&lt; CS12) | (1 &lt;&lt; CS10);</code></pre><p><code>a &lt;&lt; b</code> 表示a左移b个bit，假设这里WGM12=3,那么右移运算就是1000，而TCCR1B被初始设定为0，或操作以后就直接把WGM12寄存器的值赋为1。所以这里用麻烦的宏定义的原因就是便于直接读出寄存器的值。相应地多个寄存器的操作用或来连接（因为都是0，所以或操作不会覆盖什么东西）</p><p>至于寄存器的值对应pwm的状态，参考芯片的datasheet，注意这里设置的都是fast pwm模式。</p><img src="/2020/07/26/%E8%87%AA%E5%B9%B3%E8%A1%A1%E5%B0%8F%E8%BD%A6%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/2020-08-01-23-03-51.png" srcset="/img/loading.gif" class=""><p>因为频率和寄存器中阈值的反比关系，线速度的分布是不均匀的。可以实时对预除数进行调整，从而保证在一个相当大角速度范围内近似均匀的pwm输出</p><h1 id="控制算法"><a href="#控制算法" class="headerlink" title="控制算法"></a>控制算法</h1><p>采用的是PID双环控制：速度环和距离环，前者维持小车平衡，后者维持小车位移不变。开发过程中也有一些问题，这里列举出来：</p><h3 id="控制量的符号关系"><a href="#控制量的符号关系" class="headerlink" title="控制量的符号关系"></a>控制量的符号关系</h3><p>假设角度、加速度、电机速度三者的正方向在初始点是一致的，PID输入、输出、目标点关系已知，那么在小车运用中需要额外改变符号：</p><p>假设小车前倾，角度为正，角度输入速度环，得到负的速度输出：这里的负号指PID算法试图让小车角度回正，那么对应电机速度应该是正向，因此需要加一个负号。</p><p>假设小车前倾，角度为正，速度环输出为正（已修正），电机速度为正，但是小车行驶了一段距离，偏离原点，此时距离环接受速度环的输出为正，距离输出为负，对角度影响为负，不需要变号。</p><h3 id="PID参数解析"><a href="#PID参数解析" class="headerlink" title="PID参数解析"></a>PID参数解析</h3><p>速度环确保小车不会倒下（稳定在某个角度），将车轮速度看作“修正力”，而将角度看作“目标”的话，角度受到重力加速度分量影响，也就是存在一个“阻力”，P参数代表原始的修正力，角度越大，修正力越大。I参数代表抗衡重力加速度分量的一个力，在I参数影响下，小车受到的等效重力减小了许多，落入了能被P参数修正的区间内（如果单纯地调大P参数，会使P的作用力累积导致结果发散）。D参数用角速度控制速度，对角度的周期性震荡进行衰减，但数值太大会造成调控力度不够，收敛时间延长。</p><p>距离环其实输入的是距离微分（速度乘以时间间隔），输出是角度。I参数用距离控制倾斜角度，这当然会将系统引向不稳定状态，I较大的时候距离调整更迅速，但是I依赖于速度环的控制能力，而且I太大会引起周期震荡。考虑到采样的间隔还是比较均匀的，P参数可以看作用速度控制倾斜角度，也就是对周期性震荡进行衰减，但是P太大也会引起周期震荡，这个参数的确定与重力加速度有关。D参数用加速度调整角度，也是让运行更加平稳。</p><p>偏移时，距离信息存储在距离环的I参数中，当小车在另一个位置稳定时，I参数可以引导小车回到原地，因此距离环具有调整距离的作用。</p><h3 id="抗干扰"><a href="#抗干扰" class="headerlink" title="抗干扰"></a>抗干扰</h3><p>角度零漂等效于小车放在斜坡上：速度环的I参数对抗恒定阻力，所以没有问题，仿真中去掉I参数后小车确实以恒定速度向前移动了。</p><h1 id="GUI设计"><a href="#GUI设计" class="headerlink" title="GUI设计"></a>GUI设计</h1><h3 id="bug汇总"><a href="#bug汇总" class="headerlink" title="bug汇总"></a>bug汇总</h3><p>这里记录一些开发过程中遇到的bug，都是比较玄学的东西。</p><blockquote><p>__acrt_first_block == header</p></blockquote><p>这是DLL和exe没有共用一个栈导致的，原因是vs项目设置里没有设置动态链接dll模式（MDd），改过去以后就OK。</p><blockquote><p>esp32上传的代码时好时坏</p></blockquote><p>串口使用前要println，上传时要选no IDE，不能用arduino IDE，也是一个非常玄学的问题。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>硬设算是结束了，但是很多技术细节都没有记下来，留待以后慢慢补充。这里先总结一些需要改进的地方（包括技术、展示、软硬件设计等）</p><h3 id="缺乏合适的测试环境，测试周期过长"><a href="#缺乏合适的测试环境，测试周期过长" class="headerlink" title="缺乏合适的测试环境，测试周期过长"></a>缺乏合适的测试环境，测试周期过长</h3><p>测试环境是一个软硬结合的环境。因为自平衡小车的特殊性，测试过程中需要大量的调试。尽管我已经在设计上对小车的软硬件进行解耦，但是后期出现的转向问题、指令过渡问题等都是需要大量测试来debug的，更不用说PID调参。</p><p>理想情况下，应当有一个尽可能快速的测试周期：</p><ol><li>小车的平衡检测可以只做一次，时间可以缩短；</li><li>完善debug输出指令，可以指定输出内容；</li><li>在小车最大电流和输出功率间找到平衡点，尽量降低耗电；</li><li>寻找一个宽敞的测试环境，事先用水平仪测量保证排除地面平整度因素</li><li>前期基础性测试中对各种异常现象汇总，有意设置异常情况（放置角度不水平、任意时刻外加扰动），避免多层次bug互相影响</li><li>仿真协助测试：先给出原理可行性，再进行实际调参</li><li>每个模块都有单元测试和集成测试，不能同时对几个模块进行测试。</li></ol><h3 id="时间分配不合理，功能展示不够灵活"><a href="#时间分配不合理，功能展示不够灵活" class="headerlink" title="时间分配不合理，功能展示不够灵活"></a>时间分配不合理，功能展示不够灵活</h3><p>这主要是针对展示环节提出的，展示时双方分工没有安排好，启动时间比较长，而且触摸模块鲁棒性太差，好几次启动失败。功能展示的时候没有体现出显著性，没有方便的展示样例，导致图像识别部分也没有对应实例，拿不出可信的东西。出bug的时候也没有优先进行接下来的展示，总体来说，前期缺乏磨合训练，临场发挥不够灵活。</p><h3 id="debug没有遵照原则，浪费了大量时间"><a href="#debug没有遵照原则，浪费了大量时间" class="headerlink" title="debug没有遵照原则，浪费了大量时间"></a>debug没有遵照原则，浪费了大量时间</h3><p>debug的时候思考不够冷静，只想用自己推断来快速找到原因，但很多情况都没有思路，反而在浪费时间。</p><p>另外，一些调试手段过于繁杂，缺乏自动化设计，进而在大量测试时不可避免地引入偶然误差，同时分散了人的精力。</p><p>debug的一些经验：</p><ol><li>发现bug的时候先进行复现，进而确定出错的情景范围。</li><li>屏蔽掉若干无关模块，特别是未测试过的模块</li><li>对可复现的bug逐步排查无关变量，从而确定最核心的出错情景</li><li>添加若干调试输出，缩小排查范围</li><li>找到最核心的出错位置，初步确定几个可能性</li><li>先做出简单的改动，检验思路是否正确</li><li>最后锁定一个思路，设置关键性的调试输出，或者进行一些特定操作来复现</li><li>每一次复现时都尽可能保持测试环境的一致性。</li><li>尽量采用自动化设计。</li></ol><h3 id="代码素养不够好"><a href="#代码素养不够好" class="headerlink" title="代码素养不够好"></a>代码素养不够好</h3><p>这是两方面的：一方面指自身应当写出良好的代码，另一方面指不能让极差的代码进入项目中来。至少应当对其进行最起码的修复。</p><p>GUI编写上，这次比较成功地用MVC思想进行前后端分离，但是也出现了后端单个类过于庞大的问题。在写实时位置显示时，没有想清楚具体的控制和显示关系，导致写出来的东西有很多逻辑自相矛盾的地方。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>软硬结合的作品最核心的瓶颈就是调试，如何在有限次调试中尽量确保作品鲁棒性强，这就要求有高自动化的测试步骤、详细的数据记录、尽量可靠的原理性仿真和一些工程上的冗余。通过引入分层设计的思想，能够快速定位bug的发生位置。统一且可靠的代码风格能够避免很多潜在的bug。</p><p>另外，这次硬设的一个经验是：任何自己没想清楚的环节，到最后都会成为问题。从初创到成品的过程本身就是一个不断细化的过程，任何设想最终都落实在代码上，一些小小的意料外因素最后也会成为一个障碍，因此最好在最开始的时候就追问所有的细节：<strong>这个细节该如何实现？是否具有工程可行性？</strong>，以此来督促自己摆脱空想、面对现实。</p>]]></content>
    
    
    <categories>
      
      <category>硬件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>arduino</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【读书笔记】QT5.9C++开发指南</title>
    <link href="/2020/07/25/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91QT5.9C++%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    <url>/2020/07/25/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91QT5.9C++%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="QT学习笔记"><a href="#QT学习笔记" class="headerlink" title="QT学习笔记"></a>QT学习笔记</h1><p><strong>前言</strong></p><p>最近写了Blog自动上传的脚本…对VS CODE的了解也更丰富了, 尽可能地避开图形界面的弊端, 提高工作效率. 这篇文章只记录我在学习QT中遇到的优秀的设计思想, 而并不关心QT框架的语法细节或者是使用经验.</p><h2 id="Signal-Slots-信号与槽"><a href="#Signal-Slots-信号与槽" class="headerlink" title="Signal/Slots 信号与槽"></a>Signal/Slots 信号与槽</h2><p>这可以说是QT第一个也是最重要的一个设计思想, 在MVC框架下, 解决组件的互相通信以及Model和Components之间的互相通信问题. </p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>QT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【读书笔记】精通Cocos2d-x游戏开发(基础卷)：程序设计思想札记</title>
    <link href="/2020/07/24/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E7%B2%BE%E9%80%9ACocos2d-x%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91(%E5%9F%BA%E7%A1%80%E5%8D%B7)%EF%BC%9A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E6%9C%AD%E8%AE%B0/"/>
    <url>/2020/07/24/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E7%B2%BE%E9%80%9ACocos2d-x%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91(%E5%9F%BA%E7%A1%80%E5%8D%B7)%EF%BC%9A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E6%9C%AD%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="【读书笔记】精通Cocos2d-x游戏开发-基础卷-：程序设计思想札记"><a href="#【读书笔记】精通Cocos2d-x游戏开发-基础卷-：程序设计思想札记" class="headerlink" title="【读书笔记】精通Cocos2d-x游戏开发(基础卷)：程序设计思想札记"></a>【读书笔记】精通Cocos2d-x游戏开发(基础卷)：程序设计思想札记</h1><h1 id="程序设计思想札记"><a href="#程序设计思想札记" class="headerlink" title="程序设计思想札记"></a>程序设计思想札记</h1><p>这本书是我从2020-6-16开始学习的，目的大概是为了完成小学期的作业吧，书中有一句话启发了我，大概意思是“编程学习的是思想，而不是记忆代码。”我觉得很有道理，于是打算用这篇札记记录自己学到的程序设计<strong>思想</strong>，尽量用脱离具体实现的方式将优劣势讲清楚，便于以后独立设计一个系统时来参考。但一些总结性的东西会具体写出来。</p><p>这篇笔记可以看作读书笔记，也可以看作大作业的心得总结，当然详细的总结会放在技术文档和开发日志里，这里只是写一些闲言碎语吧。</p><hr><h3 id="可读性和可维护性：C-变量命名规则"><a href="#可读性和可维护性：C-变量命名规则" class="headerlink" title="可读性和可维护性：C++变量命名规则"></a>可读性和可维护性：C++变量命名规则</h3><p>变量命名指南：</p><ul><li>不在变量名中写变量类型：减少重复和低效</li><li>减少容易混淆的词：英语中很多词无法从部分推出整体词义，那么应当用构词法描述一个变量</li><li>尽可能具体，方法命名要一目了然</li><li>用稍长的变量名代替简短变量名+单行注释：减少阅读者的记忆负担</li><li>不要用类似val/value/result/temp/count/str这种无意义变量名</li><li>正确使用惯用语：i,j,k,n,e</li><li>生命周期比较短的变量，命名也相对要短：长命名的潜台词是“这是值得注意的变量，需要被记住”</li><li>合理使用一次性变量：并列式长代码需要拆分，嵌套式短代码需要合并<br>驼峰命名法相比于下划线，占地小，紧凑性更好，有些时候区分类和变量时，类用大写驼峰，变量用小写驼峰。但也有自己的缺点，比如HTTP，ID这种缩写词，而且在查找变量的时候必须加上大小写通配。</li></ul><p>还有一些技巧；</p><ul><li>变量、类用名词，方法和函数用动词</li><li>控件命名保留匈牙利命名法，如button-btn, label-lbl等</li><li>对容易用错的变量（比如指针和对象、全局变量），可以保留匈牙利命名法：</li></ul><ol><li>指针加p：避免-&gt;和.用错</li><li>全局变量加g_, 静态变量加s_：这些都是容易出bug的</li><li>成员变量加m_：避免和外部变量重叠<br>总地来说，变量命名需要考虑阅读效率、阅读无歧义、写作效率、写作无歧义、搜索效率、规避潜在风险、规则的简化等，是需要语言学与心理学还有编程经验三者深度融合后才能进行改进的。这次的工程也会采用这些规则来规范编写。</li></ol><h3 id="引擎与顶层逻辑的交互：回调、封装"><a href="#引擎与顶层逻辑的交互：回调、封装" class="headerlink" title="引擎与顶层逻辑的交互：回调、封装"></a>引擎与顶层逻辑的交互：回调、封装</h3><p>对于一个节点来说，加入节点树后，引擎会自动在某些时刻调用方法：初始化，添加进场景时，删除时。对于一些节点，需要每帧进行检测，那么就需要自定义回调函数，并且向引擎“注册”。有时引擎接受到外部输入时，需要将其反馈给节点，那么节点需要事先指定一个回调函数用于接收。</p><p>将外部输入和渲染看作一极，顶层逻辑看作另一极，那么游戏引擎就是连接两极的纽带，为了进行有效的沟通，诞生了消息传递和update等机制。</p><h3 id="内存泄漏与日志统计"><a href="#内存泄漏与日志统计" class="headerlink" title="内存泄漏与日志统计"></a>内存泄漏与日志统计</h3><p>内存泄漏指的是：在堆中创建对象后，没有在结束前进行回收。这个问题非常隐蔽：</p><blockquote><p>…他在维护这份代码的过程中，向其中添加了一些错误判断，如果发生错误，返回什么…但他在添加代码时，所有的返回语句都忘记把这块内存删掉了</p><p>任何一个系统的维护都是长效性的，内存泄漏也是。一种解决方法就是，将构造函数与析构函数的执行次数输出到日志中，这样程序结束后统计日志，就可以发现潜在问题了。</p></blockquote><h3 id="C-11的lambda表达式"><a href="#C-11的lambda表达式" class="headerlink" title="C++11的lambda表达式"></a>C++11的lambda表达式</h3><p>当我们需要在函数内部临时建立一个函数处理一些灵活的工作时，可以构建一个lambda函数：</p><blockquote><p>std::function&lt;return type()&gt; func1 = [capture list] (params list) mutable exception-&gt; return type { function body }</p></blockquote><p>lambda函数func1像变量一样被创建出来，被储存为std::function类型。capture list规定了func1能够利用的外部变量（范围是func1被创建时所能操作的变量），然后params list规定了调用func1时额外传入的参数，mutable修饰符表示函数可以改变捕获的变量（临时改变供自己使用？），exception抛出异常（允许函数体内部用throw()抛出异常）</p><p>但是需要注意，lambda的capture list中的变量是在<strong>创建时就定下来的</strong>，如果是引用捕获&amp;，捕获的是一个引用，func1创建后的修改会有影响，而如果是值捕获=，就只有当时的值，此时对捕获变量的修改都是没有意义的。</p><h3 id="template与可变参数模版"><a href="#template与可变参数模版" class="headerlink" title="template与可变参数模版"></a>template与可变参数模版</h3><p>这篇文章介绍了模版的应用：<a href="https://blog.csdn.net/lianhunqianr1/article/details/79966911" target="_blank" rel="noopener">https://blog.csdn.net/lianhunqianr1/article/details/79966911</a></p><blockquote><p>C++标准委员会采用一套类似函数式语言的语法来设计C++模板，而且设计成图灵完备 (Turing-complete)（详见参考），我们可以把C++模板看成是一种新的语言，而且可以看成是函数式编程语言，只是设计依附在(借助于）C++其他基础语法上（类和函数）。</p></blockquote><p>模版有其复杂的使用方法，但是这里只记录它的思想。首先是“简化”思想，运用模版编程后，不需要对每个类型单独设计一套规则，这就将相似的东西合并起来，大大简化了代码量。第二点是“灵活”，有时候程序员不知道也不需要知道一个类的确切形象，只要知道可供操作的一部分就行了，这时候只有用模版才能开发出具有普适功能的算法和容器。第三点是“动态生成代码”，模版的工作是在编译期和运行期进行的，一些典型场景中（比如用if进行类型判断），一部分花销可以从运行期迁移到编译期，这样就减小了运行开销。</p><p>模版是泛型的基础，泛型中一个思想就是<strong>“Substitution failure is not an error”</strong>，意思是对类型的适配有多次尝试，编译器会自动推导可行的方案（比如对不同参数的函数调用，自行适配合适的参数），然而一次尝试的失败并不是程序错误，只有所有尝试失败才是错误。也就是说，编写者需要设计出任何情况下至少有一种方案能够被执行的代码。自然，智能化的代码需要更加更加智能化的编写者。</p><p>可变参数模版的关键在于参数调用，这里的思想是<strong>匹配调用</strong>或者<strong>递归调用</strong>，后者是前者的延伸。匹配调用也就是：既然不知道参数长度，那么就准备多个函数，逐一匹配合适的函数即可。而递归调用将承接可变长参数的函数func1与解析的函数func2合二为一，将参数列表设为前n个固定参数与最后的可变参数，然后递归调用自身，这样就逐一解出所有参数，但是注意取值为n时，需要准备n-1个函数用来处理递归最后的“余数”，这一点是模版元编程需要考虑“全体情况”的表现。</p><h3 id="变量的四个属性：数值、类型、const、右值（C-11）"><a href="#变量的四个属性：数值、类型、const、右值（C-11）" class="headerlink" title="变量的四个属性：数值、类型、const、右值（C++11）"></a>变量的四个属性：数值、类型、const、右值（C++11）</h3><blockquote><p>通过是否可取地址操作符，以及是否有名字，可以判断是否为右值。右值是指表达式结束后就不存在的临时对象。</p></blockquote><p>在模版变成时，当然需要处理右值的函数，然而在模版的嵌套、转发中，右值可能变成左值（也就是本来赋值完就销毁的变量却拥有了自己的地址和名字）。这时用C++11提供的引用<code>T&amp;&amp;</code>就可以同时保留变量的四个属性，做到“完美转发”</p><h3 id="虚函数与多态特性"><a href="#虚函数与多态特性" class="headerlink" title="虚函数与多态特性"></a>虚函数与多态特性</h3><p>这里参考这篇文章：<a href="https://blog.csdn.net/hackbuteer1/article/details/7558868" target="_blank" rel="noopener">虚函数与纯虚函数的区别</a></p><p>虚函数蕴含的思想是<strong>多态</strong>，整个代码的执行情况对于编译器来说并不是单一的（虽然从结果上，它只能是唯一的，但编译器不需要知道整个情况）。因此，虚函数调用不取决于类型，而取决于实际初始化的类型，就如下面的代码：</p><pre><code class="hljs plain">int main(void)&#123;    A *a &#x3D; new B();    a-&gt;foo();   &#x2F;&#x2F; 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!    return 0;&#125;</code></pre><p>但是，基类定义了虚函数，子类才能继承并重载，这时候我们依然可以用基类生成一个对象，而这样的对象是不合理的：基类本该是抽象的东西，却可以被实例化。因此，纯虚函数<code>virtual void funtion1()=0</code>，规定了其必须被重写，而且这样的基类不可以被继承。</p><p>可以看出，虚函数和纯虚函数的引入是将现实中的抽象和具象关系体现在代码上，让代码更加安全，同时把“抽象”作为内嵌在语言的特性推广为所有开发者的共识，降低代码理解难度。</p><h3 id="节点继承与回调方法：Cocos2dx引擎与顶层的交互接口"><a href="#节点继承与回调方法：Cocos2dx引擎与顶层的交互接口" class="headerlink" title="节点继承与回调方法：Cocos2dx引擎与顶层的交互接口"></a>节点继承与回调方法：Cocos2dx引擎与顶层的交互接口</h3><p>在处理游戏内容的可拓展性上，cocos2d采用的思想是<strong>继承和回调</strong>，通过对节点类Node的继承，实现游戏内容的多样性和统一性。而事先规定好特定的回调函数，在约定的时刻由引擎调用，就实现了游戏逻辑的可拓展性。</p><p>回调函数：</p><ul><li>init初始化节点时调用</li><li>onEnter被添加进场景中调用（这里是二次初始化）</li><li>onExit节点从场景删除</li><li>update与时间相关，比如每一帧的逻辑、定时逻辑<br>可以认为继承是引擎为内容维度提供的接口，回调是引擎为逻辑维度提供的接口，游戏顶层设计在这两个维度上与引擎进行交互。</li></ul><h3 id="内存池设计"><a href="#内存池设计" class="headerlink" title="内存池设计"></a>内存池设计</h3><p>内存池的思想是将大大小小的内存申请需求统一，以此来<strong>用额外的内存空间为代价换取低频的内存扩展请求</strong>。这是由于技术的发展，使得内存不再需要节约使用，而更需要低频使用。</p><p>内存池的基本功能：</p><ul><li>接管原本代码中的new和delete/free功能，先申请一大块内存空间，再自行决定分配。同时释放的时候也可以暂时不delete，减少频率</li><li>内存池本身申请内存时，做到连续，低频，且尽量占用少（这三者其实是互相矛盾的）</li><li>内存空闲太多时，需要释放一部分内存。<br>PS：这一部分就实现了自主选题中的内存管理需求</li></ul><h3 id="cocos2d-x运行机制解释"><a href="#cocos2d-x运行机制解释" class="headerlink" title="cocos2d-x运行机制解释"></a>cocos2d-x运行机制解释</h3><p><strong>与windows系统关联的启动机制</strong></p><ol><li><code>_tWinMain</code> 作为入口，初始化实例AppDelegate</li><li>调用Application::getInstance()-&gt;run(); 回调applicationDidFinishLaunching，完成制作者自定的初始化</li><li>windows下的OpenGL进行底层交互处理（键盘，窗口最小化等），GLFW直接与Director等进行信息传递</li></ol><p><strong>引擎内部的运行机制</strong></p><ol><li><p>全局初始化：AppDelegate中的applicationDidFinishLaunching，可添加开发者自己的初始化代码</p></li><li><p>进入DisplayLinkDirector的mainloop（），其中的drawScene()对每一帧进行场景渲染和逻辑执行：</p></li><li><p>执行schedule的update进行逻辑更新：schedule作为调度器驱动action更新，并且执行每一帧的游戏逻辑和关于时间的逻辑</p></li><li><p>Director直接控制游戏的暂停、恢复、结束、场景切换（但判断逻辑并不在这里）</p></li><li><p>场景渲染</p><h3 id="消息、逻辑、调度交互"><a href="#消息、逻辑、调度交互" class="headerlink" title="消息、逻辑、调度交互"></a>消息、逻辑、调度交互</h3></li></ol><p><strong>消息的观察者模式：包括注册、触发、处理、注销四个步骤</strong></p><hr><p>这里首先介绍一些C++11的bind机制：</p><pre><code class="hljs plain">void TestFunc(int a, char c, float f);auto bindFunc1 &#x3D; bind(TestFunc, std::placeholders::_1, &#39;A&#39;, 100.1);bindFunc1(10);</code></pre><p>bindFunc1将一个3个参数的函数变成1个参数，2个“定量”的函数，bind第一个参数对应目标函数，后面的placeholder就对应使用时需要传入的东西。需要注意的是，预先设定的参数都是按值传递的。</p><hr><p>这里来总结观察者模式：</p><p><code>auto listener = EventListenerKeyboard::create();</code>：创建监听器，申请得到一个实例</p><p><code>listener-&gt;onKeyPressed = CC_CALLBACK_2(HelloWorld::fighterMoveCallback, this);</code>：指定监听器的哪个事件会触发哪个实例的哪个成员函数，本质上是对listener的成员指针指定要一个bind()，这里的this指当前场景的实例</p><p><code>_eventDispatcher-&gt;addEventListenerWithSceneGraphPriority(listener, this);</code>：向Director注册（_eventDispatcher其实是封装了向Director相关函数），监听器本身是绑定在节点（这里是Scene）上的，而监听器本身也拥有一个指向回调函数的指针。</p><p>触发由引擎和底层负责，这里只需要实现HelloWorld::fighterMoveCallback方法即可。</p><p><strong>调度器：Schedule</strong></p><p>Scheduler是一个全局调度器，可以从Director中获取指向它的指针，调度的本质就是<strong>在规定的时间由引擎调用某个实例的成员函数</strong>，所以需要3个元素：指向调度器的指针，指向实例的指针，实例的成员函数。</p><p>一般来说，调度器的指针是很容易获得的，实例的指针用this即可实现，所以调度一般定义在该实例对应的类中。</p><p>回调按类型分为update回调（每一帧执行的回调），对象回调和函数回调，脚本回调，执行回调。对象回调其实也是调用函数，只不过这个函数是事先约定的形式：</p><p><code>typedef void (CCObject::*SEL_SCHEDULE)(float)</code>：这里规定了一种类型叫SEL_SCHEDULE，它被定义成一个指针，指向一个CCObject类或派生类的成员函数，而这个成员函数的参数必须是float，返回类型必须是void。</p><p>调度器注册时机：</p><ul><li>Node回调函数中，如onEnter或onExit，会在下一帧开始计时</li><li>单击回调，会在当前帧立刻计时</li><li>计时回调内嵌套回调：难以控制时间<h3 id="cocos2d-x顶层逻辑设计"><a href="#cocos2d-x顶层逻辑设计" class="headerlink" title="cocos2d-x顶层逻辑设计"></a>cocos2d-x顶层逻辑设计</h3></li></ul><p>今天终于是把书差不多啃完了……以现在的预期来看，UI界面只能靠手画，同时分辨率固定，这些暂时没法解决。其他的主要在顶层规划，这也是相当考验能力的环节。</p><p>从内容上来看的话，我将游戏设计拆分成以scene为主的“内容切片”</p><ul><li>scene内加载要考虑耦合度，可能会复用的加载模式不可以在单个scene做</li><li>游戏UI独立于画面，设置继承Node的UINode，游戏UI不写在场景加载里，以便重复调用</li><li>各scene间进行解耦，每个继承的scene间的数据传输用约定的方法进行通信，尽量将数据传输大的scene进行整合</li><li>游戏逻辑去中心化，但是约定用tag进行全局的自由通信，游戏与固定的非组件部分存储指针通信</li><li>对于动态产生的节点，不存储指针，每次访问时调用方法获取实时数据。</li><li>对于复杂的逻辑控制，抽象出一个逻辑节点来做。<h3 id="debug-类之间的互相包含"><a href="#debug-类之间的互相包含" class="headerlink" title="debug:类之间的互相包含"></a>debug:类之间的互相包含</h3></li></ul><p>今天debug的时候遇到了这个问题，两个类的定义互相包含，这时候要用前置申明，而且不能写继承关系。</p><h3 id="关卡设计中的序列模式与难度设置"><a href="#关卡设计中的序列模式与难度设置" class="headerlink" title="关卡设计中的序列模式与难度设置"></a>关卡设计中的序列模式与难度设置</h3><p>首先要解决两个问题：在阶段BOSS和最终BOSS被击落前不能开启下一个阶段；每个阶段是一条时间轴，这里我想设计成既可以从外部读取又可以自动生成的机制。</p><p>一般来说玩游戏是为了有爽快感，随着玩家自身操作水平和装备的提升，固定的游戏难度难以让玩家得到充分的满足。因此，游戏难度应该参考玩家飞机的DPS（这决定了是否能理论上通关）、玩家历史战绩（这体现了玩家的水平）、时间难度（这让游戏更加丰富，也带有一些随机性）、关卡难度系数（让游戏从前到后难度有变化）。</p><h3 id="碰撞判定机制的设计"><a href="#碰撞判定机制的设计" class="headerlink" title="碰撞判定机制的设计"></a>碰撞判定机制的设计</h3><p>碰撞判定也是这个游戏的一大难点：全像素化碰撞太耗性能，直接用boundingBox碰撞又不能避免透明像素的干扰。那么在解决碰撞问题时，我的方案是用一个根据booundingbox自动伸缩的“细长”区域判定。</p><p>2D游戏有设计的优势：绝大多数情况子弹都要穿过敌机的横截面，而穿过纵截面的情况极少发生，这是因为敌机的速度一般都垂直于横截面方向。所以这样就极大方便了碰撞判定。同时对于不同类型的问题，我搭建了scene到各元素的双向通信机制，理论上这个机制可以用动态类型转换+Node-&gt;name进行区分，但这种操作有运行风险不说，性能消耗也比较大。我采用的方式是scene持有多个vector，各节点在加载时分别向scene注册自身的指针到指定vector中，各节点退出时也向scene注册销毁自身的指针，然后每一帧调用scene的碰撞判定，分组进行判定，减小内存消耗。</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏开发</tag>
      
      <tag>读书笔记</tag>
      
      <tag>cocos2d</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【读书笔记】Pragmatic_Programmer_札记</title>
    <link href="/2020/07/24/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Pragmatic_Programmer_%E6%9C%AD%E8%AE%B0/"/>
    <url>/2020/07/24/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Pragmatic_Programmer_%E6%9C%AD%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="【读书笔记】Pragmatic-Programmer-札记"><a href="#【读书笔记】Pragmatic-Programmer-札记" class="headerlink" title="【读书笔记】Pragmatic Programmer 札记"></a>【读书笔记】Pragmatic Programmer 札记</h1><h3 id="前言和概要"><a href="#前言和概要" class="headerlink" title="前言和概要"></a>前言和概要</h3><p>这本书是在七月份读的, 有差不多300页, 考虑到英文书算是比较容易理解, 应该一两周能读完.(PS: 实际从10号读到16号)</p><p>重点处会用黑体标注. 主要还是根据书中一些精华的句子写感想.</p><blockquote><p>Your background stems from an understanding of the basic principles of computer science, and your experience comes from a wide range of practical projects.</p></blockquote><p>这是一个关于学习编程知识的建议, 有最基础的计算机知识, 然后在不同领域积累许多经验. 所以语言没什么限制, 思想才是有价值的东西.</p><blockquote><p>There are other factors that can contribute to software rot, and we’ll touch on some of them elsewhere, but neglect accelerates the rot faster than any other factor.</p></blockquote><p>软件工程中的”熵增理论”或”破窗理论”, 书中建议将<strong>及时重构, 修复那些不好的设计</strong>放在第一位, 如果实在没有时间, 也要将其标注起来, 构建以一个围栏, 阻止一块不好的代码继续扩散. 这个建议是基于软件开发中的混乱度提出的, 软件在开发过程中, 总是不可避免地走向混乱, <strong>软件开发的过程也就是与混乱抗争的过程</strong>, 那么尽量保护自己的代码, 让它们简洁高效, 是延续抗争意志的很好的手段.</p><blockquote><p>If you find yourself working on a project with quite a few broken windows, it’s all too easy to slip into the mindset of “All the rest of this code is crap, I’ll just follow suit.”</p></blockquote><p>这个是破窗理论的延伸, <strong>一块不好的代码不仅会让开发者更易于添加糟糕的代码, 还会让开发者认为其他代码也是不好的.</strong>, 我注意到的是这种情形<strong>不仅适用于代码, 还适用于开发计划/开发文档等</strong>, 第一天进行开发的时候应当设计一个简洁的框架, 然后每隔一段时间适量地作出计划, 保证整体的准确性和指导功能. 计划不能太过详细, 不然后续修改需求时就会被看作一块”破窗”, 计划也不能太抽象或者没有, 不然过几天去看当时写的代码的时候就会觉得是写出来的东西难以阅读, 也找不到定位. 总之好的设计一定是精简又可扩展的, 使得每一天都能及时踏在开发的进度上, 而不至于迷失方向或疲于修改计划.</p><blockquote><p>Once you’ve got it, show people, and let them marvel. Then say “of course, it would be better if we added….”</p><p>People find it easier to join an ongoing success.</p></blockquote><p>不仅是对团队而言, 对独立开发者也是这样. <strong>让一个项目时时刻刻处于即将成功的状态, 会让它更加有吸引力</strong>, 最初的开发要做的是写出一个最精简的可行的框架, 给人眼前一亮的感觉, 然后依照这个最初的创意不断的添加功能. 对独立开发者来说, 也就是时时刻刻让项目富有吸引力, 从而让自己能坚持开发下去.</p><blockquote><p>If you give your users something to play with early, their feedback will often lead you to a better eventual solution</p></blockquote><p>这也是迭代开发的好处, 能够迅速地将开发工作转换成可见的成果</p><h3 id="Duplication-重复"><a href="#Duplication-重复" class="headerlink" title="Duplication 重复"></a>Duplication 重复</h3><blockquote><p>The alternative is to have the same thing expressed in two or more places. If you change one, you have to remember to change the others, or, like the alien computers, your program will be brought to its knees by a contradiction. It isn’t a question of whether you’ll remember:<strong>it’s a question of when you’ll forget</strong>.</p><p>The DRY principle tells us to keep the <strong>low-level</strong> knowledge in the code, where it belongs, and reserve the comments for other, <strong>high-level</strong> explanations. Otherwise, we’re duplicating knowledge, and every change means changing both the code and the comments.</p></blockquote><p>这是第一个重要的概念: <strong>在任何地方都尽量不要出现重复的知识</strong></p><p>我在过去的经验里也有这种现象: 在许多地方写上一些相似的代码, 但是修改的时候又忘记修改其他地方的东西, 或者修改了代码却没有修改注释. 现在来看看文章中给的解决方法:</p><ol><li><p>用code generator在每一次更改的时候同步代码. 这也可以使用于代码和文档之间(doxygen), 其核心理念就是<strong>在更改时同步</strong>. 用到的技术有metadata/preprocessor等</p><blockquote><p>To ensure that the tests accurately reflected the specification, the team generated them programmatically from the document itself.</p></blockquote></li><li><p>在注释中用<strong>更高级的逻辑概括代码的内容</strong>, 通常是代码的目的或作用, 这样在更改代码的时候也就不会需要同时修改注释了</p></li><li><p>为了避免头文件和实现中的注释重复, 在头文件中存放<strong>与接口相关的信息</strong>, 而在实现中写一些<strong>被封装起来的但是很重要的细节</strong></p><blockquote><p>Use the header files to document interface issues, and the implementation files to document the nitty-gritty details that users of your code don’t need to know.</p></blockquote></li><li><p>避免违背事实的抽象关系和重复的抽象关系.</p></li></ol><p>这一点书中给了一个实例: 一个运送路线包含卡车, 司机, 和路线, 而卡车中又包含号码牌, 司机和卡车类型. 而当司机生病需要替换时, 问题就来了: 有两个重复的司机. 另外, 卡车其实并不包含司机, 如果一定要包含的话, 那么这个卡车是正在运送货物的卡车. 而不是普通意义的卡车. <strong>在设计抽象的时候时常会出现重复或是违背事实的抽象关系, 从而让实际设计的类不是我们想要的类</strong>, 解决这个问题, 当然是尽量避免重复, 我想到的, 在设计时应该这样询问自己:</p><ul><li>我是否能从这个类中的某几个类成员直接得到另一个类成员? (避免相互包含的重复)</li><li>在这个类需要应用的情况中, 这个类是否都包含它的成员属性?是否有没考虑到的成员属性? (避免违反事实的包含关系)</li><li>在这个类需要应用的情况中, 类成员的是否满足所需的性质? 如可修改性, 唯一性, 可比较性(浮点数带来的精度问题), )可独立存在性(指针指向的独立内存空间)</li><li>在这个类需要应用的情况中, 类成员是否具有不能具备的性质? 如可访问性(public的滥用), 可修改性(const), 过大的取值范围(约束限制)等</li></ul><ol><li>尽量用访问函数获取类的属性<blockquote><p>Where possible, always use accessor functions to read and write the attributes of objects</p><p>有两个例子, 一个是文中给的: 一个line类有两个成员start和end, 当需要获取长度时, 为了不违背重复性的规则, 要用两个点计算这一长度, 但是这一计算通常是昂贵的, 于是设置一个distance, 在获取长度时, 先看起点和终点是否修改过了, 如果修改了就更新distance, 再传出.</p></blockquote></li></ol><p>另一个例子是getInstance()的作用, 用来得到静态指针指向的实例, 也是唯一的实例. 这两个例子都说明<strong>用访问函数存取属性可以做更多逻辑上的封装, 让类的设计更加合理</strong></p><ol><li>设计良好的可重复利用的生态环境<blockquote><p>What you’re trying to do is foster an environment where it’s easier to find and reuse existing stuff than to write it yourself.</p></blockquote></li></ol><p>这其实有分成两点: 对个人而言和对软件/语言生态而言.</p><p><strong>对个人而言, 尽量提高代码的可重复利用性</strong>, 这不仅是提高效率, 也是集中修改. 例如用一个utils类统一管理各种需要用到的静态方法, 或者用宏定义将多个数值定义统一.</p><p><strong>对生态环境而言, 简化调包方法, 降低调包风险.</strong></p><p>这是我结合语言更新来思考的, C++的调包并没有像python那么方便, 往往是直接copy别人的代码, 还要手动搜索接口说明. 复杂的复用方法让整个软件生态面临重复性的风险, 这直接带来<strong>性能不确定的第三方库</strong>, 然后导致开发者趋向于自己造轮子, 又带来了<strong>开发的复杂度上升和沟通成本的增加</strong>, 论坛的活跃度降低, 对新手而言也很不友好. 这些都会导致整个语言生态环境的没落.</p><h3 id="Orthogonality-正交性-解耦合"><a href="#Orthogonality-正交性-解耦合" class="headerlink" title="Orthogonality 正交性/解耦合"></a>Orthogonality 正交性/解耦合</h3><blockquote><p>You get two major benefits if you write orthogonal systems: increased productivity and reduced risk.</p></blockquote><p>正交性也就是解耦合, 书中总结了一些好处, 这里列出比较有新意的点:</p><ol><li>将问题局限化: 一个结构出问题以后整个错误只会在这个结构内, 这样就可以减少思考范围, 提高debug速度</li><li>避免对第三方库的依赖: 与第三方库解耦后, 只要接口合适, 可以任意更换成另一个库, 减少依赖性.<blockquote><p>Every change needs a meeting of the entire team, because any one of them might be affected</p></blockquote></li></ol><p>这是一个很有趣的点, <strong>对一个团队的解耦可以减小沟通成本</strong>, 也就是管理的时候, 将整个程序拆解成细分的几个子部件, 然后指名各个小团队制作, 这样确保每个级别只有较少的人参与研发, 沟通也富有效率, 然后部件与部件之间正交化, 一个团队的延误不影响其他团队的工作.</p><p>满足正交性以后, <strong>用模块化和层次化的思想构建一个系统</strong></p><img src="/2020/07/24/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Pragmatic_Programmer_%E6%9C%AD%E8%AE%B0/056f9a574fe47828a21074cf7e239d0d.png" srcset="/img/loading.gif" class=""><p>如图, 交互界面内部是模块化的, 而交互界面和数据库之间是层次化的. 层次化的东西下部只需向上提供接口, 同时模块化的东西, 各模块直接也只需提供接口. 这就保证了整个系统是可靠高效的.</p><blockquote><p><strong>Don’t rely on the properties of things you can’t control.</strong></p></blockquote><p>这一句话的例子是: 不要用电话号码去分辨每一个客户. 同样, 也不能用地区/姓名等区分每一个客户, 虽然在客户数量少的情况下这样做很有效. 但是最本质的是区分<strong>一个抽象的类和从属于类的成员的区别</strong>, 前者的独立性不可由后者的独立性保障, 也比如说, 一个对象的同一性判断不可以用内存中的位置来决定, 这是因为这个位置是对象的一个属性, 虽然这个位置对于一个对象是唯一的, 但很多情况下, 开发者所要的唯一性是脱离于对象生命周期的, 那么在这种时候就应该用别的方法去识别唯一性.</p><blockquote><p>If an object persistence scheme is transparent, then it’s orthogonal. If it requires you to create or access objects in a special way, then it’s not. Keeping such details isolated from your code has the added benefit of making it easier to change vendors in the future.</p></blockquote><p><strong>引入第三方库通常是增强耦合度的</strong>, 例如stl库, 从database到GUI都要调用其中的方法, 那么一旦修改其中的某个定义, 就一定会波及多个层. 在此基础上, 要么对引入的库谨慎判断, 要么自己封装一层接口, 不直接在代码中使用第三方库, 而是集中在接口使用.</p><p>对第三方库的可替代性也有判断标准, 就如这句话所说的, 如果第三方库的使用比较奇特, 那么就尽量不要引入. 最好的第三方库是transparent的</p><blockquote><p>With AOP, you implement logging orthogonally to the things being logged. Using the Java version of AOP, you could write a log message when entering any method of class Fred by coding the aspect:</p></blockquote><p>这下面是一个例子, 意思是说AOP让log不是由每个方法独自发出的, 而是在每个方法被调用时统一发出的, 这就避免了重复调用log, 而且AOP在你编写的时候就自然而然地适用, 不需要去对源代码进行任何改动.</p><p>以后在开发的时候, 可以用一个基类实现这些功能,</p><blockquote><p>In fact, we suggest that every module have its own unit test built into its code, and that these tests be performed automatically as part of the regular build process</p></blockquote><p>这是一个关于<strong>自动化测试</strong>的建议, 也就是每个组件自身有内部的测试, 组件自身包括功能和测试两部分, 一方面可以很方便地进行调用, 另一方面减小耦合度, 节省了编译的时间.</p><blockquote><p>With truly orthogonal documentation, you should be able to change the appearance dramatically without changing the content. Modern word processors provide style sheets and macros that help</p></blockquote><p><strong>文档的解耦</strong>, 也就是自动编写目录, 将格式与内容分离, 以及格式的统一控制等等.</p><h3 id="Reversibility-可逆性"><a href="#Reversibility-可逆性" class="headerlink" title="Reversibility 可逆性"></a>Reversibility 可逆性</h3><blockquote><p>If you keep decisions soft and pliable, it won’t be hard at all. If you have poor encapsulation, high coupling, and hard-coded logic or parameters in the code, it might be impossible.</p></blockquote><p>可逆性指<strong>面对未来需求的不确定性时, 如何编写出易于改动的软件系统</strong>, 书中提到的观点有两个:</p><ol><li>系统上, 为可能的改动预留空间</li><li>利用接口, 将第三方库封装在接口里面<br>注重系统的可逆性当然是有必要的, 可我觉得这里只提了这个趋势但是没有提到如何权衡: 假设第三方库要更换, 那么就要封装一层接口; 假设系统要更换, 就要设计可更改的模式. 可逆性越大的软件也越臃肿, 这样毫无疑问会降低开发效率. 那如何保持简洁又兼顾可逆性? 这里思考的应当不是哪些需求可能会改动, 而是哪些需求不会改动.</li></ol><p><strong>在确定的需求基础上, 编写出最独立,最小化的软件</strong></p><p>所以在刚开始的时候, 应当尽量确定一些不会改变的东西, 比如软件的功能, 软件使用的平台, 是否依赖网络, 软件的最大性能需求等等. 确定以后再思考可能会改动的部分, 比如软件的GUI界面, 软件的额外功能等. 在编写的时候应当尽量不包含会改动的部分, 比如尽量不引入第三方库(除非确定这个库拥有满足需求的性能), 对长期维护的项目, 要考虑第三方库的维护状态. 也要考虑代码的易读性.</p><h3 id="Tracer-Bullets-技术验证与原型构建"><a href="#Tracer-Bullets-技术验证与原型构建" class="headerlink" title="Tracer Bullets: 技术验证与原型构建"></a>Tracer Bullets: 技术验证与原型构建</h3><p>书中的tracer bullets来源于曳光弹的形象比喻, 它是一个用来验证技术是否可行的原型机, 并且这个原型机成为后续大规模开发的骨架, 其他功能陆续被添加到这个原型机上, 逐步改装, 最终完成.</p><p>与tracer bullets对应的conventional alternative是一次性集成, 或者是单向地设计-实现-集成这个模式. 单向化有两个弊端, 第一是<strong>在测试前无法得知技术的有效性, 风险大</strong>, 这也是我之前碰见的一个问题. 我在设计动态星球生成器的时候, 没有考虑到放大后的模糊效果和性能损耗, 最终开发出的东西无法运用在实际场景中. 另外一个弊端是<strong>模块化开发, 一次性集成的方法缺少实时激励, 无论是对开发者还是用户</strong>. 激励在软件开发中很有必要, 越复杂的系统越需要心理上拉出”战线”.</p><blockquote><p>A small body of code has low inertia—it is easy and quick to change.</p></blockquote><p>这是tracer bullets的另一个好处: <strong>技术验证的代码体量小, 易于修改</strong>.</p><blockquote><p>Prototyping generates disposable code. Tracer code is lean but complete, and forms part of the skeleton of the final system.</p></blockquote><p>这里强调了Tracer bullets和prototype的区别, 前者是一个<strong>完整的骨架加上小部分的实现</strong>, 后者是一个不完整的骨架加上完全的实现, tracer bullets是可以保留到最后的, 而且这个骨架就是实际应用的东西, 而不是一个供参考的原型机. 这样能确保tracer bullets工作在实际的情况中, 而且避免了最开始的重构工作.</p><blockquote><p>What sorts of things might you choose to investigate with a prototype? Anything that carries risk. Anything that hasn’t been tried before, or that is absolutely critical to the final system. Anything unproven, experimental, or doubtful. Anything you aren’t comfortable with.</p></blockquote><p>这里需要注意的是<strong>每一次尝试新事物的时候都最好做原型验证</strong>, 这样能有效避免风险. 在开发的时候无论时间是否充裕, 都应该采用最有效的开发方式, 在这种开发中技术失败的风险也会被考虑进去.</p><blockquote><p>It’s easy to become misled by the apparent completeness of a demonstrated prototype, and project sponsors or management may insist on deploying the prototype (or its progeny) if you don’t set the right expectations.</p></blockquote><p>prototype注意的是<strong>验证某个技术是否可行, 只需要一部分代码是正确的</strong>, 而tracer bullets不同, 它需要<strong>写出能完整运行的最小的正确代码, 不需要完整, 但是需要正确和能运行</strong>, 这就导致prototype必然被推翻重来.</p><blockquote><p>By coding at a higher level of abstraction, you are free to concentrate on solving domain problems, and can ignore petty implementation details.</p></blockquote><p>这是说<strong>在最初的时候不要考虑语言的具体细节, 只需要用一种伪代码描述出业务逻辑即可</strong>, 确实在思考问题的时候我默认都会从语言的角度思考可行性, 但是这是不对的, 因为理清业务逻辑不需要理清语言细节, 一个逻辑可以有很多实现, 而我在构建框架的时候并不需要去寻找最合适的实现, 甚至不需要关注是否能实现, 这些东西都是在实现的过程中考虑的.</p><blockquote><p>But with a mini-launguage, you would instead be able to issue an error message using the vocabulary of the domain.</p></blockquote><p>这也是站在业务逻辑思考的好处, 一些错误提示是基于语言或计算机系统本身的, 但这种提示是脱离<strong>业务语言</strong>的, 在业务语言中, 仅有业务本身的选择, 而将所有语法错误和执行错误都重新阐释为业务逻辑的错误.</p><blockquote><p>Given that most applications exceed their expected lifetimes, you’re probably better off biting the bullet and adopting the more complex and readable language up front</p></blockquote><p>软件是无生命的, 但是在使用的时候依然要考虑它的<strong>生命周期</strong>, 我的思考是, 在代码能够被理解的时候, 它是有活力的, 而当没有人能理解一段代码的时候, 代码就失去了活力, 而失去活力的代码会失去其价值.</p><p>开发和管理存在一个平衡: 富有活力的代码通常难以创造, 而管理没有活力的代码也非常困难. 所以这取决于这段代码的生命周期有多长: 生命周期为一天或几天的代码, 不需要开发文档, 只需要内部的注释. 而生命周期为半个月到一个月的代码, 需要开发文档, 但不需要对第三方库的维护. 而生命周期为一年到几年的代码, 则需要编写完善的开发文档, 并且尽量对第三方库封装接口, 从而让第三方库可以根据维护性更换.</p><p>生命周期应该看作代码本身的一个属性.</p><blockquote><p>We find that often the only way to determine the timetable for a project is by gaining experience on that same project.</p></blockquote><p>依据最开始的决定对整个项目的时间作规定是很不可靠的, 预估一个程序的开发时间最好的方法就是直接取开发这个程序. <strong>在开发过程中逐步确定剩余的时间, 并依照这个时间作决策</strong></p><p>也就是说, 整个开发计划是随着开发进程而变化的.</p><h3 id="ToolBox拥有自己的工具箱"><a href="#ToolBox拥有自己的工具箱" class="headerlink" title="ToolBox拥有自己的工具箱"></a>ToolBox拥有自己的工具箱</h3><blockquote><p>Many new programmers make the mistake of adopting a single power tool, such as a particular integrated development environment (IDE), and never leave its cozy interface.</p></blockquote><p><strong>每一种工具都有自身的优缺点, 没有哪个是完美的</strong>, 这也说明开发者应当掌握不同的工具来处理不同的情况, 用自身的经验加上合理调度来达成最优效率.</p><p>当然, 在一个开发进程中使用过多的工具也代表着很难被别人理解.</p><blockquote><p>As Pragmatic Programmers, our base material isn’t wood or iron, it’s knowledge.</p></blockquote><p>这一句话只是单纯看着很有哲学意味…</p><p><strong>Plain text</strong></p><p>可以翻译作”朴素的文本形式”, 书中对平面文本比较推崇, 它的优点是可以被人理解, <strong>对于一些在使用时需要被理解的东西, 通常以文本的形式保存</strong></p><p>但也有缺点, plain text占空间大, 同时在读取和写入的时候比较昂贵. 一些其他的缺点其实并不是plain text的锅, 例如易读性. 二进制的东西读取并不困难, 同时plain text也可以通过加密形式存储.</p><p><strong>Using Unix Tools Under Windows</strong></p><blockquote><p>But if you do all your work using GUIs, you are missing out on the full capabilities of your environment. You won’t be able to automate common tasks, or use the full power of the tools available to you. And you won’t be able to combine your tools to create customized macro tools.</p></blockquote><p>确实GUI在自动化处理上有些问题, 但是我觉得并不需要强行在GUI和命令行之间作划分, 有时候<strong>简单的操作由GUI完成, 自动化的东西交给命令行</strong>, 这样应该能保持效率的最大化?</p><p><strong>Use a single editor well</strong></p><p>最好选择一个编辑器来熟悉, 然后充分利用它的快捷键提高效率.</p><p>好的编辑器有以下特征:</p><ol><li>可配置, 可以自行配置让编辑器符合自己的喜好</li><li>可拓展, 可以添加新的内容</li><li>可编程, 可以自己设计复杂的组合操作</li></ol><p><strong>Always Use Source Code Control</strong></p><blockquote><p>There is a tremendous hidden benefit in having an entire project under the umbrella of a source code control system: you can have product builds that are automatic and repeatable.</p></blockquote><p>书中的观点是: 源代码管理不仅可以适用于代码, 更适用于任何自己编写的东西, 比如脚本, 管理文档等. 这样可以随时退回到之前的操作, 非常方便.</p><p>所以对于任何可以被管理的文件, 尽量把他们应用在源代码管理中</p><h3 id="Debugging-调试"><a href="#Debugging-调试" class="headerlink" title="Debugging 调试"></a>Debugging 调试</h3><p>书中总结了几条调试的规则, 这里简要列出:</p><ol><li>bug复现</li><li>数据可视化</li><li>程序运行追踪</li><li>先假设自己的代码有问题, 再思考第三方代码是否有问题</li><li>不要假设哪些代码是必定正确运行的, 而是去证明它</li><li>在找到代码之后, 反思如何避免它<h3 id="Text-Manipulation-文本操作"><a href="#Text-Manipulation-文本操作" class="headerlink" title="Text Manipulation 文本操作"></a>Text Manipulation 文本操作</h3></li></ol><p>文本操作的一些功能:(以Perl为例)</p><ol><li>建立数据库</li><li>自动方法生成</li><li>测试数据生成</li><li>抽取声明和接口</li><li>生成文档<blockquote><p>Write Code That Writes Code.</p></blockquote></li></ol><p>这句话解释了自动处理的重要性. 建立一个代码生成器是很有必要的, 这里是一些功能:</p><ol><li>创建新的文件, 并应用模版</li><li>执行自动的格式转换操作</li><li>执行预处理操作</li><li>执行给定的同步操作或一致性检查</li><li>手动处理一些源代码中的可变片段(结构体等)<h3 id="Pragmatic-Paranoia-偏执心理"><a href="#Pragmatic-Paranoia-偏执心理" class="headerlink" title="Pragmatic Paranoia 偏执心理"></a>Pragmatic Paranoia 偏执心理</h3></li></ol><blockquote><p>You Can’t Write Perfect Software</p></blockquote><p>这句话也是我感触比较深的, 在写程序的时候当然要追求效率, 但是不要追求完美. 因为完美的程序一般都会花费远远大于预定的时间来开发, 在绝大多数时候我只需要一个简单够用的程序.</p><p><strong>Design by Contract</strong></p><p>这是确保程序在正确性和完美之间的找到平衡的一个方法, 简单来说, 就是在给定条件下, 一个方法能确保结果中的一部分被正确呈现, 而一些模糊的部分会怎么样, 并没有被规定.</p><p>DBC包含三个部分: 调用者必定凑齐的条件, 依照条件返回结果的方法, 和检查条件与结果是否正确的class</p><blockquote><p>Subclasses must be usable through the base class interface without the need for the user to know the difference.</p></blockquote><p>这是继承的一个原则: <strong>继承类必须在调用基类接口的时候表现得和基类一样</strong>, 不然继承的原则就会被破坏, 这里的表现得一样不是指一样的输出, 而是输入范围至少要和基类的范围一样. 也就是说在用户使用继承类的基类接口的时候, 用户可以当做基类来使用而不会产生错误.</p><p>DBC在C++中有预处理器来保证, 如<strong>Nana</strong>, 在JAVA中有<strong>iContrast</strong></p><blockquote><p>With enough components and agents that can negotiate their own contracts among themselves to achieve a goal, we might just solve the software productivity crisis by letting software solve it for us.</p></blockquote><p>有时候面对输入不一样的情况, 并不总是将其当作<strong>错误</strong>, 而对于特殊情况, 依然能返回正确的结果, 那么程序本身在扩展的时候就自动地找出复杂范围的可行方案(例如类型推断)</p><p><strong>crash earlier</strong></p><blockquote><p>when your code discovers that something that was supposed to be impossible just happened, your program is no longer viable.</p></blockquote><p><strong>在程序最开始出错的地方停止</strong>, 一方面是避免后续的报错影响debug思路, 另一方面是避免重要的数据被错误地覆盖.</p><p>另外, 为了尽早检测出错误, 在每一个模块都应当设置<strong>检测运行状态合理性的代码</strong>, 也是为以后的debug留下线索</p><blockquote><p>If It Can’t Happen, Use Assertions to Ensure That It Won’t</p></blockquote><p>很多时候在编程中会默认加上一些条件, 然后根据这些假设编程, 但是<strong>对正确性的检测不能因为主观的假设而偏颇</strong>, 此时使用Assertion来显式表达自己的假设.</p><p>但是要注意, 断言中不能存放任何业务逻辑的代码, 因为断言可能在编译时被关闭.</p><blockquote><p>First, they assume that testing finds all the bugs. Second, the optimists are forgetting that your program runs in a dangerous world.</p></blockquote><p>这是<strong>Assertion不仅用于debug</strong>的原因, 因为断言针对的是所有潜在bug和不正确的输入</p><blockquote><p>For example, if your code tries to open a file for reading and that file does not exist, should an exception be raised?</p></blockquote><p>这就涉及到exception的意义: <strong>exception用在处理设计者意想不到的状况, 不能参与正常的业务逻辑处理</strong></p><p>同时, 大量的异常处理会打乱整个代码的逻辑, 我们在debug的时候用exception<strong>只需要知道大概的范围, 但不需要精确到每一步</strong>,因此抛出异常的也只是一个try块, 最好不要是每一行代码都检测.</p><p>以我之前的经验, 在捕获异常的时候, 最好直接用<strong>方法+功能来定位</strong>, 这样设计者既可以直接找到出错的地方, 也可以知道运行的宏观逻辑.</p><blockquote><p>An error handler is a routine that is called when an error is detected.</p></blockquote><p>可以设计一个专门用来处理异常信息的接口, 便于异常的管理和查找</p><blockquote><p>Finish What You Start</p></blockquote><p>尽量在同一个方法内完成打开和关闭操作, 否则很容易出现多次打开或不正确的打开时机等问题</p><p>也可以利用语言内部的对称性, 将资源的打开关闭放在构造和析构函数里. <strong>用一个类实例作为资源的抽象</strong>, 同样的, 这种方式也能避免在throw exception的时候没有释放资源, 因为资源会随着C++的特性自动释放</p><p><strong>deallocate structure</strong></p><p>书中给了三种方式:</p><ol><li>父结构自行负责子结构资源的分配和释放</li><li>父结构不管子结构, 每个结构独立管理资源的分配和释放</li><li>如果父结构还有子结构的资源, 则拒绝释放.(外部管理)<h3 id="flexible-适应性强的代码"><a href="#flexible-适应性强的代码" class="headerlink" title="flexible 适应性强的代码"></a>flexible 适应性强的代码</h3></li></ol><blockquote><p>A good way to stay flexible is to write less code.</p></blockquote><p>这个建议很简单, 只要不写代码, 就能降低代码的修改难度. <strong>保持代码的简洁性也是增强适应性的一个方式</strong></p><blockquote><p>Rather than digging though a hierarchy yourself, just ask for what you need directly.</p></blockquote><p>在一个类中对另一个类的接口调用<strong>尽量只调用浅层的方法</strong>, 因为如果一连串地调用, 就减少了封装的程度, 增加了耦合度.</p><p><strong>The Law of Demeter for Functions</strong></p><p>任何方法只能调用:</p><ol><li>自身的方法</li><li>传入参数的方法</li><li>方法定义域中生成的实例的方法.<blockquote><p>First, we want to make our systems highly configurable. Not just things such as screen colors and prompt text, but deeply ingrained items such as the choice of algorithms, database products, middleware technology, and user-interface style.</p></blockquote></li></ol><p>从<strong>外部定制</strong>来说, 可定制的远远不止用户的flavor, 更包含开发者的可选项. <strong>用文件来定制被每次都修改源代码更加优美</strong></p><p>可定制的有很多, 比如运行路径, 用户界面, 平台等.</p><blockquote><p>Our goal is to think declaratively (specifying what is to be done, not how) and create highly dynamic and adaptable programs. We do this by adopting a general rule: program for the general case, and put the specifics somewhere else—outside the compiled code base.</p></blockquote><p>这一段写的非常出乎我意料. *<em>我们写出的程序是一次性编译的, 那么就不应该存在特定的目的. *</em></p><p>最理想的状态是用metadata描述程序的功能, 然后整个程序是一个引擎, 对描述进行解析, 并按照预想的方式运行. 这样, 程序的功能部分用人类语言描述出来, 保留了大部分业务逻辑的信息. 然后引擎本身也是高度解耦的, 可以较大程度覆盖可能的业务逻辑.</p><p>在工作场景里, 写一个程序不仅要覆盖给定的需求, 更要在拓展潜在需求上尽量做到健壮, 灵活. 这种写程序的目标是整个可能性的组合, 而不是一个单一的目的.</p><h3 id="workflow-用户的操作空间"><a href="#workflow-用户的操作空间" class="headerlink" title="workflow 用户的操作空间"></a>workflow 用户的操作空间</h3><blockquote><p>It can be eye-opening to see where the dependencies really exist.</p></blockquote><p>workflow用在这种地方: 用户可以执行不同的操作, 但是一些操作需要在另一些操作执行完以后才能执行. 那么如何设计程序? 这就是<strong>用图形表达出用户可能的所有操作, 即一个操作空间</strong></p><p>基于操作空间, 可以设计前端的结构:</p><blockquote><p>In a hungry consumer model, you replace the central scheduler with a number of independent consumer tasks and a centralized work queue.</p></blockquote><p>序列化, 也就是将用户的操作拆分成<strong>去中心化的动作, 然后放在中心化的序列中</strong>, 这种设置比用很多flag表示要有效得多.</p><p>同时, 可以将多个序列进行拆分重组, 进而达到多线程的目的. 上述的workflow检测依赖性, 然后将满足解耦条件的动作从序列中抽出. 也可以合并多个序列, 只要检测能否互相并存即可. 这种情况下, <strong>所有的依赖性都可以通过检测序列来实现</strong></p><h3 id="concurrency-同时性"><a href="#concurrency-同时性" class="headerlink" title="concurrency 同时性"></a>concurrency 同时性</h3><blockquote><p>Because things can now happen at the “same time,” you may suddenly see some time-based dependencies.</p></blockquote><p>多线程并不是”麻烦”的技术, 相反, 多线程给代码设置更高的要求, 让一些低劣的代码不能正常运行, 这促使开发者提高编程水平.</p><h3 id="Publish-Subscribe消息机制"><a href="#Publish-Subscribe消息机制" class="headerlink" title="Publish/Subscribe消息机制"></a>Publish/Subscribe消息机制</h3><blockquote><p>Objects should be able to register to receive only the events they need, and should never be sent events they don’t need.</p></blockquote><p>这个消息通知机制就是cocos2d里用到的机制: <strong>接受者向发送者注册, 然后发送者每回发送的时候, 都向注册了的组件发出通知</strong></p><p>这里我有一些启发: 对于可以通信的东西, 它们交流代码媒介是什么呢? 既然消息是去中心化的, 那么交流一定要有一个共同语言. 而<strong>共同的基类就是组件间交流的语言</strong>, 当组件都有相同的基类的时候, 组件间的交流就可以基于这个语言, 当然也只能限于这个语言.</p><h3 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h3><p><a href="https://baike.baidu.com/item/MVC%E6%A1%86%E6%9E%B6/9241230?fromtitle=MVC%E6%A8%A1%E5%BC%8F&fromid=713147&fr=aladdin" target="_blank" rel="noopener">MVC设计模式</a></p><blockquote><p>separating the model from both the GUI that represents it and the controls that manage the view</p></blockquote><p>这是MVC的设计思想:<strong>数据被封装成一个model, 读取和写入都是单向的</strong>,</p><p>MVC的设计思想不仅用在GUI的设计中, 只要是涉及数据+交互的, 都可以用MVC进行解耦.</p><h3 id="Blackboard-匿名论坛设计模式"><a href="#Blackboard-匿名论坛设计模式" class="headerlink" title="Blackboard 匿名论坛设计模式"></a>Blackboard 匿名论坛设计模式</h3><blockquote><p>A blackboard system lets us decouple our objects from each other completely, providing a forum where knowledge consumers and producers can exchange data anonymously and asynchronously.</p></blockquote><p>黑板设计模式的意义在于<strong>黑板本身仅是一个容器, 而业务逻辑被分散到各个组件中去</strong>, 这是去中心化的. 去中心化有它的好处, 对于非常复杂的规则, 如果编写一个中心化的东西(可以参考桌游的gm), 那么对所有情况进行组合是非常困难的. 但是现实中很多逻辑本身就是去中心化的, 比如人与人的交流活动, 而将去中心化的东西用程序实现, 就涉及到一个”论坛”, 论坛中的讨论者是去中心化的, 但是论坛本身是中心化的, 这样就可以做到组件的充分解耦.</p><p>我也想把这个模式叫做<strong>匿名论坛模式</strong></p><h3 id="Programming-by-Coincidence"><a href="#Programming-by-Coincidence" class="headerlink" title="Programming by Coincidence"></a>Programming by Coincidence</h3><blockquote><p>As developers, we also work in minefields.</p></blockquote><p>要避免coding中的一些潜在问题, 我摘选了几点比较好的建议:</p><ol><li>在运用新技术时一定要先作技术验证, 避免产生歧义.</li><li>不要依赖潜在的东西, 比如语言, 平台, 和测试的特定接口</li><li>在测试的时候, 不仅确保结果正确, 也确保过程和预想的一样.</li><li>不要为了兼容而兼容, 在适当的时候就要果断进行重构<h3 id="optimizing-性能优化"><a href="#optimizing-性能优化" class="headerlink" title="optimizing 性能优化"></a>optimizing 性能优化</h3></li></ol><p>这部分还是关于时间复杂度的, 但是程序整体的性能瓶颈并不一定是算法, 也可能是读写速度, 存储空间等</p><h3 id="refactor-重构"><a href="#refactor-重构" class="headerlink" title="refactor 重构"></a>refactor 重构</h3><p>四个重构的场景:</p><ol><li>代码有重复性(DRY)</li><li>代码耦合度高</li><li>代码中应用的assumption过于陈旧</li><li>有性能瓶颈<blockquote><p>Don’t try to refactor and add functionality at the same time.</p></blockquote></li></ol><p>重构的理念是<strong>小步重构, 大量测试</strong>, 也就是不要在重构的时候无意间改变了原先的业务逻辑.</p><h3 id="test-测试"><a href="#test-测试" class="headerlink" title="test 测试"></a>test 测试</h3><blockquote><p>In C++ you can achieve the same effect (at compile time) by using #ifdef to compile unit test code selectively.</p></blockquote><p>之前有提到说每一个模块都应该带有对自身的测试代码, 那么这些测试代码就可以放在宏定义里面. 当然, <strong>测试的逻辑一定要和业务逻辑的代码解耦</strong></p><blockquote><p>A test harness can handle common operations such as logging status, analyzing output for expected results, and selecting and running the tests.</p></blockquote><p>我认为每个系统的测试都是不一样的, 很难做到同一个测试系统用于不同的代码, 但是在log中对error和warning由专门的分类比直接用string写字符串要好很多.</p><p>我认为一个良好的log应该是包含<strong>可视化, 分级, 折叠, 自动保存信息</strong>等功能, 用不同的颜色输出error和warning, 然后每次输出后都保存到文档中, 以便下次调试时比较. 对于比较复杂的系统, 将次要的输出信息折叠起来, 只保留主要部分.</p><p>但与其对一段不良的代码做许多测试, 还不如<strong>尽量编写没有bug的代码</strong>,通过改良编程习惯, 加深对底层的理解,做到防患于未然</p><blockquote><p>The wizard code is not factored out behind a tidy interface—it is interwoven line by line with functionality that Joe writes.</p></blockquote><p>这里的wizard指的是自动代码生成器, 就像自动类框架生成这种东西. 但是使用的条件是开发者必须完全熟悉wizard生成的代码, 因为这些代码是全面地和开发者的代码混合的.</p><h3 id="The-Requirements-Pit-充分理解需求"><a href="#The-Requirements-Pit-充分理解需求" class="headerlink" title="The Requirements Pit 充分理解需求"></a>The Requirements Pit 充分理解需求</h3><blockquote><p>Requirements rarely lie on the surface. Normally, they’re buried deep beneath layers of assumptions, misconceptions, and politics.</p></blockquote><p>寻找<strong>真正的需求</strong>确实是比较困难的, 有时候难以想象完全整个交互场景, 有时候没有真正拆解需求的组合, 导致设计的框架过于复杂.</p><blockquote><p>It’s important to discover the underlying reason why users do a particular thing, rather than just the way they currently do it.</p></blockquote><p>真正的需求可能连用户自己都不清楚, 因为<strong>一个单一的需求无法决定整个程序框架, 可能的需求和潜在的变动一同组成的需求域才能决定程序哪方面需要flexible</strong></p><p>另一个了解需求的方法是: 假设自己是用户. 也就是站在用户的角度思考自己计划的设计是否足够强大, 且足够方便.</p><blockquote><p>Don’t be a slave to any notation; use whatever method best communicates the requirements with your audience.</p></blockquote><p>在理解并记录需求的时候需要的是最符合业务逻辑的语言, <strong>业务逻辑的语言并不局限于任何一种图表或记号</strong></p><h3 id="Maintain-a-Glossary-制作术语表"><a href="#Maintain-a-Glossary-制作术语表" class="headerlink" title="Maintain a Glossary 制作术语表"></a>Maintain a Glossary 制作术语表</h3><p>这也是一个<strong>标准化</strong>的东西, 对文档中的描述给定一个准确的定义, 当然这主要用在大型项目中. 从共同的语言中特异化一些东西来描述业务逻辑, 可以说是一种”业务语言”</p><h3 id="while-in-coding"><a href="#while-in-coding" class="headerlink" title="while in coding"></a>while in coding</h3><p>这一节实际上是之前的小节的汇总, 包含一些我觉得很有用的观点.</p><ol><li>在开始项目之前做技术验证和原型建模</li><li>在开始项目之前先扫除直觉上的担忧</li><li>不要写太多太详细的技术文档, 要拥有较强的灵活性<blockquote><p>Often, it is only during coding that certain options become apparent.</p></blockquote></li></ol><p>我也有类似的经验, 写着写着才发现有的地方可以用很巧妙的方式实现, 或者以另一个方式拓展. 但是否要遵循这种方向? 我觉得应该要看这个拓展性是不是符合项目需求或潜在需求的.</p><blockquote><p>Never underestimate the cost of adopting new tools and methods.</p></blockquote><p>这是建议不要在正式项目中<strong>过多使用不熟悉的技术</strong>, 同样地, 框架设计应该在满足需求的同时尽可能简洁, 而不是在没有必要的地方留下拓展接口.</p><blockquote><p>Test Early. Test Often. Test Automatically.</p></blockquote><p>在集成化测试前作单元测试是很有必要的, 因为越是复杂的不可靠系统越难找到真正的bug, 最好在每次build时都自动地进行测试</p><h3 id="comments-注释"><a href="#comments-注释" class="headerlink" title="comments 注释"></a>comments 注释</h3><blockquote><p>In general, comments should discuss why something is done, its purpose and its goal.</p></blockquote><p>注释是另一个维度的东西, 注释补全了代码中人的意图和业务逻辑, <strong>注释和代码是互补的, 是高层次的逻辑抽象, 而不是代码的翻译</strong></p><p>与doxygen相反地, 可以把<strong>设计文档的一部分通过自动生成器同步到代码注释中去</strong>, 也可以将代码注释和技术文档各自独立, 并单向集成到API Reference中</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>读完真是身心俱疲…</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>编程思想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程设开发总结</title>
    <link href="/2020/07/24/%E7%A8%8B%E8%AE%BE%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <url>/2020/07/24/%E7%A8%8B%E8%AE%BE%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="2020年7月程设开发总结"><a href="#2020年7月程设开发总结" class="headerlink" title="2020年7月程设开发总结"></a>2020年7月程设开发总结</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今年6月上旬到七月初的这二十多天大概是我人生中第一次写一个3K-5K量级的项目, 从第一天对游戏引擎完全不了解, 到自己用一下午去设计一个UI界面, 甚至去分析飞船的结构特点, 最终用稍微超过预期的时间完成了一个勉强满意的”模具”, 虽然离理想中的游戏差距很多, 但是提供了一个可以完善的平台, 让我有信心继续做下去. 中间着实有不少困难, 甚至让最初企划时的兴奋感都消散殆尽, 但是能做出一个能代表自己风格的作品, 确实是一件有意义的事, 甚至可以说没有什么比自我实现这种事更有意义了.</p><p>当然, 在这种量级的开发中, 尽管已经提前设想过一些解决方案, 但还是遇到了意料之外的情况. 设计的理念也有待改进. 这篇文章就是总结这些琐碎的东西的.</p><h3 id="健壮性和复杂性-应当考虑不变的是什么-而不是可变的是什么"><a href="#健壮性和复杂性-应当考虑不变的是什么-而不是可变的是什么" class="headerlink" title="健壮性和复杂性: 应当考虑不变的是什么, 而不是可变的是什么."></a>健壮性和复杂性: 应当考虑不变的是什么, 而不是可变的是什么.</h3><p>在写这个游戏的最开始, 我的构想还不是很成熟, 于是最初的目标就是: 尽可能保证底层设计的健壮性, 这样以后再变动设计时就能尽量减小重构次数. 依照这个方案, 前期对底层的处理确实比较模块化, 同时避免了后面的许多问题. 但是这样也使得整个设计非常复杂, 在处理<strong>类的相互包含问题</strong>的时候, 我之前设计的复杂的相互引用机制让debug变得异常困难. 如果舍弃这个机制, 整个底层都要重构, 好在最后尽量避免了相互引用, 然后<strong>把独立的方法集成到一个工具类中</strong>, 这样就确定了一个不循环的结构关系, 当然<strong>如何设计一个自顶而下又可以互相通信的机制</strong>也是我没考虑过的问题. 所以这里我先提出一点想法:</p><p><strong>在设计的时候先考虑哪些需求是不会改变的, 再以此设计一个最精简的系统</strong></p><p>就例如游戏中的各个scene, 整个游戏流程只需要提供一个实例, 那么scene只需要一个静态成员存放instance就可以了, 然后用getInstance()方法, 完全可以避免成员需要拿指针的问题. DataLoader也是, 同一时间只能加载一个存放的内容, 不同存档不需要交换信息, 而且DataLoader的类型也是确定的: 加载游戏配置数据和玩家存档里的数据, 这样就只要设定两个静态成员就可以了.</p><h3 id="对内部细节的封装"><a href="#对内部细节的封装" class="headerlink" title="对内部细节的封装"></a>对内部细节的封装</h3><p>一开始我对飞机的定义很不明确, 武器是否可更换? 飞机是否可更换? 飞机型号是否有特殊技能? 是否有特定的增益? 但在设计的时候应该始终把飞机看作一个”黑箱”, 对战斗scene来说, 只要能获取飞机的位置/血量等数据就可以, 而不需要关注内部的东西, 同样整个level生产的也无外乎飞机/子弹/掉落物/特效等, 设计的时候就设计几个基类供level调用即可.</p><h3 id="代码的可维护性"><a href="#代码的可维护性" class="headerlink" title="代码的可维护性"></a>代码的可维护性</h3><p>写到后面的时候时常会犯一些低级错误: 重载函数写错了参数列表, if语句中==少打了一个=, 还有各种约定的规则没有被遵守. coding的过程也是<strong>不断制定规则的过程</strong>, 但是这些规则在编写的时候制定下来, 又如何保证一定能被遵守呢? <strong>任何程序员自行编写的规则都尽量要做到强制被遵守</strong>, 例如两个函数调用前后的顺序, 就用isLoaded来检测, 在没有遵守的时候抛出异常, 又如Reflection这个类的机制, 这是个反例, 所有的飞机都需要在创建的时候手动向反射表注册, 这样并不符合上面所说的理念. 这个改进的方案还没想好(也许没有?), 但是像这种规则即使不能避免, 也要及时整理在技术文档里.</p><p>save里的数据也缺乏维护性, 这是因为最初的时候对<strong>飞机/子弹的实例和模版概念没有分清</strong>导致的, 按理说save里只能存放实例, 也就是一些具有特异性的东西, 但是<strong>属性本身就是有变和不变两个性质的</strong>, 属性的数量/类别/作用都是不变的, 但属性的数值却是可变的, 所以一个武器的属性表就应该同时存放在gameData和save里, 同时这里实例的概念是什么? 是拥有相同属性, 相同的类模版, 但属性数值可以不同的一些飞船. 一个实例并不代表游戏里的一个飞船, 事实上<strong>实例本身仅有数值特意化的功能, 实际生成的数量是由程序控制的, 每个游戏内实体的区分也仅靠内存地址的不同</strong>, storage里存放的实例都是不同的, 因为给玩家相同参数的东西没有意义, 所以每个物品对应一个实例, 但level里的实例是可复用的, 因为生成的飞机基本都是一样的外观, 方便动态控制生成的数量. 这也限制了按照实例查找个体的范围, 这个范围是不能包括可复用实例的区域的.</p><p>像这种唯一性的确定规则, 应当在设计的时候就想好. 后期更改会带来很大的麻烦</p><h3 id="开发进度的可视化-amp-迭代开发"><a href="#开发进度的可视化-amp-迭代开发" class="headerlink" title="开发进度的可视化&amp;迭代开发"></a>开发进度的可视化&amp;迭代开发</h3><p>整个开发过程最艰难的大概就是做UI和写行星生成器的时候, 这里我的开发流程并不合理, 首先行星生成器我花了3天时间研究, 但是结果上这一个东西因为性能原因不能产生大面积的可动背景, 而这三天里, 我并没有做任何推动开发进度的东西, 导致写完以后一度丧失了进行下去的信心. <strong>对一个独立开发者而言, 如何规定开发计划, 让整个开发进度可视化, 并得到充分的反馈, 是开发能否进行下去的关键</strong>, 在做行星生成器的时候, 我把整个游戏背景设计/UI设计完全押注在这一个技术的实现上, 然而这种是很危险的. 对一个最精简框架所必须的UI, 背景图片而言, 他们虽然要遵循一个统一的视觉形象, 但是不能依赖一个未知能否实现的技术.</p><p>在规划的时候也应该从最精简的框架入手, 先<strong>搭建出一个能用的东西, 再去思考怎样让它变得更好</strong>. 过度追求完美是很危险的, 就像我在写行星生成器的时候, 过度想让它完美呈现, 却因此破坏了整个游戏的开发进程, 也破坏了迭代开发的原则. 以后的设计中要避免各个技术的相互耦合, 对于难度高的技术, 尽量先写一个可用的版本, 再去完善它.</p><h3 id="文档规范化-amp-注释规范化"><a href="#文档规范化-amp-注释规范化" class="headerlink" title="文档规范化&amp;注释规范化"></a>文档规范化&amp;注释规范化</h3><p>这次没有用doxygen生成文档, 虽然写了许多注释, 但回看的时候效果都很差: <strong>太少注释让人无法理解运行原理, 太多注释让人花费大量的时间在浏览无用信息上</strong>, 后期修改一个源文件的时候, 经常在十几个方法里面寻找, 但是在中途就忘记了自己要找什么东西. 同时满足注释的详细程度和检索遍历程度, 听起来是矛盾的, 但其实也有方法: <strong>一些注释是只需要全局检索的, 例如TODO, 那么只要有可检索的关键字就行了</strong>, 而需要让人了解”这个方法是干什么的”这些注释, 不能写得太过琐碎, 最好写出<strong>一整块注释, 大致说明代码的功能, 需要特别注意的地方在所在行添加注释</strong>, 这样就不必在繁多的注释行中不断阅读.</p><p>doxygen也是比较方便的, 但是我还没有关注过注释的可维护性, 在对程序进行修改的时候, 注释很难进行同步修改, 这也是我写大量功能性注释的弊端:<strong>注释太多反而加大了修改的工作量, 也增添了额外的规则</strong>, 而最好是在一段代码通过稳定测试以后再写一个总结性质的注释.</p><h3 id="过程中的奇异bug们与一些零碎经验"><a href="#过程中的奇异bug们与一些零碎经验" class="headerlink" title="过程中的奇异bug们与一些零碎经验"></a>过程中的奇异bug们与一些零碎经验</h3><p>开发过程中也遇上了一些奇怪的bug:</p><ol><li><p>枚举的size{small,medium,large}中的small与cocos2d命名空间的一个宏定义重名(所以<strong>一般在cpp里用using namespace而不要在头文件里用</strong>)</p></li><li><p>设置rotation后再设置anchorPoint总是显示错位, 后来发现是因为旋转后锚点的位置也会在坐标系中改变</p></li><li><p>提示nullptr, 是因为垃圾自动回收机制导致的</p></li><li><p>用removeChildByName的时候, 对参数理解不到位, 导致后来一些奇奇怪怪的报错(以后要多看reference)<br>也有一些零碎的东西需要改进</p></li><li><p>cocos2d::ui这个命名空间太长了, 最好用 <code>namespace vlns = very::long::namespace</code> 削短</p></li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
      <category>游戏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏开发</tag>
      
      <tag>cocos2d</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020SummerGame：美工设计笔记</title>
    <link href="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="2020SummerGame：美工设计笔记"><a href="#2020SummerGame：美工设计笔记" class="headerlink" title="2020SummerGame：美工设计笔记"></a>2020SummerGame：美工设计笔记</h1><h2 id="美工设计笔记——飞船设计P"><a href="#美工设计笔记——飞船设计P" class="headerlink" title="美工设计笔记——飞船设计P"></a>美工设计笔记——飞船设计P</h2><p>因为假期时间很充裕，这次游戏的美工打算自己画，也是积累一些美术方面的经验。整个学习过程就是：观看优秀的美工设计-总结各自的优缺点和风格特异性-尝试转移到自己的设计上。而关于理论方面，我打算先自己看完优秀案例再学习理论基础，以便能随时与实践联系起来。</p><p>初步来说，整体的美工设计包括飞船设计、武器设计、子弹/激光等特效设计，爆炸效果设计，游戏背景设计，UI设计，宝石设计。当然整体的风格要统一。</p><h3 id="Star-sector飞船拆解：涂装、外壳纹理、外壳结构、内部器件、功能模块"><a href="#Star-sector飞船拆解：涂装、外壳纹理、外壳结构、内部器件、功能模块" class="headerlink" title="Star sector飞船拆解：涂装、外壳纹理、外壳结构、内部器件、功能模块"></a>Star sector飞船拆解：涂装、外壳纹理、外壳结构、内部器件、功能模块</h3><p>Star sector的飞船设计很明显的特点就是：各方阵容特色鲜明，整体造型统一，同时与UI搭配和谐。整体拆解如上所说，但是部分结构还是需要细分：首先关注一下打光，star sector的飞船打光大都是<strong>从上向下的点光源或线光源</strong>，打光区分<strong>球面</strong>和<strong>圆盘</strong>，同时根据反光度的不同，区分<strong>外壳</strong>和内部<strong>器件</strong>，同时根据光和阴影的分布，可以将飞船的曲面表示出来，许多飞船<strong>中间亮两边暗</strong>，整体呈现半球形的曲面分布。</p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/b9a5e2688026aea33132a83487f68bbb.png" srcset="/img/loading.gif" class=""><p>（打光下的球体，注意两个小球的光点并不在中间，这种对应的物理结构我还没搞清楚）</p><p>不同阵营的涂装、外壳结构、外壳纹理是不同的。<strong>外壳覆盖范围</strong>有全覆盖型（看起来很坚固，但是速度缓慢）、半覆盖型、贴边覆盖型（只有贴边的平行装甲，中间部分都是露出的）、无覆盖型（找不到光滑面，都是内部器件）。按照<strong>对称性</strong>划分可以有对称型和不规则型，其中不规则型大多采用圆滑设计，来保持整体美观。同样，根据势力范围不同，飞船的<strong>基本图案</strong>也是不同的，分为以平行四边形为基础和以圆形为基础。但是，在各个阵营的飞船中也能找到共同的东西，比如<strong>统一为白色的舰桥</strong>：</p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/71532e57a67ac4f036ba59f9177281ef.png" srcset="/img/loading.gif" class=""><p>当外壳结构确定好后，外壳纹理起到细化的作用。<strong>拼装式外壳纹理</strong>经常在以圆形为基础的飞船上看见，此时飞船表面像是被设计好的几块外壳拼装出来一样：</p><p><strong>搭建式外壳纹理</strong>在以平行四边形为基础的飞船上看见，此时飞船表面各部件有实际的层次。这是因为拼装出的类似球状在光的渲染下比较好看，而如果平行四边形采用拼装式，那么只能得到一块平面，如果平行四边形在3维空间采用曲面设计的话，就其二维特征不统一了，反而会破坏飞船的美感。</p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/6a8b6a51709adf96539ca7cf85bc9ecf.png" srcset="/img/loading.gif" class=""><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/1e18c10bef9b8a3e85fc039c0db29d29.png" srcset="/img/loading.gif" class=""><p>再来看下涂装，starsector飞船有涂装的很少，但是涂装能大大改善单个机体的外观确是无疑的。涂装分为两种：<strong>线型涂装</strong>主要沿机体方向勾勒出一条或几条线，它能直接把繁复的装甲结构统一成一个整体，由涂装飞船获得了精细与整体性的平衡。而<strong>面型涂装</strong>主要是有装饰作用，所有外壳刷上统一色系的涂装会强烈凸显出外壳与内部器件的对比感。另外，当飞船装甲过大时，合理利用涂装以显示分区可以让整体更加醒目</p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/27a23ea4f02a4091df97886fb83ac69d.png" srcset="/img/loading.gif" class=""><p>此外，海盗在其他势力的制式飞船上加涂装更能彰显其个性——这也是其他制式飞船很少画涂装的原因。</p><p>飞船的功能结构与其游戏内容是契合的，这里发现的<strong>功能结构</strong>有武器（机枪、激光）、机库、舰桥（航母有大舰桥，小飞机有小的舰桥）、引擎周围的导热管、货仓、存储罐、舷窗（有黄色亮光）、飞机指示灯（在机翼边缘）、反应装甲（这是从坦克上借鉴的）</p><p>飞船的“内部器件”是具有重要功能的模块，颜色一般以灰色、深灰色为主，内容主要是<strong>平行的管线</strong>、<strong>类似集成电路的设计</strong>，内部器件被故意设计成繁复的，一是为了凸显<strong>飞船的真实性</strong>，比如引擎给人的印象就是复杂，这种设计能突出引擎特征，二是与相对简单的装甲形成<strong>强烈对比</strong>，增添飞船层次性，让整个设计错落有致。在外壳周围的一些暗部设计很好地起到了<strong>装饰边缘</strong>的作用。</p><p>综合起来，starsector的飞船设计理念可以总结为：统一性、多样性、对称性、层次性、功能性、阵营风格各异。当然缺点也存在：大多数飞船缺乏涂装，内部器件和外部装甲的比例不协调，而且外部装甲的装饰太过复杂，导致整体看起来过于零碎没有统一感。大多数飞船色彩搭配并不鲜艳（虽然在鲜艳和真实感之间取得平衡时很困难的事），但有少数飞船结合优秀的曲面设计和对称性设计，虽然不鲜艳但是给人以强烈的美感。</p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/45f6a4319921dbfa4e24a680da4bd785.png" srcset="/img/loading.gif" class=""><h3 id="其他设计飞船拆解：案例与优劣分析"><a href="#其他设计飞船拆解：案例与优劣分析" class="headerlink" title="其他设计飞船拆解：案例与优劣分析"></a>其他设计飞船拆解：案例与优劣分析</h3><p><strong>一种相对小巧的飞船</strong></p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/5507559d4c9368d20e2751def388db6d.png" srcset="/img/loading.gif" class=""><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/cc2b75a5c6cba835fe489d3fa0ff4838.png" srcset="/img/loading.gif" class=""><p>优势：P2的颜色设计非常值得借鉴，灯光将机体的<strong>边缘</strong>映照出相同的颜色，白色作为<strong>连通颜色</strong>连接不同的区域，让足足5种颜色和谐地融汇在一起。P1和P2装甲的非发光部分做了做旧处理，增加了阴影，整体摆脱了平面化。</p><p>劣势：虽然有阴影，但是整体的光源并不清晰，也可能是平面光，让飞船的立体感不强烈。同时缺少作为复杂性点缀的内部器件，导致颜色的整体对比度也不强烈，缺少现实感。</p><p><strong>使用偏置光源的立体式飞船</strong></p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/664050ac456f11d91ec7984f15295521.png" srcset="/img/loading.gif" class=""><p>评价：这个飞船使用的是偏置光源，同时注意飞船的结构是三维立体式结构，这种结构的劣势在于：它<strong>过于写实</strong>，从而与低像素的画风形成不统一。3维飞船的直接映射需要强烈的立体支撑感，包括高清晰度、光源的正确照射，甚至要求必须在三维背景下完成，而这种设定对一个2D游戏是不可接受的。另外，因为3维飞船的真实性，许多2D用到的技巧都不可行，比如在飞船周围增加武器零件以丰富颜色对比度，这使得飞船的观感更差。</p><p><strong>配色出彩的一组飞船</strong></p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/3eb22e6231fbd04cd1e92be577aca4d4.png" srcset="/img/loading.gif" class=""><p>评价：这组飞船的最大特点就是配色非常舒服，每个飞船大致有3种主要颜色：一种主颜色和两种辅助色，主颜色又包含偏暗的阴影颜色。辅助色用于驾驶舱、灯光等点缀。</p><p><strong>造型和涂装都富有特色的飞船</strong></p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/1c8b396ab142f8ffae13f9053b1fd71f.png" srcset="/img/loading.gif" class=""><p>评价：这个飞船的造型很好看，整体呈现一个三角形，明显的轴对称结构，中间紧实两侧舒展，越靠近中间处颜色越浅，两侧占面积比较大的区域用深灰色，这样让整个飞机中心突出。同时在深灰色区域也都加上装甲设计，略微摆脱廉价感。但不足的是，没有强烈的阴影对照，整体的立体感欠缺很多。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>人权的边界线——底层人民的经济困境与生育权利</title>
    <link href="/2020/07/24/%E4%BA%BA%E6%9D%83%E7%9A%84%E8%BE%B9%E7%95%8C%E7%BA%BF%E2%80%94%E2%80%94%E5%BA%95%E5%B1%82%E4%BA%BA%E6%B0%91%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%9B%B0%E5%A2%83%E4%B8%8E%E7%94%9F%E8%82%B2%E6%9D%83%E5%88%A9/"/>
    <url>/2020/07/24/%E4%BA%BA%E6%9D%83%E7%9A%84%E8%BE%B9%E7%95%8C%E7%BA%BF%E2%80%94%E2%80%94%E5%BA%95%E5%B1%82%E4%BA%BA%E6%B0%91%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%9B%B0%E5%A2%83%E4%B8%8E%E7%94%9F%E8%82%B2%E6%9D%83%E5%88%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="人权的边界线——底层人民的经济困境与生育权利"><a href="#人权的边界线——底层人民的经济困境与生育权利" class="headerlink" title="人权的边界线——底层人民的经济困境与生育权利"></a>人权的边界线——底层人民的经济困境与生育权利</h1><blockquote><p>2020年5月29日广西河池，都安县保安乡上镇村弄邓，一对90后夫妻目前生育有9个孩子，分别有3个女儿6个儿子，最大的孩子12岁在读4年级，还有1个再有3个月也会降生。男子平时外出在工地打工赚钱养家，家里种有玉米自己吃。男子表示有在家产子的经历，都是老妈在帮忙。这对夫妻对未来充满希望，表示会慢慢打工为所有的孩子赚足学费。</p></blockquote><p>将每个家庭的财产与生育率作一幅图，生育率的图像呈现哑铃形：最低处是中产家庭，两边是富裕家庭和底层家庭。富裕家庭为了确保自己的产业有继承者，往往会生育不只一个孩子；底层人民则是在买“生产力”，一般来说，一个男孩成年后打工或者务农，总能挣到超过他抚养费用的生活费，加上政府给的低保费用，一户贫穷人家由此重获新生，如果中了“生育彩票”，培养出有正经工作的孩子，那么这户人家就很大可能在接下来的几十年内摆脱贫困，所有兄弟姐妹都可以过上好日子。</p><p>但我看到这个理论的时候，总是对其有很深的抵触，思考许久，我的疑惑是：人的权利，到底是谁在维护谁的权利？</p><hr><p><strong>消灭苦难有两种方式，要么改善现状，要么消灭幸福</strong></p><p>人们总是认为贫穷是单纯的，就像是缺水、缺粮一样，忍忍就过去了。但贫穷有着独特的吸引力：它将开阔的变成狭隘的、将公平变成嫉妒、将善良变成丑恶。就像是千千万万贪欲“幸福”的困苦家庭一样，这户人家选择在贫困中创造一个又一个生命。忍受着常年的物质匮乏，接受远远落后于他们求知欲的教育，长大则背负十一份责任，曾经的兄弟姐妹都化作工厂里大汗淋漓时承受的压力，如此一日又一日，一年又一年，年老力衰时回到那个抚育自己的村落，又有了数倍于自己一辈的孩子们，十人养一人，百人养十人，这一循环不会轻易打破，因为每个人都心知肚明：如果不再让新的生命献祭给“贫穷”，那么他们自身就会被献祭——无劳动能力者没有活下去的权利。</p><p>在大一返乡时，我在动荡的火车厢里翻阅着何夕的《大饥之年》，“大饥之年，人易子而食。”那天的夜里没有星星，空气中混合着人们的谈论声，这几百上千人融洽地待在狭小的车厢中，一定程度上缓解了我的恐惧感。当时我应该想到，几百公里之外的广西，那是另一种的易子而食，人出生即被预支出劳动力，永远看不到理想，永远看不到自由，我们为何不将其视为家畜呢？当然，他们是幸福的，因为在满是苦难的土壤里根本不存在幸福的种子，活在相对性里的人们，将隆起的高山看作地之柱，将奔流而下的瀑布视为天之泉。</p><p>存在者才有权利，存在者构建的法律，保障的是存在者的权利。时间是它们忠实的卫士，试图违背人类本性的反叛者都在短短百年内被不留痕迹地抹去。在过去几千年的历史中，人类的一部分当然也尝试过改写这一法律，但最后，往往只有存在者的法律获得了最多的拥护，婴儿出生后即受法律保护，因为任何谋杀的手段都让现存于世的人们感到自身的存在受到威胁。未存在于世的“人”会如何感想呢？谁也不管这个。但奇怪的是，我竟然认为人在诞生之前就是被保护的，就像是对废纸篓怜悯每一丝纤维一样无意义。</p><hr><p><strong>相对性与生存策略</strong></p><p>若是作一个审判者，以绝对自洽的法律判断对错，我找不到这样的标准。我现在如此怜悯贫困中的孩子，也有千百年后生活在物质无限充足的社会中，那些怜悯着我的人类。我的生活是如我认为的那般幸福，还是说我也同那些孩子一样，只在苦难中存在？道德与正义建立在相对性之上，人们如同一个个观察者，在不同的时间、不同的地位上去看待一件事，谁是“真理”呢？历史已经写下了答案，真理并不存在于世界上，有的只是无穷无尽的斗争与反斗争，支配与反支配。</p><p>人是有会创造文化认同的社会性动物，它们是图腾。如果将人类看作一个整体，它的进化无疑是令人惊叹的：人类在无数的个体竞争中进行自我迭代，又在多变的历史环境下不断异化。贫穷的人不再遵循自然法则，他们的法则是金钱的法则、法律的法则。活在资本主义“世界”的人们开始了自己的异化：泯灭自由意志、吃苦耐劳、容易满足、永远乐观。基因里强大的适应能力给了人类无穷无尽的生存动力，他们从泥土里挖掘草根，在时间域里开拓近似无穷尽的生产力工具——他们自己是工具，工具也是自己。局外人用自己的图腾去衡量异教徒，注定是毫无意义的。</p><p>正如尼采所说：上帝已死。</p><p>不到二十年时间，我也不例外地找到了自己的生存方式。可我不能再论证人类超越动物性的“道德”与“正义”了，唯物者的视角被笼上一层阴影，当然，总有毫无阴霾的唯物者们信仰这一图腾。过去的时间里我为了是否接受人性的异化而犹豫着，最终选择了规则，但也留存一些大义的理想，其实是欲望的延伸，来自于幼小时记忆中不知名的角落。当然了，理想是相对的，手段是唯一的。理性视角下的我无须为自己的规则与外界格格不入而懊恼，但依然需要进行庞大的知识整理使得理论自洽。想想生活在相对论宇宙中的人类吧，地球以每秒29.8千米的速度绕太阳公转，太阳也以一个速度绕银河系公转，银河系与仙女系在几亿年后交融在一起……但博尔特的短跑记录是百米9秒58。相对性下的人类世界依然是可以被构建的。</p><p>自由意志，那是更深层的本源，人顺应异化本能地活着，与在自由意志的控制下活着，究竟是否为同一个事物呢？让我发笑的是，我的理想是试图用前者的方法构建后者的世界。这大概是互相矛盾的吧，但如果两者能统一的话，就没有任何问题了。</p><hr><p><strong>后记</strong></p><p>这篇文章写在假期的深夜，尽管已经过了凌晨一点，但我还是毫无睡意，有时候也为了自身的存在迷茫过，在思考很久以后，得到了这篇答案。无意义吗？意义是不存在的，每个人创建自己的图腾，然后按照规则行事。</p>]]></content>
    
    
    <categories>
      
      <category>经济</category>
      
    </categories>
    
    
    <tags>
      
      <tag>时政分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
