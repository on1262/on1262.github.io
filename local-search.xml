<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【算法】单源最短路径dijkstra算法</title>
    <link href="/2020/11/08/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84dijkstra%E7%AE%97%E6%B3%95/"/>
    <url>/2020/11/08/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84dijkstra%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="dijkstra算法以及第七周OJ"><a href="#dijkstra算法以及第七周OJ" class="headerlink" title="dijkstra算法以及第七周OJ"></a>dijkstra算法以及第七周OJ</h1><h2 id="dijkstra算法理解"><a href="#dijkstra算法理解" class="headerlink" title="dijkstra算法理解"></a>dijkstra算法理解</h2><h3 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h3><p>运行一次dijkstra算法只能求出给定点到图中所有点的最短距离以及最短路径。</p><p>假设一个顶点数为n、边数为e的图，需要两张表：第一张表大小为n，<strong>记录给定点到图中所有点的最短路径</strong>，这张表在过程中会不断更新；第二张表是最短路径树SPT，在单源情况下，这个树只是从起点到n个节点的二层带权n叉树，被添加的最短路径都是确定的路径，不会被更改。</p><p>首先更新最短路径表，只将起点的邻接点更新到表中，其余置INF(无穷大)。</p><p>每一步开始时，先考察最短路径表中还没确定的点，也就是SPT以外的点，访问其中最短距离对应的点B，<strong>这个点是不确定点中最短的一条，对所有路径，它们只能从A出发，而表中至少包含A所有的邻接点的路径，任何从A到B的点的路径都至少有一段被包含在表中，也就是任何可能路径都不会比表中最短路径还要短</strong>，我们找的这个B恰好能利用这个信息：全图任何从A到B的可能路径，都不会比表中最短路径（一个从A到B的路径）短，那么表中的最短路径就是全图上的最短路径。</p><p>每一步结束时，总能得到一个B，将这个B添加到SPT中。然后要用B更新最短路径表：因为B已经被加在了SPT中，所以必须添加新的备选最短路径使得最短路径表中总能找到新的最短路径，而这个添加过程就引入了所有与B相关的路径：</p><p>假设其他路径都不是最短路径，那么B更新了邻接点后，必然会更新到最短路径：<strong>这是因为，假设路径表中有一条n+1步的路径，那么它包含的n步的路径必定是最短路径，否则它不会被更新到。当所有与SPT的邻接点都被更新到最短路径表中时，假设一个路径是到达邻接点的最短路径，那么它后退一步的路径必然是最短路径，我们已知这样的路径的所有邻接点都被更新，那么这个路径必然被包含在表中</strong></p><p>每次更新可能更新多个最短路径，但是每次只接收一个。</p><h3 id="优化策略：配对堆"><a href="#优化策略：配对堆" class="headerlink" title="优化策略：配对堆"></a>优化策略：配对堆</h3><p>见堆相关blog</p><p><strong>顶点查找</strong></p><p>利用dijkstra算法运行中不会扩增线性表的特点，构建堆的时候，只改变每个节点的指针，不改变节点存储的位置。也就是依然可以用下标搜索到特定node，然后搜索到其邻接表.虽然node不存储自身位置，但是可以取地址相减获得序号</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><strong>时间复杂度</strong></p><p>因为每次SPT只增加一个点，所以必定要迭代n次，每次迭代的耗时分析：</p><ol><li>要找到路径表中除了SPT以外的点的最短路径</li><li>将其添加到SPT中，并更新路径表中邻接节点的路径<br>如果我们用配对堆维护最小路径，每次取出堆顶是O(logn)的耗时，但每次更新路径是O(1)的操作，所以总耗时是O(nlogn + e)<br>对于稀疏图，用邻接表存储，查找邻接节点就是O(1)，总共需要O(e)次，不影响复杂度</li></ol><p><strong>空间复杂度</strong></p><p>SPT需要空间为n，建堆空间为n，最短路径表的空间为n（单源）</p><h2 id="OJ分析"><a href="#OJ分析" class="headerlink" title="OJ分析"></a>OJ分析</h2><p>OJ的问题主要在于：找所有最小路径数和空白区域划分。</p><h3 id="路径记录"><a href="#路径记录" class="headerlink" title="路径记录"></a>路径记录</h3><p><strong>根据最短路径的各个子路径也一定是最短路径</strong>的原理，只需要记录每个点到A点的最短路径的前一个点即可，在更新路径的时候，如果待更新路径与原路径相等，那么就同时记录两个点，所需空间复杂度就是邻接表的复杂度，即O(e)</p><h3 id="零权重分布"><a href="#零权重分布" class="headerlink" title="零权重分布"></a>零权重分布</h3><p>一个思路：例如给定10个置0权重，就构建10层的图，每层图都一样，但是层之间的路径是单向的：<strong>第一层的A节点用有向的0权重连接到第二层的A的邻接点</strong>，也就是说，算法可以选择在第一层到达终点，也可以选择通过0权重到达第二层，但是每次上升就无法下降，<strong>将二维图扩展到3维，就覆盖了所有可能的置0路线</strong></p><p>但是也有不严谨的地方：如果路径长度比置0数还要短，最短路径就是0，此时这个长度就没有用上。</p><h3 id="零权重复杂度分析"><a href="#零权重复杂度分析" class="headerlink" title="零权重复杂度分析"></a>零权重复杂度分析</h3><p>将倍数代入复杂度，log(aN)被线性化，而ae也是线性增长的，因此整个时间复杂度增长速度近似线性增长。</p><p>因为每层图都是一样的，0权重连接也可以通过邻接表查询到，所以权重存储空间与a无关。最短路径表和SPT会增长到aN，在第一次检测后，将最短距离减去最大权重依然大于当前最短距离的点看作不存在，当需要检测A层时，只需要存储可能经过的点的位置。</p><p>也可以同时以起点和终点进行2次最短路径检测，然后对每一条边进行比对，就可以得到经过某条边到达终点的路径长度，如果大于最小路径减去最大权重的a倍，就删掉该条边（一定不会经过这条边），然后再删除孤立点</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>马恩选集笔记：社会主义从空想到科学的发展</title>
    <link href="/2020/11/08/%E9%A9%AC%E6%81%A9%E9%80%89%E9%9B%86%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E4%BB%8E%E7%A9%BA%E6%83%B3%E5%88%B0%E7%A7%91%E5%AD%A6%E7%9A%84%E5%8F%91%E5%B1%95/"/>
    <url>/2020/11/08/%E9%A9%AC%E6%81%A9%E9%80%89%E9%9B%86%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E4%BB%8E%E7%A9%BA%E6%83%B3%E5%88%B0%E7%A7%91%E5%AD%A6%E7%9A%84%E5%8F%91%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="社会主义从空想到科学的发展"><a href="#社会主义从空想到科学的发展" class="headerlink" title="社会主义从空想到科学的发展"></a>社会主义从空想到科学的发展</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><blockquote><p>不能把思想同思维着的物质分开</p></blockquote><p>人可以假定上帝存在、思想存在，但是思想和上帝都是观测不到实体的，那么思想是否可以独立于肉体存在呢？诚然我们有抽象的思想概念，但它只存在于“人”的印象中，而不能被科学地观测到。同命运、上帝一样，不可知的东西是不能在其上构建理论的。</p><blockquote><p>不可知论断言人的认识能力不能超出感觉经验或现象的范围，不能认识事物的本质及发展规律。</p></blockquote><p>不可知论本身论述的证明或证伪都可以用其循环的逻辑解释，核心在于“XX是否是事物的本质及发展规律”这个命题无法证实或证伪，这就与科学有根本的区别。</p><p>当然可以继续对“科学”这种概念进行质疑，这样质疑下去可以对所有概念是否有意义提出怀疑，甚至可以对“无法证实且无法证伪”这一论断进行怀疑。在这个问题上，<strong>需要一些无理由也不需要理由的假设</strong>，这里假设值得研究的范围仅限于与人所感受的现实相关的东西，也就是：</p><blockquote><p>可是，如果我们达到了我们的目的，发现事物符合我们关于该事物的观念，并产生我们所预期的效果，这就肯定地证明，在这一范围内，我们对事物及其特性的知觉符合存在于我们之外的现实</p></blockquote><p>所谓“经世济用”并不排斥抽象物，而是排斥不能证明也不能证否的、与其他物没有关联的抽象物。再此基础上利用推理、验证等手段可以证明一些感知是否正确，也就可以认为认识到了事物的“客观本性”</p><blockquote><p>这种观点认为，一切重要历史事件的终极原因和伟大动力是社会的经济发展，是生产方式和交换方式的改变，是由此产生的社会之划分为不同的阶级，是这些阶级彼此之间的斗争。</p></blockquote><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><blockquote><p>在形而上学者看来，事物及其在思想上的反映即概念，是孤立 的、应当逐个地和分别地加以考察的、固定的、僵硬的、一成不变的研究对象。</p></blockquote><p>静止不光是运动的一部分，实际上绝对的静止是不存在的，这就和运动有相当大的区别：绝对的静止并不存在，所以以静止为前提研究得出的结论就可能带有一些“未可知”的成分。</p><blockquote><p>辩证法在考察事物及其在观念上的反映时，本质上是从它们的联系、它们的联结、它们的运动、它们的产生和消逝方面去考察的。</p></blockquote><p>这类似于黑箱的概念，事物的联系也就是人接触事物的途径，如果两个事物在人所能观察到的范围内都是一致的，那么这两个事物应当被看作同一事物。而人赋予的名字等都是符号，没有额外的内涵。</p><p><strong>唯心主义</strong></p><blockquote><p>客观唯心主义认为，在现实世界之外独立存在着一种客观精神，它是世界的本源，世界万物是由它产生（派生）出来的。其著名代表人物，有中国的朱熹、古希腊的柏拉图和德国的黑格尔等。</p></blockquote><blockquote><p>主观唯心主义是把人的主观精神（意识、观念等）作为认识世界的出发点，存在主观精神之中的是认知上的世界，是主观精神的产物，而并非真正客观上的世界。主要代表人物，有中国的陆九渊和王守仁，和德国的费希特等。</p></blockquote><p>极端唯心主义可以称为唯我主义。唯心和唯物的根本分歧在于物质和精神哪个是第一性质，哪个是第二性质。</p><p>从唯物主义角度解释精神，可以解释为一种局部混沌、整体却有规律的大脑活动。不同于机械决定论的观点，脑的活动是无法预知的，但这和不可知论者的观点又有区别：脑的活动尽管无法预知，但是精神实在地影响了客观世界，精神的存在是可以验证的，又因为不在不可知的领域构建理论，这里应当排除第一性的精神，于是唯物主义与唯心主义的对立就成立了。</p><h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><blockquote><p>以往的全部历史，除原始状态外，都是阶级斗争的历史；这些 互相斗争的社会阶级在任何时候都是生产关系和交换关系的产 物，一句话，都是自己时代的经济关系的产物。</p></blockquote><p>阶级当然存在于历史中，但是不能这样就论断是“阶级斗争的历史”。在研究历史发展的规律的时候，历史中的各个事件是不等权的，这种权重变化是人赋予历史的而不是历史自身的属性。从客观上来讲，一场雨和一场革命没有区别，只是前者充满偶然性，后者暗含历史必然规律。</p><p>这里我倾向于认为：阶级斗争在历史发展中有其必然规律，因此从实用的角度，可以解释为“阶级斗争的历史”。</p><h2 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h2><blockquote><p>唯物主义历史观从下述原理出发：生产以及随生产而来的产品交换是一切社会制度的基础；在每个历史地出现的社会中，产品分配以及和它相伴随的社会之划分为阶级或等级，是由生产什么、怎样生产以及怎样交换产品来决定的。</p></blockquote><p>历史规律必然要排除偶然性，即研究群体性的东西。可以假定每个时代的“人”作为一种生物是基本不变的，古代人放到现代社会经过现代化教育也与现代人无差异。那么个体的因素不变，个体差异又被抹去，只剩下个体之间的联系，即群体性的东西。</p><p>先承认一种稳定性假设：大多数人没有足够的时间和精力在一生中同时从事很多层面的工作。在货币发挥作用的时代，生产和交换确实是社会制度的分类依据，但是如果没有货币呢？</p><p>可以假设人们不需要衡量不同物品间的价值，也不能用一个物品与另一个物品交换。可一定要面对物质需求不能满足人们需要的情况，这就要求物质需求极大满足。或者是在赛博空间中得以实现。</p><blockquote><p>一部分人的过度劳动成了另一部分人失业的前提</p></blockquote><p>推理过程如下：机器生产让劳动力多出来，但是机器生产的东西却需要所有人都消费，于是这些人就变成了“后备军”，此时生产对劳动力的需求大于市场对消费者的需求，劳动力永远是过剩的，而消费者永远是欠缺的。这就导致两个情况：劳动力互相挤压工资，也就是内卷化，和商品滞销，也就是市场经济萎靡。</p><blockquote><p>我们已经看到，现代机器的已经达到极高程度的改进的可能 性，怎样由于社会中的生产无政府状态而变成一种迫使各个工业 资本家不断改进自己的机器、不断提高机器的生产能力的强制性 命令。</p></blockquote><p>在买方市场下，生产产品质量越好、规模越大越能盈利，从而越能提升机器效能。通过交易的形式，资本环境下的优胜劣汰完全由盈利决定，于是发展到最终的企业一定是盈利效果最好的企业：对于劳动力市场，必须提高员工可替代性，让每个员工成为“螺丝钉”，从而最大化利用劳动力市场压低劳动力价格；其次，对于消费者市场，必须对市场进行垄断从而让消费者只能购买其产品。企业的扩大生产只是加剧了整个周期的进行速度。</p><blockquote><p>在危机中，社会化生产和资本主义占有之间的矛盾剧烈地爆发出来。商品流通暂时停顿下来；流通手段即货币成为流通的障碍；商品生产和商品流通的一切规律都颠倒过来了。经济的冲突达到了顶点：<strong>生产方式起来反对交换方式</strong>。</p></blockquote><p>生产方式指工厂机器生产，交换方式指商品交换。机器生产使得少部分人获得大部分利润，交换方式使得大部分人需要提供大部分的消费，显然两者是冲突的。</p><blockquote><p>支配商品生产的规律日益显露出来，它们的作用日益加强。竞争不可遏止。个别工厂中的社会化组织和整个生产中的社会无政府状态相矛盾</p></blockquote><blockquote><p>机构和交通机构起初由股份公司占有，后来由托拉斯占有，然后又由国家占有。资产阶级表明自己已成为多余的阶级；它的全部社会职能现在由领工薪的职员来执行了</p></blockquote><blockquote><p>无产阶级将取得公共权力，并且利用这个权力把脱离资产阶级掌握的社会化生产资料变为公共财产。</p></blockquote><p>这是恩格斯总结的历史发展规律，但是无产阶级取得公共权力的过程说的不是很清楚：从股份公司发展到托拉斯这一步可以在完全竞争的理想化市场下实现，如互联网公司的兼并最终形成少数“大厂”，从托拉斯到国家的这一步就不是很明显。改革开放的原因就是要促进经济活力，如果大公司集体转编制，宏观上的体现就是回归计划经济时代，人人大锅饭使得每个人劳作意愿下降。</p><p>应当看到国家与个人之间平衡是在各层次权力的博弈中达到稳定的。如果阶级对立消失，<strong>个人与社会的矛盾是否会代替阶级之间的矛盾成为新的社会冲突点？</strong>。如果结团体的利益高于保持个体的利益，社会会朝着阶级化的方向前进。反之，社会关系会逐渐原子化，回归到个体与个体间的关系。</p><p>如果人人都能“不劳而获”，那么势必大多数人都不会劳动，拿低保度日。下面是关于北欧高福利制度的介绍</p><p><strong>北欧高福利制度的支撑</strong></p><p>来源：<a href="https://www.zhihu.com/question/58173613/answer/676810895" target="_blank" rel="noopener">https://www.zhihu.com/question/58173613/answer/676810895</a></p><blockquote><p>聚焦高附加值，低发展速度产业</p></blockquote><p>这一条是基本的：高附加值理论上可以带来高社会福利，低发展速度代表可以“吃老本”而不用担心996.<strong>丹麦发展畜牧业、生物制药、基础材料、艺术设计</strong></p><blockquote><p>他们得以保持竞争力的，往往已经不是难以逾越的“绝对技术壁垒”，而是以用“低市场增长”（而且大部分行业市场也不大）+“较高技术门槛”成的一圈“黑域”</p></blockquote><p>市场太小决定了北欧的高福利制度是不可大范围推广的，这种高技术门槛、低市场增长的产业不会太大，就比如圆珠笔芯这个产业。之所以没有后来者愿意跟进，是因为这些产业拥有十足的<strong>先发者优势</strong>，先积累的排斥后积累的，加上自身获利实在不多，因此得以保全。</p><blockquote><p>只要社会总劳动所提供的产品除了满足社会全体成员最起码的生活需要以外只有少量剩余，就是说，只要劳动还占去社会大多数成员的全部或几乎全部时间，这个社会就必然划分为阶级。</p></blockquote><p>劳动时间与生产力发展在现阶段不一定有直接联系：互联网行业是先进生产力，但是员工依然996。在现在生产力比较发达的时代，为了维持金融体系稳定，大量时间被用于偿还过去的借债。比如说房地产行业，大量卖地资金由百姓承担，相当于政府向人民借钱发展经济，而且地价提升带来买房刚性需求受阻，大多数人被迫为了房贷工作。</p><p>当人民无法享受到生产力发展带来的物质丰富时，劳动时间也就无法随着生产力发展而下降。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【算法】堆</title>
    <link href="/2020/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%A0%86/"/>
    <url>/2020/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="堆的分类"><a href="#堆的分类" class="headerlink" title="堆的分类"></a>堆的分类</h2><p>大根堆指堆顶是最大元素，小根堆指堆顶是最小元素。但是两者都要求数据以有序的结构存储、读取，这个结构就是根节点与子节点的大小关系一致。</p><h2 id="自底而上建立堆"><a href="#自底而上建立堆" class="headerlink" title="自底而上建立堆"></a>自底而上建立堆</h2><p>首先将存储数据的一维数组看作一个完全二叉树，然后从右向左，从叶子节点开始遍历，<strong>因为完全二叉树的存储位置都是固定的，所以每次排序可以O(1)地搜索到位置</strong>，同时因为每次排序时都将数组后面的元素调整到前面，所以只需一次遍历即可构建堆，复杂度O(n)</p><h1 id="配对堆"><a href="#配对堆" class="headerlink" title="配对堆"></a>配对堆</h1><h2 id="原理简述"><a href="#原理简述" class="headerlink" title="原理简述"></a>原理简述</h2><p>配对堆用指针的方式将一个复杂结构线性化存储到内存中。一个节点包含3个指针，一个指向第一个孩子，一个指向左侧兄弟（最左侧的指向父亲），一个指向右侧兄弟。</p><h2 id="操作简述"><a href="#操作简述" class="headerlink" title="操作简述"></a>操作简述</h2><p><strong>查找最小值</strong></p><p>对于小根堆，返回堆顶即可，复杂度O(1)</p><p><strong>合并两个堆</strong></p><p>合并到根节点，对于小根堆，将较小的根作为合并后的根，只需要拉一根线（指针）即可，复杂度O(1)</p><p><strong>插入</strong></p><p>插入也是插入到根节点，同理，O(1)</p><p><strong>decrease-key（修改节点并重新调整）</strong></p><p>decrease指的是修改一般是往堆顶的方向修改，即只会增大/减小。修改方法是将其与父节点的连接断开，然后将其作为新节点添加到根节点处。</p><p><strong>删除堆顶</strong></p><p>删除堆顶是为了取出最小值，这也是堆的限制：只能从堆顶删除，从而便于单一地维护堆结构。为了重新构建新堆，删除后会剩下若干子堆，将它们先两个两个合并，然后再对合并后的堆进行合并，直到所有节点都合并到根节点为止。</p><p>合并的总次数可能会退化到O(n)，但如果配对堆的结构保持住，就是O(logn)的复杂度</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>删除堆顶的操作平摊复杂度是O(logn)，修改节点操作认为是O(loglogn)，在n不很大的时候都可以看作常数。</p><h2 id="实现简述"><a href="#实现简述" class="headerlink" title="实现简述"></a>实现简述</h2><p>自底而上构建堆即采用完全二叉树的方式，此时数据是顺序存储的，但是多叉树必定是乱序的，因此需要用3个指针，确保同层兄弟互相指向，同父节点至少一个指向父亲，且父亲指向第一个儿子。</p><p>在修改节点的时候，源数据的位置并不会变，只是指针会变。<strong>这就要求源数据在第一次建堆以后不能添加新值，只能修改和删除</strong></p><p>在修改节点时，若删除的是第一个儿子，就需要同时修改父亲处的指针，因为第一个儿子与父亲是双向连接的，所以容易修改。若修改非第一个儿子，则需要将左右兄弟连接，这也是O(1)的。</p>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】递归与递归消去</title>
    <link href="/2020/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E5%BD%92%E6%B6%88%E5%8E%BB/"/>
    <url>/2020/11/03/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E5%BD%92%E6%B6%88%E5%8E%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="递归与递归消去"><a href="#递归与递归消去" class="headerlink" title="递归与递归消去"></a>递归与递归消去</h1><h2 id="递归的复杂度"><a href="#递归的复杂度" class="headerlink" title="递归的复杂度"></a>递归的复杂度</h2><p> 当调用栈较多时，对栈空间的影响较大，同时调用栈也有时间花销。</p><p> 当重复计算某些问题时（菲波纳契数列），递归不能利用已知的问题的解，时间复杂度与非递归算法有本质上的差异。</p><h2 id="消除递归"><a href="#消除递归" class="headerlink" title="消除递归"></a>消除递归</h2><p> 尾递归可以直接用循环代替，减小栈空间开销。</p><p> 对非尾递归的情况，可以显性模拟一个递归调用栈，然后进行结构上的优化。</p>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】线性表</title>
    <link href="/2020/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2020/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="分类和概念介绍"><a href="#分类和概念介绍" class="headerlink" title="分类和概念介绍"></a>分类和概念介绍</h2><p>队列分为顺序队列、循环队列、链式队列，没有本质区别。两者都实现的是：<strong>存储了入队操作顺序，实现先进先出</strong>，结构上，队列有个头指针和尾指针，有入队和出队操作，为了在有限的空间上实现不限次的入队出队操作，必须使得队列元素前后顺序与存储顺序无关，所以引入循环队列（虚拟一个循环的空间）和链式队列（在存储位置上离散化）。</p><p><strong>优先级队列</strong></p><p>优先级队列给每个点定义一个优先级，入队没有变化，优先级高的先出队。<strong>因为线性存储结构只能存放局部信息，所以无法实现全局范围内优先级的自动查找</strong>，无论用有序/无序、链表/顺序表，都至少在一个操作上有O(N)的复杂度。</p><h1 id="线性表的应用"><a href="#线性表的应用" class="headerlink" title="线性表的应用"></a>线性表的应用</h1><h2 id="栈实现自然表达式运算"><a href="#栈实现自然表达式运算" class="headerlink" title="栈实现自然表达式运算"></a>栈实现自然表达式运算</h2><p>由两个栈组成：一个符号栈，一个操作数栈。</p><p>实现原理：<strong>从左往右检测，当后一个运算符比前一个运算符等级低的时候，必定可以先对前面计算</strong></p><p>为了确保每一个高优先级运算符都能检测到一个低优先级运算符，将结尾加一个符号<code>;</code>来通知截止。</p><p>所有运算表达式都存在一个第一个计算的位置，这个位置有如下规律：操作数优先级一定不低于右边，否则右边先计算；操作数优先级一定高于左边，否则左边先计算。</p><p>在运算表达式中，只要先计算这样的位置，就一定能符合运算顺序。因此入栈时先比对进入的是否高于左边，高于左边才入栈，否则当前元素就满足栈顶元素的“右边”，栈顶先计算。</p><p>另外，括号的表达式应当尽量低，这是因为括号给定了一个局部最低优先级，使得其内部的数只能先计算再与括号计算。括号本身的计算就是消去，对结果无影响，其低优先级的特性才对运算顺序有影响。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>线性表反映的是一种时间复杂度和空间复杂度交换的技术。当我们预设一种存储方式，就在其中包含了一维的存储信息。用链表的方式实现O(1)的相邻信息存储；用顺序表的方式实现O(1)的随机读取；用队列实现先进先出的顺序；用栈实现后进先出的顺序。</p>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】字符串查找KMP算法</title>
    <link href="/2020/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BEKMP%E7%AE%97%E6%B3%95/"/>
    <url>/2020/11/02/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BEKMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><p>为了解决重复配对问题，KMP算法的思路就是<strong>利用子串的信息，每次匹配让子串移动最大的距离</strong>。</p><p>这就涉及到如何不重复：<strong>先找出模式串（用来比对的子串）每个位置上往前读的最长相等后缀，这个相等是与从一开始往后读的进行比较</strong>, 那么比对第一位就失败，就移动一位；如果比对K位的时候失败，就找K位前的字符串是否能作为开头，预处理已经对每一位这样的情况进行了分析，现在用的时候就不需要重复比对，节省了时间。</p><p>预处理中，记开头比对的地方为i，对于j位的匹配，它前面j-1位的匹配最长长度已经知道了，只要将i往后移一位就可以知道j位是否还匹配。如果匹配就继续移，如果不匹配，那么检查一下前面可能匹配的点，注意此时i不动，i前面的串和j前面的一致，而j前面的串又和j-1的最大匹配串一致，所以去找前面还有没有可能匹配上的，如果没有，就迅速跳转到第一位，重新开始比对。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>比对一次，失配，子串滑过一段距离，下一次比对如果再失配，子串已经把最大可“滑”距离用完了，无法再移动，就只能换下一个位置比对，所以每个点最多比对2次。预处理中，检查匹配只需要检查一次，如果不行就从开头比对，每个点最多比对2次，因此复杂度是2m,总时间复杂度为O(m+n)</p>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>马恩选集笔记：关于费尔巴哈的提纲</title>
    <link href="/2020/10/05/%E9%A9%AC%E6%81%A9%E9%80%89%E9%9B%86%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%85%B3%E4%BA%8E%E8%B4%B9%E5%B0%94%E5%B7%B4%E5%93%88%E7%9A%84%E6%8F%90%E7%BA%B2/"/>
    <url>/2020/10/05/%E9%A9%AC%E6%81%A9%E9%80%89%E9%9B%86%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%85%B3%E4%BA%8E%E8%B4%B9%E5%B0%94%E5%B7%B4%E5%93%88%E7%9A%84%E6%8F%90%E7%BA%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="关于费尔巴哈的提纲"><a href="#关于费尔巴哈的提纲" class="headerlink" title="关于费尔巴哈的提纲"></a>关于费尔巴哈的提纲</h1><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><blockquote><p>人的思维是否具有客观的真理性，这不是一个理论的问题，而是一个实践的问题</p></blockquote><p>这个论述强调的核心是基于现实而非理念上的唯物主义。从现实来说，讨论“理想”的人是没有意义的，因为理论的东西无法干涉现实。相反，<strong>讨论现实中人的思维是否具有理想的真理性是有意义的</strong>，因为这个基础是现实的人，也就有了现实的作用。因此这个问题是实践的，也就是需要在现实中寻找答案的。</p><blockquote><p>关于环境和教育起改变作用的唯物主义学说忘记了：环境是由人来改变的，而教育者本人一定是受教育的。因此，这种学说必然会把社会分成两部分，其中一部分凌驾于社会之上。</p></blockquote><p>这是在其理论中剥离出“理念”的部分。不存在脱离于现实的环境和教育，也就不存在理想化的、理念的环境与教育，这势必造成环境和教育与人互相作用，甚至不能把它单独看作一个独立于人的客体来研究。</p><blockquote><p>他(费尔巴哈)做的工作是把宗教世界归结于它的世俗基础。</p></blockquote><p>马克思否认宗教世界理念的存在性，这个和费尔巴哈是一致的，但是马克思又认为宗教世界是世俗基础自身的异化，也可以说是世俗世界选择的分裂。因此宗教世界也不是和世俗世界并列的东西，而是被包括在内的。</p><blockquote><p>他把感性不是看做实践的、人的感性的活动。</p></blockquote><p>感性的意思大概是人的感知，这是被自然地包括在实践中去了，而不是单独地抽象出一个过程。</p><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><p>实践本质论虽然有进步意义，但是依然有缺陷：在实践之前，世界就没有本质了吗？为了建立宏观的结构体系，我们必须做出很多基本的、无需认证的假设，比如说一个理论必须逻辑自恰等，否则就会陷入虚无主义而无法开展研究。我认为所有理论应当有一个“经世济用”的假设，也就是说，不包含任何不可知的、形而上的东西，且不做出任何从概念到概念的论证，因为这些论证都是对实践无帮助的。相反，可以做出从概念到概念的总结，与论证不同，总结能让人更加深入地把握一个理论，具有实用的价值。</p><p>对于实践本质论，我提出几个问题：实践的定义是什么？本质是否是永恒不变的？实践本质论是可知的吗？</p><p>第一个问题涉及到语言的模糊性，一个例子是特修斯之船，深究下去，“实践”的范围是不清楚的，这就意味着一部分行为是处于模糊状态，而这部分行为是否是本质呢？本质也是没有明确标准的。事实上，所有试图在现实世界中寻找标准，也就是永恒真理的尝试，都不可能取得成功。<strong>人处在现实之内，不可能触摸到脱离现实的任何东西、概念、形体，那么因果、标准、逻辑、道德是否存在，对人而言都是可以随意假设的。</strong></p><p>关键在于，人所研究的理论应当是经世济用的理论，这个动力是先验的、无理由的。在此基础上提出认识世界的逻辑：</p><p>首先肯定客观世界的存在，否则无法将诸多规律独立于主体之外，规律也就失去效用。然后承认逻辑自恰的标准，这也是规律能够存在的条件之一。最后将若干规律视为“公理”，即无法验证真伪，但是又在当前视角下符合现实情况的规律。这些规律是不需要理由证明的，也是无法证明的。</p><p><strong>此时可以归纳地说：实践是本质的</strong>，这个结论建立在上述不需要理由的假设上，本身是上述结论的总结，不能作为其他结论的理由，也不应该作为其他结论的理由。</p><p>实践的本质性在于，所有公理依靠实践检验，一旦没有经世济用的作用，公理就失去意义。只要承认经世济用的前提，公理本身不应被人作为独立于客观世界的存在，此时公理就脱离了实践。</p><p>此时再来看“实践”和“本质”定义的模糊性：这两个词是总结性的，但是不能作为原因，这个结论存在的前提是这种解释能够达成特定的效用，也就是它所总结的规律是有效的，而就其本身的范围，实践的范围当然包括很多模糊的东西，但这并不影响它的正确性：<strong>不存在某个真理要求一个结论必须是逻辑自恰的，对于总结性的结论，只要它能单向地包括所指的性质（或者只是大部分性质），就可以说它拥有了实践上的意义</strong></p>]]></content>
    
    
    <categories>
      
      <category>哲学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>马克思</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【读书笔记】算法导论</title>
    <link href="/2020/10/04/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    <url>/2020/10/04/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="算法导论-读书笔记"><a href="#算法导论-读书笔记" class="headerlink" title="算法导论-读书笔记"></a>算法导论-读书笔记</h1><h2 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h2><p>在写OJ的时候发现自己对算法的理解相当不足，遂产生系统地学习算法的想法。这本书相当厚，在第一遍看的时候一定没法做到每道题都写完并且AC。我试想在阅读的过程中总结那些新的、巧妙的设计思想，也就是脱离编程语言的、脱离具体问题的一些普适性的算法设计和优化思路。所以在记录的时候也不会具体到某一道题，<strong>而是着重分析算法对现实世界的抽象原则以及优化思路</strong>，当然一些典型问题会记下用于解释说明。</p><p>因为不涉及具体的解题实践，这种练习被移到OJ中完成。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>一般来说，对于四则运算、数据移动、条件判断、方法调用这些指令，都是需要常量时间完成的。如果涉及内存数据的存储，那么存储花费的时间可能远多余计算所用时间。</p><p>一些指令在特定条件下会被简化：如幂乘运算在用移位法乘2的n次方的时候只需要常量时间。</p><p>一般只分析最坏情况，因为最坏情况通常和平均情况相差不大，且有时候经常出现最坏情况（数据库查找不存在的数据）</p><h2 id="分冶法：将大规模问题拆分成小规模问题"><a href="#分冶法：将大规模问题拆分成小规模问题" class="headerlink" title="分冶法：将大规模问题拆分成小规模问题"></a>分冶法：将大规模问题拆分成小规模问题</h2><h3 id="分解，解决，合并"><a href="#分解，解决，合并" class="headerlink" title="分解，解决，合并"></a>分解，解决，合并</h3><p>分冶法使用有些条件：</p><ol><li>所拆分的问题必须是独立的，互相不能依赖</li><li>子问题和母问题之间是线性组合的关系，这样能在O(N)的时间内从子问题的解得到母问题的解。</li><li>子问题和母问题必须能用同一形式表述，可以用统一的方法解决。</li></ol><p>需要处理的有两种情况：递归情况和基本情况，分别对应递归方法的继续递归选择和返回值选择。</p><h3 id="主方法求递归式的时间复杂度"><a href="#主方法求递归式的时间复杂度" class="headerlink" title="主方法求递归式的时间复杂度"></a>主方法求递归式的时间复杂度</h3><h3 id="矩阵乘法的Strassen算法"><a href="#矩阵乘法的Strassen算法" class="headerlink" title="矩阵乘法的Strassen算法"></a>矩阵乘法的Strassen算法</h3><h2 id="贪心法："><a href="#贪心法：" class="headerlink" title="贪心法："></a>贪心法：</h2><h3 id="最大子数组问题"><a href="#最大子数组问题" class="headerlink" title="最大子数组问题"></a>最大子数组问题</h3><p>最大子数组问题：在一个数的序列里面，寻找一个序列和最大的连续序列。</p><p>这个问题可以找出一个具有全局性质的指标：假设<code>a_i</code>是最大子数组左侧角标，那与<code>a_i</code>相连的任意左侧子数组都不可能有正和，任意右侧子数组都不可能有负和（在右侧角标左边的数组），于是对于左侧角标，它能被贪心算法命中一次，且此时全局最优解一定能被遍历一次，然后用擂台法就可以得到结果了。</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>opencv基础学习</title>
    <link href="/2020/08/10/opencv%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/08/10/opencv%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="opencv基础学习笔记"><a href="#opencv基础学习笔记" class="headerlink" title="opencv基础学习笔记"></a>opencv基础学习笔记</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在硬设开发的期间需要用到图像识别的功能，于是安装了opencv试图利用现成的库来实现。虽然只是调库，但是基本的概念还是得弄清楚，否则在其之上的修改就没法做了。这篇笔记主要记录opencv的基础概念，参照的是官方的tutorial，做的是一个总结式的笔记。和之前的笔记一样，也是重思想不重细节。</p><h3 id="Mat-图像的C-类抽象"><a href="#Mat-图像的C-类抽象" class="headerlink" title="Mat 图像的C++类抽象"></a>Mat 图像的C++类抽象</h3><p>mat组成就是一个代表灰度的矩阵+header,其中header存储矩阵大小、内存位置等信息。但是图像抽象并非如此简单：mat考虑到了内存管理问题，引入了counting system，并且对cv程序中的常用场景（图像传递）进行优化，减少大量复制带来的性能损耗。</p><p><strong>counting system</strong></p><p>多处引用带来一个问题：谁来释放这片内存？在reference counting mechanism的机制下，<strong>当程序中没有任何指针指向这片内存时，就代表它可以被释放了</strong>，没有指针指向内存，代表程序在这个时候是看不见这片内存的，也就无法利用其中的信息。reference counting并非要记录最后剩下的是“哪个”引用，因为哪一个都是无所谓的。这就像游乐园进场的数数一样，每进去一个就数一个数，在数到满员的时候让下一个游客等待下一轮再进去。</p><p><strong>color space</strong></p><p>不同色域的区别有两个：储存在矩阵中数值的范围和各层间的呈色方式。影响矩阵的只有前者，但是这也代表指定mat的时候就要指定颜色的分解方式。</p><p>另外，mat也提供了对图像的一个部分引用，或者是对图像中的颜色进行整体替换的功能。</p><h3 id="Feature-Matching-图像特征匹配"><a href="#Feature-Matching-图像特征匹配" class="headerlink" title="Feature Matching 图像特征匹配"></a>Feature Matching 图像特征匹配</h3><p>突然跳到这里是因为目前需要先理解这部分的内容。</p><p><strong>Matcher</strong></p><p>特征匹配简单地来说，就是选取图像的一部分计算出一个“特征”，这个特征进入到特定的数学空间中，此空间可以具有抗旋转、抗缩放、抗亮度变化等特性，也就是说这些变换并不会使同一个特征偏离太远。这个“距离”也是由数学空间所定义的。</p><p>Matcher操作的元素是Descriptor，也就是描述符，测量的量是两者的距离，操作的方式是逐一测量，并选出最接近的两个描述符（Brute-Force Matcher），距离的描述方式不一，可以是L1范数，也可以是L2范数。</p><p>一个DMatch Object抽象的是一对匹配的特征符，存储了特征符的序号、距离、图像序号。</p><p><strong>Descriptor</strong></p><p>matcher本身并不包含技术性的东西，特征符的选取和其在数学空间的位置都是由算法决定的，这个算法就是SIFT, ORB等。不同算法的选取方式不同，但不同的descriptor都在线性空间中，这就为Descriptor和matcher的解藕提供了基础。</p><p>descriptor在opencv中表现为一个高维向量，descriptor和key point共用一个序号来代表一个特征点的性质</p><p><strong>Key point</strong></p><p>关键点包括3个内容：位置、尺度、方向。位置指关键点在图像上的位置，这里的图像是经过尺度变换得到的。方向是关键点具有旋转不变性的原因：同一组关键点的方向应该是一致的，因此统计出整个图像的方向后，就可以还原出图像被旋转的角度（如果整个图像方向为0，那就类似圆形）。</p><p>Test: origin to scale_up:<br>– Max dist : 0.614476<br>– Min dist : 0.023140<br>normalized delta x=0.0046309<br>normalized delta y=0.0441643<br>normalized center=-0.0114116<br>Test: origin to left:<br>– Max dist : 0.593219<br>– Min dist : 0.025086<br>normalized delta x=-0.187185<br>normalized delta y=-0.0130463<br>normalized center=0.0207472<br>Test: origin to right:<br>– Max dist : 0.628698<br>– Min dist : 0.021708<br>normalized delta x=0.141781<br>normalized delta y=-0.0297364<br>normalized center=-0.0214759<br>Test: origin to up:<br>– Max dist : 0.679967<br>– Min dist : 0.036778<br>normalized delta x=-0.037491<br>normalized delta y=-0.216021<br>normalized center=0.0254128<br>Test: origin to down:<br>– Max dist : 0.537027<br>– Min dist : 0.024740<br>normalized delta x=0.00706097<br>normalized delta y=0.0883386<br>normalized center=0.0443451</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自平衡小车开发笔记</title>
    <link href="/2020/07/26/%E8%87%AA%E5%B9%B3%E8%A1%A1%E5%B0%8F%E8%BD%A6%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/07/26/%E8%87%AA%E5%B9%B3%E8%A1%A1%E5%B0%8F%E8%BD%A6%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="陀螺仪模块"><a href="#陀螺仪模块" class="headerlink" title="陀螺仪模块"></a>陀螺仪模块</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>MPU6050是一个陀螺仪模块，最近在做单片机的时候需要用到姿态估计，但是这个东西内部机理比较复杂，而且搜了一圈没有找到详细的教程，这个笔记包括硬件接口的解读和信号处理，因为做的项目是平衡车，所以会牺牲刷新率和角度范围来尽量提高精度。</p><h3 id="加速度计"><a href="#加速度计" class="headerlink" title="加速度计"></a>加速度计</h3><p>首先要明确加速度计测的是什么：加速度计的等效模型是一个铁球在正方体盒子中达到与正方体保持相对静止时与各个面的压力（规定正方向，一对面的压力就有了符号），这也就是说，铁球加速度时刻等于盒子加速度（不然他俩无法保持相对静止），铁球被封闭在盒子内，接触力只有压力，非接触力有重力、磁力等，但是在实际的加速度计中，是没有铁球的，也就没有磁力。</p><p>那么，可以推出：</p><p><strong>传感器加速度=测量加速度+重力加速度</strong></p><p>这里的三个加速度要转换到同一坐标系</p><img src="/2020/07/26/%E8%87%AA%E5%B9%B3%E8%A1%A1%E5%B0%8F%E8%BD%A6%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/2020-07-26-20-14-32.png" srcset="/img/loading.gif" class=""><p>我们需要用测量加速度得到传感器姿态，也就是传感器坐标系到地面坐标系（重力加速度所在坐标系，也是人观察的坐标系）的映射规律，3个已知量解出3个未知量，这就要求传感器加速度已知。这个要求是加速度计自身办不到的，需要借助其他模块。</p><p>但是，平衡车这一例子上，可以借助结构带来的额外条件用加速度额外解出角度。</p><p>当加速度计被绑定在平衡车上时，我们假设在短时间内平衡车车轮制动，那么整个车体相当于一个木杆，加速度只能有一个方向：与杆垂直的方向。我们将传感器的总加速度加上重力加速度，也就得到测量加速度。<strong>这个加速度在Z轴上的投影大小等于重力加速度在Z轴上投影的大小</strong>，用反余弦直接就可以解出角度。</p><p>为此，需要的条件是：短时间内维持车轮制动，在短时间达到近似静止或匀速运动，并对传感器高速采样，得到足够精确的结果。</p><h3 id="角速度计"><a href="#角速度计" class="headerlink" title="角速度计"></a>角速度计</h3><p>在非平衡状态时，加速度计就不可用（其实也可以作核算），这时对角度的计算就用角速度的积分。</p><h1 id="电机控制"><a href="#电机控制" class="headerlink" title="电机控制"></a>电机控制</h1><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>步进电机在调试后暴露出的缺点是：速度太快，加速减速算法太复杂，而且静止状态会过热。改进的方法是选用A4988，并采用16细分模式。利用A4988的最大电流控制，将静止电流设置在0.7A左右，这样基本就不会发热。剩下的技术难点就是pwm调频进行速度控制。</p><h3 id="pwm底层调频"><a href="#pwm底层调频" class="headerlink" title="pwm底层调频"></a>pwm底层调频</h3><p>步进角1.8度，16细分后一圈是3200步。uno主频16MHz, 预除数1，8，64，256，1024，timer1支持计数器到65535, timer2支持到256, 两者最低pwm频率分别是0.23Hz和61Hz。</p><p>轮子直径5cm, 换算成线速度，timer2支持的最小线速度是0.31cm/s，在不改变scale的时候最大线速度是80cm/s左右，完全支持所有使用情景。</p><p>得出公式：c = (5000 * pi * d) / (p *s); 其中c是比较器上限(0-255)，d是轮子半径，p是preScale大小，s是轮子线速度。d和s的长度单位统一，时间单位是秒。默认16细分。</p><p>如果只计算赫兹数的话，c = 16 * 10^6 / (p * f); 其中f是输出频率。</p><p>为了让速度的离散分布尽量均匀，我们预先对不同速度进行分区。先作出不同预除数的可能</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>这里记一下位运算的结果：</p><pre><code class="hljs plain">   &#x2F;&#x2F; turn on CTC modeTCCR1B |&#x3D; (1 &lt;&lt; WGM12);&#x2F;&#x2F; Set CS10 and CS12 bits for 1024 prescalerTCCR1B |&#x3D; (1 &lt;&lt; CS12) | (1 &lt;&lt; CS10);</code></pre><p><code>a &lt;&lt; b</code> 表示a左移b个bit，假设这里WGM12=3,那么右移运算就是1000，而TCCR1B被初始设定为0，或操作以后就直接把WGM12寄存器的值赋为1。所以这里用麻烦的宏定义的原因就是便于直接读出寄存器的值。相应地多个寄存器的操作用或来连接（因为都是0，所以或操作不会覆盖什么东西）</p><p>至于寄存器的值对应pwm的状态，参考芯片的datasheet，注意这里设置的都是fast pwm模式。</p><img src="/2020/07/26/%E8%87%AA%E5%B9%B3%E8%A1%A1%E5%B0%8F%E8%BD%A6%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/2020-08-01-23-03-51.png" srcset="/img/loading.gif" class=""><p>因为频率和寄存器中阈值的反比关系，线速度的分布是不均匀的。可以实时对预除数进行调整，从而保证在一个相当大角速度范围内近似均匀的pwm输出</p><h1 id="控制算法"><a href="#控制算法" class="headerlink" title="控制算法"></a>控制算法</h1><p>采用的是PID双环控制：速度环和距离环，前者维持小车平衡，后者维持小车位移不变。开发过程中也有一些问题，这里列举出来：</p><h3 id="控制量的符号关系"><a href="#控制量的符号关系" class="headerlink" title="控制量的符号关系"></a>控制量的符号关系</h3><p>假设角度、加速度、电机速度三者的正方向在初始点是一致的，PID输入、输出、目标点关系已知，那么在小车运用中需要额外改变符号：</p><p>假设小车前倾，角度为正，角度输入速度环，得到负的速度输出：这里的负号指PID算法试图让小车角度回正，那么对应电机速度应该是正向，因此需要加一个负号。</p><p>假设小车前倾，角度为正，速度环输出为正（已修正），电机速度为正，但是小车行驶了一段距离，偏离原点，此时距离环接受速度环的输出为正，距离输出为负，对角度影响为负，不需要变号。</p><h3 id="PID参数解析"><a href="#PID参数解析" class="headerlink" title="PID参数解析"></a>PID参数解析</h3><p>速度环确保小车不会倒下（稳定在某个角度），将车轮速度看作“修正力”，而将角度看作“目标”的话，角度受到重力加速度分量影响，也就是存在一个“阻力”，P参数代表原始的修正力，角度越大，修正力越大。I参数代表抗衡重力加速度分量的一个力，在I参数影响下，小车受到的等效重力减小了许多，落入了能被P参数修正的区间内（如果单纯地调大P参数，会使P的作用力累积导致结果发散）。D参数用角速度控制速度，对角度的周期性震荡进行衰减，但数值太大会造成调控力度不够，收敛时间延长。</p><p>距离环其实输入的是距离微分（速度乘以时间间隔），输出是角度。I参数用距离控制倾斜角度，这当然会将系统引向不稳定状态，I较大的时候距离调整更迅速，但是I依赖于速度环的控制能力，而且I太大会引起周期震荡。考虑到采样的间隔还是比较均匀的，P参数可以看作用速度控制倾斜角度，也就是对周期性震荡进行衰减，但是P太大也会引起周期震荡，这个参数的确定与重力加速度有关。D参数用加速度调整角度，也是让运行更加平稳。</p><p>偏移时，距离信息存储在距离环的I参数中，当小车在另一个位置稳定时，I参数可以引导小车回到原地，因此距离环具有调整距离的作用。</p><h3 id="抗干扰"><a href="#抗干扰" class="headerlink" title="抗干扰"></a>抗干扰</h3><p>角度零漂等效于小车放在斜坡上：速度环的I参数对抗恒定阻力，所以没有问题，仿真中去掉I参数后小车确实以恒定速度向前移动了。</p><h1 id="GUI设计"><a href="#GUI设计" class="headerlink" title="GUI设计"></a>GUI设计</h1><h3 id="bug汇总"><a href="#bug汇总" class="headerlink" title="bug汇总"></a>bug汇总</h3><p>这里记录一些开发过程中遇到的bug，都是比较玄学的东西。</p><blockquote><p>__acrt_first_block == header</p></blockquote><p>这是DLL和exe没有共用一个栈导致的，原因是vs项目设置里没有设置动态链接dll模式（MDd），改过去以后就OK。</p><blockquote><p>esp32上传的代码时好时坏</p></blockquote><p>串口使用前要println，上传时要选no IDE，不能用arduino IDE，也是一个非常玄学的问题。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>硬设算是结束了，但是很多技术细节都没有记下来，留待以后慢慢补充。这里先总结一些需要改进的地方（包括技术、展示、软硬件设计等）</p><h3 id="缺乏合适的测试环境，测试周期过长"><a href="#缺乏合适的测试环境，测试周期过长" class="headerlink" title="缺乏合适的测试环境，测试周期过长"></a>缺乏合适的测试环境，测试周期过长</h3><p>测试环境是一个软硬结合的环境。因为自平衡小车的特殊性，测试过程中需要大量的调试。尽管我已经在设计上对小车的软硬件进行解耦，但是后期出现的转向问题、指令过渡问题等都是需要大量测试来debug的，更不用说PID调参。</p><p>理想情况下，应当有一个尽可能快速的测试周期：</p><ol><li>小车的平衡检测可以只做一次，时间可以缩短；</li><li>完善debug输出指令，可以指定输出内容；</li><li>在小车最大电流和输出功率间找到平衡点，尽量降低耗电；</li><li>寻找一个宽敞的测试环境，事先用水平仪测量保证排除地面平整度因素</li><li>前期基础性测试中对各种异常现象汇总，有意设置异常情况（放置角度不水平、任意时刻外加扰动），避免多层次bug互相影响</li><li>仿真协助测试：先给出原理可行性，再进行实际调参</li><li>每个模块都有单元测试和集成测试，不能同时对几个模块进行测试。</li></ol><h3 id="时间分配不合理，功能展示不够灵活"><a href="#时间分配不合理，功能展示不够灵活" class="headerlink" title="时间分配不合理，功能展示不够灵活"></a>时间分配不合理，功能展示不够灵活</h3><p>这主要是针对展示环节提出的，展示时双方分工没有安排好，启动时间比较长，而且触摸模块鲁棒性太差，好几次启动失败。功能展示的时候没有体现出显著性，没有方便的展示样例，导致图像识别部分也没有对应实例，拿不出可信的东西。出bug的时候也没有优先进行接下来的展示，总体来说，前期缺乏磨合训练，临场发挥不够灵活。</p><h3 id="debug没有遵照原则，浪费了大量时间"><a href="#debug没有遵照原则，浪费了大量时间" class="headerlink" title="debug没有遵照原则，浪费了大量时间"></a>debug没有遵照原则，浪费了大量时间</h3><p>debug的时候思考不够冷静，只想用自己推断来快速找到原因，但很多情况都没有思路，反而在浪费时间。</p><p>另外，一些调试手段过于繁杂，缺乏自动化设计，进而在大量测试时不可避免地引入偶然误差，同时分散了人的精力。</p><p>debug的一些经验：</p><ol><li>发现bug的时候先进行复现，进而确定出错的情景范围。</li><li>屏蔽掉若干无关模块，特别是未测试过的模块</li><li>对可复现的bug逐步排查无关变量，从而确定最核心的出错情景</li><li>添加若干调试输出，缩小排查范围</li><li>找到最核心的出错位置，初步确定几个可能性</li><li>先做出简单的改动，检验思路是否正确</li><li>最后锁定一个思路，设置关键性的调试输出，或者进行一些特定操作来复现</li><li>每一次复现时都尽可能保持测试环境的一致性。</li><li>尽量采用自动化设计。</li></ol><h3 id="代码素养不够好"><a href="#代码素养不够好" class="headerlink" title="代码素养不够好"></a>代码素养不够好</h3><p>这是两方面的：一方面指自身应当写出良好的代码，另一方面指不能让极差的代码进入项目中来。至少应当对其进行最起码的修复。</p><p>GUI编写上，这次比较成功地用MVC思想进行前后端分离，但是也出现了后端单个类过于庞大的问题。在写实时位置显示时，没有想清楚具体的控制和显示关系，导致写出来的东西有很多逻辑自相矛盾的地方。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>软硬结合的作品最核心的瓶颈就是调试，如何在有限次调试中尽量确保作品鲁棒性强，这就要求有高自动化的测试步骤、详细的数据记录、尽量可靠的原理性仿真和一些工程上的冗余。通过引入分层设计的思想，能够快速定位bug的发生位置。统一且可靠的代码风格能够避免很多潜在的bug。</p><p>另外，这次硬设的一个经验是：任何自己没想清楚的环节，到最后都会成为问题。从初创到成品的过程本身就是一个不断细化的过程，任何设想最终都落实在代码上，一些小小的意料外因素最后也会成为一个障碍，因此最好在最开始的时候就追问所有的细节：<strong>这个细节该如何实现？是否具有工程可行性？</strong>，以此来督促自己摆脱空想、面对现实。</p>]]></content>
    
    
    <categories>
      
      <category>硬件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>arduino</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【读书笔记】QT5.9C++开发指南</title>
    <link href="/2020/07/25/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91QT5.9C++%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    <url>/2020/07/25/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91QT5.9C++%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="QT学习笔记"><a href="#QT学习笔记" class="headerlink" title="QT学习笔记"></a>QT学习笔记</h1><p><strong>前言</strong></p><p>最近写了Blog自动上传的脚本…对VS CODE的了解也更丰富了, 尽可能地避开图形界面的弊端, 提高工作效率. 这篇文章只记录我在学习QT中遇到的优秀的设计思想, 而并不关心QT框架的语法细节或者是使用经验.</p><h2 id="Signal-Slots-信号与槽"><a href="#Signal-Slots-信号与槽" class="headerlink" title="Signal/Slots 信号与槽"></a>Signal/Slots 信号与槽</h2><p>这可以说是QT第一个也是最重要的一个设计思想, 在MVC框架下, 解决组件的互相通信以及Model和Components之间的互相通信问题. </p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>QT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【读书笔记】精通Cocos2d-x游戏开发(基础卷)：程序设计思想札记</title>
    <link href="/2020/07/24/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E7%B2%BE%E9%80%9ACocos2d-x%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91(%E5%9F%BA%E7%A1%80%E5%8D%B7)%EF%BC%9A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E6%9C%AD%E8%AE%B0/"/>
    <url>/2020/07/24/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E7%B2%BE%E9%80%9ACocos2d-x%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91(%E5%9F%BA%E7%A1%80%E5%8D%B7)%EF%BC%9A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E6%9C%AD%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="【读书笔记】精通Cocos2d-x游戏开发-基础卷-：程序设计思想札记"><a href="#【读书笔记】精通Cocos2d-x游戏开发-基础卷-：程序设计思想札记" class="headerlink" title="【读书笔记】精通Cocos2d-x游戏开发(基础卷)：程序设计思想札记"></a>【读书笔记】精通Cocos2d-x游戏开发(基础卷)：程序设计思想札记</h1><h1 id="程序设计思想札记"><a href="#程序设计思想札记" class="headerlink" title="程序设计思想札记"></a>程序设计思想札记</h1><p>这本书是我从2020-6-16开始学习的，目的大概是为了完成小学期的作业吧，书中有一句话启发了我，大概意思是“编程学习的是思想，而不是记忆代码。”我觉得很有道理，于是打算用这篇札记记录自己学到的程序设计<strong>思想</strong>，尽量用脱离具体实现的方式将优劣势讲清楚，便于以后独立设计一个系统时来参考。但一些总结性的东西会具体写出来。</p><p>这篇笔记可以看作读书笔记，也可以看作大作业的心得总结，当然详细的总结会放在技术文档和开发日志里，这里只是写一些闲言碎语吧。</p><hr><h3 id="可读性和可维护性：C-变量命名规则"><a href="#可读性和可维护性：C-变量命名规则" class="headerlink" title="可读性和可维护性：C++变量命名规则"></a>可读性和可维护性：C++变量命名规则</h3><p>变量命名指南：</p><ul><li>不在变量名中写变量类型：减少重复和低效</li><li>减少容易混淆的词：英语中很多词无法从部分推出整体词义，那么应当用构词法描述一个变量</li><li>尽可能具体，方法命名要一目了然</li><li>用稍长的变量名代替简短变量名+单行注释：减少阅读者的记忆负担</li><li>不要用类似val/value/result/temp/count/str这种无意义变量名</li><li>正确使用惯用语：i,j,k,n,e</li><li>生命周期比较短的变量，命名也相对要短：长命名的潜台词是“这是值得注意的变量，需要被记住”</li><li>合理使用一次性变量：并列式长代码需要拆分，嵌套式短代码需要合并<br>驼峰命名法相比于下划线，占地小，紧凑性更好，有些时候区分类和变量时，类用大写驼峰，变量用小写驼峰。但也有自己的缺点，比如HTTP，ID这种缩写词，而且在查找变量的时候必须加上大小写通配。</li></ul><p>还有一些技巧；</p><ul><li>变量、类用名词，方法和函数用动词</li><li>控件命名保留匈牙利命名法，如button-btn, label-lbl等</li><li>对容易用错的变量（比如指针和对象、全局变量），可以保留匈牙利命名法：</li></ul><ol><li>指针加p：避免-&gt;和.用错</li><li>全局变量加g_, 静态变量加s_：这些都是容易出bug的</li><li>成员变量加m_：避免和外部变量重叠<br>总地来说，变量命名需要考虑阅读效率、阅读无歧义、写作效率、写作无歧义、搜索效率、规避潜在风险、规则的简化等，是需要语言学与心理学还有编程经验三者深度融合后才能进行改进的。这次的工程也会采用这些规则来规范编写。</li></ol><h3 id="引擎与顶层逻辑的交互：回调、封装"><a href="#引擎与顶层逻辑的交互：回调、封装" class="headerlink" title="引擎与顶层逻辑的交互：回调、封装"></a>引擎与顶层逻辑的交互：回调、封装</h3><p>对于一个节点来说，加入节点树后，引擎会自动在某些时刻调用方法：初始化，添加进场景时，删除时。对于一些节点，需要每帧进行检测，那么就需要自定义回调函数，并且向引擎“注册”。有时引擎接受到外部输入时，需要将其反馈给节点，那么节点需要事先指定一个回调函数用于接收。</p><p>将外部输入和渲染看作一极，顶层逻辑看作另一极，那么游戏引擎就是连接两极的纽带，为了进行有效的沟通，诞生了消息传递和update等机制。</p><h3 id="内存泄漏与日志统计"><a href="#内存泄漏与日志统计" class="headerlink" title="内存泄漏与日志统计"></a>内存泄漏与日志统计</h3><p>内存泄漏指的是：在堆中创建对象后，没有在结束前进行回收。这个问题非常隐蔽：</p><blockquote><p>…他在维护这份代码的过程中，向其中添加了一些错误判断，如果发生错误，返回什么…但他在添加代码时，所有的返回语句都忘记把这块内存删掉了</p><p>任何一个系统的维护都是长效性的，内存泄漏也是。一种解决方法就是，将构造函数与析构函数的执行次数输出到日志中，这样程序结束后统计日志，就可以发现潜在问题了。</p></blockquote><h3 id="C-11的lambda表达式"><a href="#C-11的lambda表达式" class="headerlink" title="C++11的lambda表达式"></a>C++11的lambda表达式</h3><p>当我们需要在函数内部临时建立一个函数处理一些灵活的工作时，可以构建一个lambda函数：</p><blockquote><p>std::function&lt;return type()&gt; func1 = [capture list] (params list) mutable exception-&gt; return type { function body }</p></blockquote><p>lambda函数func1像变量一样被创建出来，被储存为std::function类型。capture list规定了func1能够利用的外部变量（范围是func1被创建时所能操作的变量），然后params list规定了调用func1时额外传入的参数，mutable修饰符表示函数可以改变捕获的变量（临时改变供自己使用？），exception抛出异常（允许函数体内部用throw()抛出异常）</p><p>但是需要注意，lambda的capture list中的变量是在<strong>创建时就定下来的</strong>，如果是引用捕获&amp;，捕获的是一个引用，func1创建后的修改会有影响，而如果是值捕获=，就只有当时的值，此时对捕获变量的修改都是没有意义的。</p><h3 id="template与可变参数模版"><a href="#template与可变参数模版" class="headerlink" title="template与可变参数模版"></a>template与可变参数模版</h3><p>这篇文章介绍了模版的应用：<a href="https://blog.csdn.net/lianhunqianr1/article/details/79966911" target="_blank" rel="noopener">https://blog.csdn.net/lianhunqianr1/article/details/79966911</a></p><blockquote><p>C++标准委员会采用一套类似函数式语言的语法来设计C++模板，而且设计成图灵完备 (Turing-complete)（详见参考），我们可以把C++模板看成是一种新的语言，而且可以看成是函数式编程语言，只是设计依附在(借助于）C++其他基础语法上（类和函数）。</p></blockquote><p>模版有其复杂的使用方法，但是这里只记录它的思想。首先是“简化”思想，运用模版编程后，不需要对每个类型单独设计一套规则，这就将相似的东西合并起来，大大简化了代码量。第二点是“灵活”，有时候程序员不知道也不需要知道一个类的确切形象，只要知道可供操作的一部分就行了，这时候只有用模版才能开发出具有普适功能的算法和容器。第三点是“动态生成代码”，模版的工作是在编译期和运行期进行的，一些典型场景中（比如用if进行类型判断），一部分花销可以从运行期迁移到编译期，这样就减小了运行开销。</p><p>模版是泛型的基础，泛型中一个思想就是<strong>“Substitution failure is not an error”</strong>，意思是对类型的适配有多次尝试，编译器会自动推导可行的方案（比如对不同参数的函数调用，自行适配合适的参数），然而一次尝试的失败并不是程序错误，只有所有尝试失败才是错误。也就是说，编写者需要设计出任何情况下至少有一种方案能够被执行的代码。自然，智能化的代码需要更加更加智能化的编写者。</p><p>可变参数模版的关键在于参数调用，这里的思想是<strong>匹配调用</strong>或者<strong>递归调用</strong>，后者是前者的延伸。匹配调用也就是：既然不知道参数长度，那么就准备多个函数，逐一匹配合适的函数即可。而递归调用将承接可变长参数的函数func1与解析的函数func2合二为一，将参数列表设为前n个固定参数与最后的可变参数，然后递归调用自身，这样就逐一解出所有参数，但是注意取值为n时，需要准备n-1个函数用来处理递归最后的“余数”，这一点是模版元编程需要考虑“全体情况”的表现。</p><h3 id="变量的四个属性：数值、类型、const、右值（C-11）"><a href="#变量的四个属性：数值、类型、const、右值（C-11）" class="headerlink" title="变量的四个属性：数值、类型、const、右值（C++11）"></a>变量的四个属性：数值、类型、const、右值（C++11）</h3><blockquote><p>通过是否可取地址操作符，以及是否有名字，可以判断是否为右值。右值是指表达式结束后就不存在的临时对象。</p></blockquote><p>在模版变成时，当然需要处理右值的函数，然而在模版的嵌套、转发中，右值可能变成左值（也就是本来赋值完就销毁的变量却拥有了自己的地址和名字）。这时用C++11提供的引用<code>T&amp;&amp;</code>就可以同时保留变量的四个属性，做到“完美转发”</p><h3 id="虚函数与多态特性"><a href="#虚函数与多态特性" class="headerlink" title="虚函数与多态特性"></a>虚函数与多态特性</h3><p>这里参考这篇文章：<a href="https://blog.csdn.net/hackbuteer1/article/details/7558868" target="_blank" rel="noopener">虚函数与纯虚函数的区别</a></p><p>虚函数蕴含的思想是<strong>多态</strong>，整个代码的执行情况对于编译器来说并不是单一的（虽然从结果上，它只能是唯一的，但编译器不需要知道整个情况）。因此，虚函数调用不取决于类型，而取决于实际初始化的类型，就如下面的代码：</p><pre><code class="hljs plain">int main(void)&#123;    A *a &#x3D; new B();    a-&gt;foo();   &#x2F;&#x2F; 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!    return 0;&#125;</code></pre><p>但是，基类定义了虚函数，子类才能继承并重载，这时候我们依然可以用基类生成一个对象，而这样的对象是不合理的：基类本该是抽象的东西，却可以被实例化。因此，纯虚函数<code>virtual void funtion1()=0</code>，规定了其必须被重写，而且这样的基类不可以被继承。</p><p>可以看出，虚函数和纯虚函数的引入是将现实中的抽象和具象关系体现在代码上，让代码更加安全，同时把“抽象”作为内嵌在语言的特性推广为所有开发者的共识，降低代码理解难度。</p><h3 id="节点继承与回调方法：Cocos2dx引擎与顶层的交互接口"><a href="#节点继承与回调方法：Cocos2dx引擎与顶层的交互接口" class="headerlink" title="节点继承与回调方法：Cocos2dx引擎与顶层的交互接口"></a>节点继承与回调方法：Cocos2dx引擎与顶层的交互接口</h3><p>在处理游戏内容的可拓展性上，cocos2d采用的思想是<strong>继承和回调</strong>，通过对节点类Node的继承，实现游戏内容的多样性和统一性。而事先规定好特定的回调函数，在约定的时刻由引擎调用，就实现了游戏逻辑的可拓展性。</p><p>回调函数：</p><ul><li>init初始化节点时调用</li><li>onEnter被添加进场景中调用（这里是二次初始化）</li><li>onExit节点从场景删除</li><li>update与时间相关，比如每一帧的逻辑、定时逻辑<br>可以认为继承是引擎为内容维度提供的接口，回调是引擎为逻辑维度提供的接口，游戏顶层设计在这两个维度上与引擎进行交互。</li></ul><h3 id="内存池设计"><a href="#内存池设计" class="headerlink" title="内存池设计"></a>内存池设计</h3><p>内存池的思想是将大大小小的内存申请需求统一，以此来<strong>用额外的内存空间为代价换取低频的内存扩展请求</strong>。这是由于技术的发展，使得内存不再需要节约使用，而更需要低频使用。</p><p>内存池的基本功能：</p><ul><li>接管原本代码中的new和delete/free功能，先申请一大块内存空间，再自行决定分配。同时释放的时候也可以暂时不delete，减少频率</li><li>内存池本身申请内存时，做到连续，低频，且尽量占用少（这三者其实是互相矛盾的）</li><li>内存空闲太多时，需要释放一部分内存。<br>PS：这一部分就实现了自主选题中的内存管理需求</li></ul><h3 id="cocos2d-x运行机制解释"><a href="#cocos2d-x运行机制解释" class="headerlink" title="cocos2d-x运行机制解释"></a>cocos2d-x运行机制解释</h3><p><strong>与windows系统关联的启动机制</strong></p><ol><li><code>_tWinMain</code> 作为入口，初始化实例AppDelegate</li><li>调用Application::getInstance()-&gt;run(); 回调applicationDidFinishLaunching，完成制作者自定的初始化</li><li>windows下的OpenGL进行底层交互处理（键盘，窗口最小化等），GLFW直接与Director等进行信息传递</li></ol><p><strong>引擎内部的运行机制</strong></p><ol><li><p>全局初始化：AppDelegate中的applicationDidFinishLaunching，可添加开发者自己的初始化代码</p></li><li><p>进入DisplayLinkDirector的mainloop（），其中的drawScene()对每一帧进行场景渲染和逻辑执行：</p></li><li><p>执行schedule的update进行逻辑更新：schedule作为调度器驱动action更新，并且执行每一帧的游戏逻辑和关于时间的逻辑</p></li><li><p>Director直接控制游戏的暂停、恢复、结束、场景切换（但判断逻辑并不在这里）</p></li><li><p>场景渲染</p><h3 id="消息、逻辑、调度交互"><a href="#消息、逻辑、调度交互" class="headerlink" title="消息、逻辑、调度交互"></a>消息、逻辑、调度交互</h3></li></ol><p><strong>消息的观察者模式：包括注册、触发、处理、注销四个步骤</strong></p><hr><p>这里首先介绍一些C++11的bind机制：</p><pre><code class="hljs plain">void TestFunc(int a, char c, float f);auto bindFunc1 &#x3D; bind(TestFunc, std::placeholders::_1, &#39;A&#39;, 100.1);bindFunc1(10);</code></pre><p>bindFunc1将一个3个参数的函数变成1个参数，2个“定量”的函数，bind第一个参数对应目标函数，后面的placeholder就对应使用时需要传入的东西。需要注意的是，预先设定的参数都是按值传递的。</p><hr><p>这里来总结观察者模式：</p><p><code>auto listener = EventListenerKeyboard::create();</code>：创建监听器，申请得到一个实例</p><p><code>listener-&gt;onKeyPressed = CC_CALLBACK_2(HelloWorld::fighterMoveCallback, this);</code>：指定监听器的哪个事件会触发哪个实例的哪个成员函数，本质上是对listener的成员指针指定要一个bind()，这里的this指当前场景的实例</p><p><code>_eventDispatcher-&gt;addEventListenerWithSceneGraphPriority(listener, this);</code>：向Director注册（_eventDispatcher其实是封装了向Director相关函数），监听器本身是绑定在节点（这里是Scene）上的，而监听器本身也拥有一个指向回调函数的指针。</p><p>触发由引擎和底层负责，这里只需要实现HelloWorld::fighterMoveCallback方法即可。</p><p><strong>调度器：Schedule</strong></p><p>Scheduler是一个全局调度器，可以从Director中获取指向它的指针，调度的本质就是<strong>在规定的时间由引擎调用某个实例的成员函数</strong>，所以需要3个元素：指向调度器的指针，指向实例的指针，实例的成员函数。</p><p>一般来说，调度器的指针是很容易获得的，实例的指针用this即可实现，所以调度一般定义在该实例对应的类中。</p><p>回调按类型分为update回调（每一帧执行的回调），对象回调和函数回调，脚本回调，执行回调。对象回调其实也是调用函数，只不过这个函数是事先约定的形式：</p><p><code>typedef void (CCObject::*SEL_SCHEDULE)(float)</code>：这里规定了一种类型叫SEL_SCHEDULE，它被定义成一个指针，指向一个CCObject类或派生类的成员函数，而这个成员函数的参数必须是float，返回类型必须是void。</p><p>调度器注册时机：</p><ul><li>Node回调函数中，如onEnter或onExit，会在下一帧开始计时</li><li>单击回调，会在当前帧立刻计时</li><li>计时回调内嵌套回调：难以控制时间<h3 id="cocos2d-x顶层逻辑设计"><a href="#cocos2d-x顶层逻辑设计" class="headerlink" title="cocos2d-x顶层逻辑设计"></a>cocos2d-x顶层逻辑设计</h3></li></ul><p>今天终于是把书差不多啃完了……以现在的预期来看，UI界面只能靠手画，同时分辨率固定，这些暂时没法解决。其他的主要在顶层规划，这也是相当考验能力的环节。</p><p>从内容上来看的话，我将游戏设计拆分成以scene为主的“内容切片”</p><ul><li>scene内加载要考虑耦合度，可能会复用的加载模式不可以在单个scene做</li><li>游戏UI独立于画面，设置继承Node的UINode，游戏UI不写在场景加载里，以便重复调用</li><li>各scene间进行解耦，每个继承的scene间的数据传输用约定的方法进行通信，尽量将数据传输大的scene进行整合</li><li>游戏逻辑去中心化，但是约定用tag进行全局的自由通信，游戏与固定的非组件部分存储指针通信</li><li>对于动态产生的节点，不存储指针，每次访问时调用方法获取实时数据。</li><li>对于复杂的逻辑控制，抽象出一个逻辑节点来做。<h3 id="debug-类之间的互相包含"><a href="#debug-类之间的互相包含" class="headerlink" title="debug:类之间的互相包含"></a>debug:类之间的互相包含</h3></li></ul><p>今天debug的时候遇到了这个问题，两个类的定义互相包含，这时候要用前置申明，而且不能写继承关系。</p><h3 id="关卡设计中的序列模式与难度设置"><a href="#关卡设计中的序列模式与难度设置" class="headerlink" title="关卡设计中的序列模式与难度设置"></a>关卡设计中的序列模式与难度设置</h3><p>首先要解决两个问题：在阶段BOSS和最终BOSS被击落前不能开启下一个阶段；每个阶段是一条时间轴，这里我想设计成既可以从外部读取又可以自动生成的机制。</p><p>一般来说玩游戏是为了有爽快感，随着玩家自身操作水平和装备的提升，固定的游戏难度难以让玩家得到充分的满足。因此，游戏难度应该参考玩家飞机的DPS（这决定了是否能理论上通关）、玩家历史战绩（这体现了玩家的水平）、时间难度（这让游戏更加丰富，也带有一些随机性）、关卡难度系数（让游戏从前到后难度有变化）。</p><h3 id="碰撞判定机制的设计"><a href="#碰撞判定机制的设计" class="headerlink" title="碰撞判定机制的设计"></a>碰撞判定机制的设计</h3><p>碰撞判定也是这个游戏的一大难点：全像素化碰撞太耗性能，直接用boundingBox碰撞又不能避免透明像素的干扰。那么在解决碰撞问题时，我的方案是用一个根据booundingbox自动伸缩的“细长”区域判定。</p><p>2D游戏有设计的优势：绝大多数情况子弹都要穿过敌机的横截面，而穿过纵截面的情况极少发生，这是因为敌机的速度一般都垂直于横截面方向。所以这样就极大方便了碰撞判定。同时对于不同类型的问题，我搭建了scene到各元素的双向通信机制，理论上这个机制可以用动态类型转换+Node-&gt;name进行区分，但这种操作有运行风险不说，性能消耗也比较大。我采用的方式是scene持有多个vector，各节点在加载时分别向scene注册自身的指针到指定vector中，各节点退出时也向scene注册销毁自身的指针，然后每一帧调用scene的碰撞判定，分组进行判定，减小内存消耗。</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏开发</tag>
      
      <tag>读书笔记</tag>
      
      <tag>cocos2d</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【读书笔记】Pragmatic_Programmer_札记</title>
    <link href="/2020/07/24/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Pragmatic_Programmer_%E6%9C%AD%E8%AE%B0/"/>
    <url>/2020/07/24/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Pragmatic_Programmer_%E6%9C%AD%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="【读书笔记】Pragmatic-Programmer-札记"><a href="#【读书笔记】Pragmatic-Programmer-札记" class="headerlink" title="【读书笔记】Pragmatic Programmer 札记"></a>【读书笔记】Pragmatic Programmer 札记</h1><h3 id="前言和概要"><a href="#前言和概要" class="headerlink" title="前言和概要"></a>前言和概要</h3><p>这本书是在七月份读的, 有差不多300页, 考虑到英文书算是比较容易理解, 应该一两周能读完.(PS: 实际从10号读到16号)</p><p>重点处会用黑体标注. 主要还是根据书中一些精华的句子写感想.</p><blockquote><p>Your background stems from an understanding of the basic principles of computer science, and your experience comes from a wide range of practical projects.</p></blockquote><p>这是一个关于学习编程知识的建议, 有最基础的计算机知识, 然后在不同领域积累许多经验. 所以语言没什么限制, 思想才是有价值的东西.</p><blockquote><p>There are other factors that can contribute to software rot, and we’ll touch on some of them elsewhere, but neglect accelerates the rot faster than any other factor.</p></blockquote><p>软件工程中的”熵增理论”或”破窗理论”, 书中建议将<strong>及时重构, 修复那些不好的设计</strong>放在第一位, 如果实在没有时间, 也要将其标注起来, 构建以一个围栏, 阻止一块不好的代码继续扩散. 这个建议是基于软件开发中的混乱度提出的, 软件在开发过程中, 总是不可避免地走向混乱, <strong>软件开发的过程也就是与混乱抗争的过程</strong>, 那么尽量保护自己的代码, 让它们简洁高效, 是延续抗争意志的很好的手段.</p><blockquote><p>If you find yourself working on a project with quite a few broken windows, it’s all too easy to slip into the mindset of “All the rest of this code is crap, I’ll just follow suit.”</p></blockquote><p>这个是破窗理论的延伸, <strong>一块不好的代码不仅会让开发者更易于添加糟糕的代码, 还会让开发者认为其他代码也是不好的.</strong>, 我注意到的是这种情形<strong>不仅适用于代码, 还适用于开发计划/开发文档等</strong>, 第一天进行开发的时候应当设计一个简洁的框架, 然后每隔一段时间适量地作出计划, 保证整体的准确性和指导功能. 计划不能太过详细, 不然后续修改需求时就会被看作一块”破窗”, 计划也不能太抽象或者没有, 不然过几天去看当时写的代码的时候就会觉得是写出来的东西难以阅读, 也找不到定位. 总之好的设计一定是精简又可扩展的, 使得每一天都能及时踏在开发的进度上, 而不至于迷失方向或疲于修改计划.</p><blockquote><p>Once you’ve got it, show people, and let them marvel. Then say “of course, it would be better if we added….”</p><p>People find it easier to join an ongoing success.</p></blockquote><p>不仅是对团队而言, 对独立开发者也是这样. <strong>让一个项目时时刻刻处于即将成功的状态, 会让它更加有吸引力</strong>, 最初的开发要做的是写出一个最精简的可行的框架, 给人眼前一亮的感觉, 然后依照这个最初的创意不断的添加功能. 对独立开发者来说, 也就是时时刻刻让项目富有吸引力, 从而让自己能坚持开发下去.</p><blockquote><p>If you give your users something to play with early, their feedback will often lead you to a better eventual solution</p></blockquote><p>这也是迭代开发的好处, 能够迅速地将开发工作转换成可见的成果</p><h3 id="Duplication-重复"><a href="#Duplication-重复" class="headerlink" title="Duplication 重复"></a>Duplication 重复</h3><blockquote><p>The alternative is to have the same thing expressed in two or more places. If you change one, you have to remember to change the others, or, like the alien computers, your program will be brought to its knees by a contradiction. It isn’t a question of whether you’ll remember:<strong>it’s a question of when you’ll forget</strong>.</p><p>The DRY principle tells us to keep the <strong>low-level</strong> knowledge in the code, where it belongs, and reserve the comments for other, <strong>high-level</strong> explanations. Otherwise, we’re duplicating knowledge, and every change means changing both the code and the comments.</p></blockquote><p>这是第一个重要的概念: <strong>在任何地方都尽量不要出现重复的知识</strong></p><p>我在过去的经验里也有这种现象: 在许多地方写上一些相似的代码, 但是修改的时候又忘记修改其他地方的东西, 或者修改了代码却没有修改注释. 现在来看看文章中给的解决方法:</p><ol><li><p>用code generator在每一次更改的时候同步代码. 这也可以使用于代码和文档之间(doxygen), 其核心理念就是<strong>在更改时同步</strong>. 用到的技术有metadata/preprocessor等</p><blockquote><p>To ensure that the tests accurately reflected the specification, the team generated them programmatically from the document itself.</p></blockquote></li><li><p>在注释中用<strong>更高级的逻辑概括代码的内容</strong>, 通常是代码的目的或作用, 这样在更改代码的时候也就不会需要同时修改注释了</p></li><li><p>为了避免头文件和实现中的注释重复, 在头文件中存放<strong>与接口相关的信息</strong>, 而在实现中写一些<strong>被封装起来的但是很重要的细节</strong></p><blockquote><p>Use the header files to document interface issues, and the implementation files to document the nitty-gritty details that users of your code don’t need to know.</p></blockquote></li><li><p>避免违背事实的抽象关系和重复的抽象关系.</p></li></ol><p>这一点书中给了一个实例: 一个运送路线包含卡车, 司机, 和路线, 而卡车中又包含号码牌, 司机和卡车类型. 而当司机生病需要替换时, 问题就来了: 有两个重复的司机. 另外, 卡车其实并不包含司机, 如果一定要包含的话, 那么这个卡车是正在运送货物的卡车. 而不是普通意义的卡车. <strong>在设计抽象的时候时常会出现重复或是违背事实的抽象关系, 从而让实际设计的类不是我们想要的类</strong>, 解决这个问题, 当然是尽量避免重复, 我想到的, 在设计时应该这样询问自己:</p><ul><li>我是否能从这个类中的某几个类成员直接得到另一个类成员? (避免相互包含的重复)</li><li>在这个类需要应用的情况中, 这个类是否都包含它的成员属性?是否有没考虑到的成员属性? (避免违反事实的包含关系)</li><li>在这个类需要应用的情况中, 类成员的是否满足所需的性质? 如可修改性, 唯一性, 可比较性(浮点数带来的精度问题), )可独立存在性(指针指向的独立内存空间)</li><li>在这个类需要应用的情况中, 类成员是否具有不能具备的性质? 如可访问性(public的滥用), 可修改性(const), 过大的取值范围(约束限制)等</li></ul><ol><li>尽量用访问函数获取类的属性<blockquote><p>Where possible, always use accessor functions to read and write the attributes of objects</p><p>有两个例子, 一个是文中给的: 一个line类有两个成员start和end, 当需要获取长度时, 为了不违背重复性的规则, 要用两个点计算这一长度, 但是这一计算通常是昂贵的, 于是设置一个distance, 在获取长度时, 先看起点和终点是否修改过了, 如果修改了就更新distance, 再传出.</p></blockquote></li></ol><p>另一个例子是getInstance()的作用, 用来得到静态指针指向的实例, 也是唯一的实例. 这两个例子都说明<strong>用访问函数存取属性可以做更多逻辑上的封装, 让类的设计更加合理</strong></p><ol><li>设计良好的可重复利用的生态环境<blockquote><p>What you’re trying to do is foster an environment where it’s easier to find and reuse existing stuff than to write it yourself.</p></blockquote></li></ol><p>这其实有分成两点: 对个人而言和对软件/语言生态而言.</p><p><strong>对个人而言, 尽量提高代码的可重复利用性</strong>, 这不仅是提高效率, 也是集中修改. 例如用一个utils类统一管理各种需要用到的静态方法, 或者用宏定义将多个数值定义统一.</p><p><strong>对生态环境而言, 简化调包方法, 降低调包风险.</strong></p><p>这是我结合语言更新来思考的, C++的调包并没有像python那么方便, 往往是直接copy别人的代码, 还要手动搜索接口说明. 复杂的复用方法让整个软件生态面临重复性的风险, 这直接带来<strong>性能不确定的第三方库</strong>, 然后导致开发者趋向于自己造轮子, 又带来了<strong>开发的复杂度上升和沟通成本的增加</strong>, 论坛的活跃度降低, 对新手而言也很不友好. 这些都会导致整个语言生态环境的没落.</p><h3 id="Orthogonality-正交性-解耦合"><a href="#Orthogonality-正交性-解耦合" class="headerlink" title="Orthogonality 正交性/解耦合"></a>Orthogonality 正交性/解耦合</h3><blockquote><p>You get two major benefits if you write orthogonal systems: increased productivity and reduced risk.</p></blockquote><p>正交性也就是解耦合, 书中总结了一些好处, 这里列出比较有新意的点:</p><ol><li>将问题局限化: 一个结构出问题以后整个错误只会在这个结构内, 这样就可以减少思考范围, 提高debug速度</li><li>避免对第三方库的依赖: 与第三方库解耦后, 只要接口合适, 可以任意更换成另一个库, 减少依赖性.<blockquote><p>Every change needs a meeting of the entire team, because any one of them might be affected</p></blockquote></li></ol><p>这是一个很有趣的点, <strong>对一个团队的解耦可以减小沟通成本</strong>, 也就是管理的时候, 将整个程序拆解成细分的几个子部件, 然后指名各个小团队制作, 这样确保每个级别只有较少的人参与研发, 沟通也富有效率, 然后部件与部件之间正交化, 一个团队的延误不影响其他团队的工作.</p><p>满足正交性以后, <strong>用模块化和层次化的思想构建一个系统</strong></p><img src="/2020/07/24/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Pragmatic_Programmer_%E6%9C%AD%E8%AE%B0/056f9a574fe47828a21074cf7e239d0d.png" srcset="/img/loading.gif" class=""><p>如图, 交互界面内部是模块化的, 而交互界面和数据库之间是层次化的. 层次化的东西下部只需向上提供接口, 同时模块化的东西, 各模块直接也只需提供接口. 这就保证了整个系统是可靠高效的.</p><blockquote><p><strong>Don’t rely on the properties of things you can’t control.</strong></p></blockquote><p>这一句话的例子是: 不要用电话号码去分辨每一个客户. 同样, 也不能用地区/姓名等区分每一个客户, 虽然在客户数量少的情况下这样做很有效. 但是最本质的是区分<strong>一个抽象的类和从属于类的成员的区别</strong>, 前者的独立性不可由后者的独立性保障, 也比如说, 一个对象的同一性判断不可以用内存中的位置来决定, 这是因为这个位置是对象的一个属性, 虽然这个位置对于一个对象是唯一的, 但很多情况下, 开发者所要的唯一性是脱离于对象生命周期的, 那么在这种时候就应该用别的方法去识别唯一性.</p><blockquote><p>If an object persistence scheme is transparent, then it’s orthogonal. If it requires you to create or access objects in a special way, then it’s not. Keeping such details isolated from your code has the added benefit of making it easier to change vendors in the future.</p></blockquote><p><strong>引入第三方库通常是增强耦合度的</strong>, 例如stl库, 从database到GUI都要调用其中的方法, 那么一旦修改其中的某个定义, 就一定会波及多个层. 在此基础上, 要么对引入的库谨慎判断, 要么自己封装一层接口, 不直接在代码中使用第三方库, 而是集中在接口使用.</p><p>对第三方库的可替代性也有判断标准, 就如这句话所说的, 如果第三方库的使用比较奇特, 那么就尽量不要引入. 最好的第三方库是transparent的</p><blockquote><p>With AOP, you implement logging orthogonally to the things being logged. Using the Java version of AOP, you could write a log message when entering any method of class Fred by coding the aspect:</p></blockquote><p>这下面是一个例子, 意思是说AOP让log不是由每个方法独自发出的, 而是在每个方法被调用时统一发出的, 这就避免了重复调用log, 而且AOP在你编写的时候就自然而然地适用, 不需要去对源代码进行任何改动.</p><p>以后在开发的时候, 可以用一个基类实现这些功能,</p><blockquote><p>In fact, we suggest that every module have its own unit test built into its code, and that these tests be performed automatically as part of the regular build process</p></blockquote><p>这是一个关于<strong>自动化测试</strong>的建议, 也就是每个组件自身有内部的测试, 组件自身包括功能和测试两部分, 一方面可以很方便地进行调用, 另一方面减小耦合度, 节省了编译的时间.</p><blockquote><p>With truly orthogonal documentation, you should be able to change the appearance dramatically without changing the content. Modern word processors provide style sheets and macros that help</p></blockquote><p><strong>文档的解耦</strong>, 也就是自动编写目录, 将格式与内容分离, 以及格式的统一控制等等.</p><h3 id="Reversibility-可逆性"><a href="#Reversibility-可逆性" class="headerlink" title="Reversibility 可逆性"></a>Reversibility 可逆性</h3><blockquote><p>If you keep decisions soft and pliable, it won’t be hard at all. If you have poor encapsulation, high coupling, and hard-coded logic or parameters in the code, it might be impossible.</p></blockquote><p>可逆性指<strong>面对未来需求的不确定性时, 如何编写出易于改动的软件系统</strong>, 书中提到的观点有两个:</p><ol><li>系统上, 为可能的改动预留空间</li><li>利用接口, 将第三方库封装在接口里面<br>注重系统的可逆性当然是有必要的, 可我觉得这里只提了这个趋势但是没有提到如何权衡: 假设第三方库要更换, 那么就要封装一层接口; 假设系统要更换, 就要设计可更改的模式. 可逆性越大的软件也越臃肿, 这样毫无疑问会降低开发效率. 那如何保持简洁又兼顾可逆性? 这里思考的应当不是哪些需求可能会改动, 而是哪些需求不会改动.</li></ol><p><strong>在确定的需求基础上, 编写出最独立,最小化的软件</strong></p><p>所以在刚开始的时候, 应当尽量确定一些不会改变的东西, 比如软件的功能, 软件使用的平台, 是否依赖网络, 软件的最大性能需求等等. 确定以后再思考可能会改动的部分, 比如软件的GUI界面, 软件的额外功能等. 在编写的时候应当尽量不包含会改动的部分, 比如尽量不引入第三方库(除非确定这个库拥有满足需求的性能), 对长期维护的项目, 要考虑第三方库的维护状态. 也要考虑代码的易读性.</p><h3 id="Tracer-Bullets-技术验证与原型构建"><a href="#Tracer-Bullets-技术验证与原型构建" class="headerlink" title="Tracer Bullets: 技术验证与原型构建"></a>Tracer Bullets: 技术验证与原型构建</h3><p>书中的tracer bullets来源于曳光弹的形象比喻, 它是一个用来验证技术是否可行的原型机, 并且这个原型机成为后续大规模开发的骨架, 其他功能陆续被添加到这个原型机上, 逐步改装, 最终完成.</p><p>与tracer bullets对应的conventional alternative是一次性集成, 或者是单向地设计-实现-集成这个模式. 单向化有两个弊端, 第一是<strong>在测试前无法得知技术的有效性, 风险大</strong>, 这也是我之前碰见的一个问题. 我在设计动态星球生成器的时候, 没有考虑到放大后的模糊效果和性能损耗, 最终开发出的东西无法运用在实际场景中. 另外一个弊端是<strong>模块化开发, 一次性集成的方法缺少实时激励, 无论是对开发者还是用户</strong>. 激励在软件开发中很有必要, 越复杂的系统越需要心理上拉出”战线”.</p><blockquote><p>A small body of code has low inertia—it is easy and quick to change.</p></blockquote><p>这是tracer bullets的另一个好处: <strong>技术验证的代码体量小, 易于修改</strong>.</p><blockquote><p>Prototyping generates disposable code. Tracer code is lean but complete, and forms part of the skeleton of the final system.</p></blockquote><p>这里强调了Tracer bullets和prototype的区别, 前者是一个<strong>完整的骨架加上小部分的实现</strong>, 后者是一个不完整的骨架加上完全的实现, tracer bullets是可以保留到最后的, 而且这个骨架就是实际应用的东西, 而不是一个供参考的原型机. 这样能确保tracer bullets工作在实际的情况中, 而且避免了最开始的重构工作.</p><blockquote><p>What sorts of things might you choose to investigate with a prototype? Anything that carries risk. Anything that hasn’t been tried before, or that is absolutely critical to the final system. Anything unproven, experimental, or doubtful. Anything you aren’t comfortable with.</p></blockquote><p>这里需要注意的是<strong>每一次尝试新事物的时候都最好做原型验证</strong>, 这样能有效避免风险. 在开发的时候无论时间是否充裕, 都应该采用最有效的开发方式, 在这种开发中技术失败的风险也会被考虑进去.</p><blockquote><p>It’s easy to become misled by the apparent completeness of a demonstrated prototype, and project sponsors or management may insist on deploying the prototype (or its progeny) if you don’t set the right expectations.</p></blockquote><p>prototype注意的是<strong>验证某个技术是否可行, 只需要一部分代码是正确的</strong>, 而tracer bullets不同, 它需要<strong>写出能完整运行的最小的正确代码, 不需要完整, 但是需要正确和能运行</strong>, 这就导致prototype必然被推翻重来.</p><blockquote><p>By coding at a higher level of abstraction, you are free to concentrate on solving domain problems, and can ignore petty implementation details.</p></blockquote><p>这是说<strong>在最初的时候不要考虑语言的具体细节, 只需要用一种伪代码描述出业务逻辑即可</strong>, 确实在思考问题的时候我默认都会从语言的角度思考可行性, 但是这是不对的, 因为理清业务逻辑不需要理清语言细节, 一个逻辑可以有很多实现, 而我在构建框架的时候并不需要去寻找最合适的实现, 甚至不需要关注是否能实现, 这些东西都是在实现的过程中考虑的.</p><blockquote><p>But with a mini-launguage, you would instead be able to issue an error message using the vocabulary of the domain.</p></blockquote><p>这也是站在业务逻辑思考的好处, 一些错误提示是基于语言或计算机系统本身的, 但这种提示是脱离<strong>业务语言</strong>的, 在业务语言中, 仅有业务本身的选择, 而将所有语法错误和执行错误都重新阐释为业务逻辑的错误.</p><blockquote><p>Given that most applications exceed their expected lifetimes, you’re probably better off biting the bullet and adopting the more complex and readable language up front</p></blockquote><p>软件是无生命的, 但是在使用的时候依然要考虑它的<strong>生命周期</strong>, 我的思考是, 在代码能够被理解的时候, 它是有活力的, 而当没有人能理解一段代码的时候, 代码就失去了活力, 而失去活力的代码会失去其价值.</p><p>开发和管理存在一个平衡: 富有活力的代码通常难以创造, 而管理没有活力的代码也非常困难. 所以这取决于这段代码的生命周期有多长: 生命周期为一天或几天的代码, 不需要开发文档, 只需要内部的注释. 而生命周期为半个月到一个月的代码, 需要开发文档, 但不需要对第三方库的维护. 而生命周期为一年到几年的代码, 则需要编写完善的开发文档, 并且尽量对第三方库封装接口, 从而让第三方库可以根据维护性更换.</p><p>生命周期应该看作代码本身的一个属性.</p><blockquote><p>We find that often the only way to determine the timetable for a project is by gaining experience on that same project.</p></blockquote><p>依据最开始的决定对整个项目的时间作规定是很不可靠的, 预估一个程序的开发时间最好的方法就是直接取开发这个程序. <strong>在开发过程中逐步确定剩余的时间, 并依照这个时间作决策</strong></p><p>也就是说, 整个开发计划是随着开发进程而变化的.</p><h3 id="ToolBox拥有自己的工具箱"><a href="#ToolBox拥有自己的工具箱" class="headerlink" title="ToolBox拥有自己的工具箱"></a>ToolBox拥有自己的工具箱</h3><blockquote><p>Many new programmers make the mistake of adopting a single power tool, such as a particular integrated development environment (IDE), and never leave its cozy interface.</p></blockquote><p><strong>每一种工具都有自身的优缺点, 没有哪个是完美的</strong>, 这也说明开发者应当掌握不同的工具来处理不同的情况, 用自身的经验加上合理调度来达成最优效率.</p><p>当然, 在一个开发进程中使用过多的工具也代表着很难被别人理解.</p><blockquote><p>As Pragmatic Programmers, our base material isn’t wood or iron, it’s knowledge.</p></blockquote><p>这一句话只是单纯看着很有哲学意味…</p><p><strong>Plain text</strong></p><p>可以翻译作”朴素的文本形式”, 书中对平面文本比较推崇, 它的优点是可以被人理解, <strong>对于一些在使用时需要被理解的东西, 通常以文本的形式保存</strong></p><p>但也有缺点, plain text占空间大, 同时在读取和写入的时候比较昂贵. 一些其他的缺点其实并不是plain text的锅, 例如易读性. 二进制的东西读取并不困难, 同时plain text也可以通过加密形式存储.</p><p><strong>Using Unix Tools Under Windows</strong></p><blockquote><p>But if you do all your work using GUIs, you are missing out on the full capabilities of your environment. You won’t be able to automate common tasks, or use the full power of the tools available to you. And you won’t be able to combine your tools to create customized macro tools.</p></blockquote><p>确实GUI在自动化处理上有些问题, 但是我觉得并不需要强行在GUI和命令行之间作划分, 有时候<strong>简单的操作由GUI完成, 自动化的东西交给命令行</strong>, 这样应该能保持效率的最大化?</p><p><strong>Use a single editor well</strong></p><p>最好选择一个编辑器来熟悉, 然后充分利用它的快捷键提高效率.</p><p>好的编辑器有以下特征:</p><ol><li>可配置, 可以自行配置让编辑器符合自己的喜好</li><li>可拓展, 可以添加新的内容</li><li>可编程, 可以自己设计复杂的组合操作</li></ol><p><strong>Always Use Source Code Control</strong></p><blockquote><p>There is a tremendous hidden benefit in having an entire project under the umbrella of a source code control system: you can have product builds that are automatic and repeatable.</p></blockquote><p>书中的观点是: 源代码管理不仅可以适用于代码, 更适用于任何自己编写的东西, 比如脚本, 管理文档等. 这样可以随时退回到之前的操作, 非常方便.</p><p>所以对于任何可以被管理的文件, 尽量把他们应用在源代码管理中</p><h3 id="Debugging-调试"><a href="#Debugging-调试" class="headerlink" title="Debugging 调试"></a>Debugging 调试</h3><p>书中总结了几条调试的规则, 这里简要列出:</p><ol><li>bug复现</li><li>数据可视化</li><li>程序运行追踪</li><li>先假设自己的代码有问题, 再思考第三方代码是否有问题</li><li>不要假设哪些代码是必定正确运行的, 而是去证明它</li><li>在找到代码之后, 反思如何避免它<h3 id="Text-Manipulation-文本操作"><a href="#Text-Manipulation-文本操作" class="headerlink" title="Text Manipulation 文本操作"></a>Text Manipulation 文本操作</h3></li></ol><p>文本操作的一些功能:(以Perl为例)</p><ol><li>建立数据库</li><li>自动方法生成</li><li>测试数据生成</li><li>抽取声明和接口</li><li>生成文档<blockquote><p>Write Code That Writes Code.</p></blockquote></li></ol><p>这句话解释了自动处理的重要性. 建立一个代码生成器是很有必要的, 这里是一些功能:</p><ol><li>创建新的文件, 并应用模版</li><li>执行自动的格式转换操作</li><li>执行预处理操作</li><li>执行给定的同步操作或一致性检查</li><li>手动处理一些源代码中的可变片段(结构体等)<h3 id="Pragmatic-Paranoia-偏执心理"><a href="#Pragmatic-Paranoia-偏执心理" class="headerlink" title="Pragmatic Paranoia 偏执心理"></a>Pragmatic Paranoia 偏执心理</h3></li></ol><blockquote><p>You Can’t Write Perfect Software</p></blockquote><p>这句话也是我感触比较深的, 在写程序的时候当然要追求效率, 但是不要追求完美. 因为完美的程序一般都会花费远远大于预定的时间来开发, 在绝大多数时候我只需要一个简单够用的程序.</p><p><strong>Design by Contract</strong></p><p>这是确保程序在正确性和完美之间的找到平衡的一个方法, 简单来说, 就是在给定条件下, 一个方法能确保结果中的一部分被正确呈现, 而一些模糊的部分会怎么样, 并没有被规定.</p><p>DBC包含三个部分: 调用者必定凑齐的条件, 依照条件返回结果的方法, 和检查条件与结果是否正确的class</p><blockquote><p>Subclasses must be usable through the base class interface without the need for the user to know the difference.</p></blockquote><p>这是继承的一个原则: <strong>继承类必须在调用基类接口的时候表现得和基类一样</strong>, 不然继承的原则就会被破坏, 这里的表现得一样不是指一样的输出, 而是输入范围至少要和基类的范围一样. 也就是说在用户使用继承类的基类接口的时候, 用户可以当做基类来使用而不会产生错误.</p><p>DBC在C++中有预处理器来保证, 如<strong>Nana</strong>, 在JAVA中有<strong>iContrast</strong></p><blockquote><p>With enough components and agents that can negotiate their own contracts among themselves to achieve a goal, we might just solve the software productivity crisis by letting software solve it for us.</p></blockquote><p>有时候面对输入不一样的情况, 并不总是将其当作<strong>错误</strong>, 而对于特殊情况, 依然能返回正确的结果, 那么程序本身在扩展的时候就自动地找出复杂范围的可行方案(例如类型推断)</p><p><strong>crash earlier</strong></p><blockquote><p>when your code discovers that something that was supposed to be impossible just happened, your program is no longer viable.</p></blockquote><p><strong>在程序最开始出错的地方停止</strong>, 一方面是避免后续的报错影响debug思路, 另一方面是避免重要的数据被错误地覆盖.</p><p>另外, 为了尽早检测出错误, 在每一个模块都应当设置<strong>检测运行状态合理性的代码</strong>, 也是为以后的debug留下线索</p><blockquote><p>If It Can’t Happen, Use Assertions to Ensure That It Won’t</p></blockquote><p>很多时候在编程中会默认加上一些条件, 然后根据这些假设编程, 但是<strong>对正确性的检测不能因为主观的假设而偏颇</strong>, 此时使用Assertion来显式表达自己的假设.</p><p>但是要注意, 断言中不能存放任何业务逻辑的代码, 因为断言可能在编译时被关闭.</p><blockquote><p>First, they assume that testing finds all the bugs. Second, the optimists are forgetting that your program runs in a dangerous world.</p></blockquote><p>这是<strong>Assertion不仅用于debug</strong>的原因, 因为断言针对的是所有潜在bug和不正确的输入</p><blockquote><p>For example, if your code tries to open a file for reading and that file does not exist, should an exception be raised?</p></blockquote><p>这就涉及到exception的意义: <strong>exception用在处理设计者意想不到的状况, 不能参与正常的业务逻辑处理</strong></p><p>同时, 大量的异常处理会打乱整个代码的逻辑, 我们在debug的时候用exception<strong>只需要知道大概的范围, 但不需要精确到每一步</strong>,因此抛出异常的也只是一个try块, 最好不要是每一行代码都检测.</p><p>以我之前的经验, 在捕获异常的时候, 最好直接用<strong>方法+功能来定位</strong>, 这样设计者既可以直接找到出错的地方, 也可以知道运行的宏观逻辑.</p><blockquote><p>An error handler is a routine that is called when an error is detected.</p></blockquote><p>可以设计一个专门用来处理异常信息的接口, 便于异常的管理和查找</p><blockquote><p>Finish What You Start</p></blockquote><p>尽量在同一个方法内完成打开和关闭操作, 否则很容易出现多次打开或不正确的打开时机等问题</p><p>也可以利用语言内部的对称性, 将资源的打开关闭放在构造和析构函数里. <strong>用一个类实例作为资源的抽象</strong>, 同样的, 这种方式也能避免在throw exception的时候没有释放资源, 因为资源会随着C++的特性自动释放</p><p><strong>deallocate structure</strong></p><p>书中给了三种方式:</p><ol><li>父结构自行负责子结构资源的分配和释放</li><li>父结构不管子结构, 每个结构独立管理资源的分配和释放</li><li>如果父结构还有子结构的资源, 则拒绝释放.(外部管理)<h3 id="flexible-适应性强的代码"><a href="#flexible-适应性强的代码" class="headerlink" title="flexible 适应性强的代码"></a>flexible 适应性强的代码</h3></li></ol><blockquote><p>A good way to stay flexible is to write less code.</p></blockquote><p>这个建议很简单, 只要不写代码, 就能降低代码的修改难度. <strong>保持代码的简洁性也是增强适应性的一个方式</strong></p><blockquote><p>Rather than digging though a hierarchy yourself, just ask for what you need directly.</p></blockquote><p>在一个类中对另一个类的接口调用<strong>尽量只调用浅层的方法</strong>, 因为如果一连串地调用, 就减少了封装的程度, 增加了耦合度.</p><p><strong>The Law of Demeter for Functions</strong></p><p>任何方法只能调用:</p><ol><li>自身的方法</li><li>传入参数的方法</li><li>方法定义域中生成的实例的方法.<blockquote><p>First, we want to make our systems highly configurable. Not just things such as screen colors and prompt text, but deeply ingrained items such as the choice of algorithms, database products, middleware technology, and user-interface style.</p></blockquote></li></ol><p>从<strong>外部定制</strong>来说, 可定制的远远不止用户的flavor, 更包含开发者的可选项. <strong>用文件来定制被每次都修改源代码更加优美</strong></p><p>可定制的有很多, 比如运行路径, 用户界面, 平台等.</p><blockquote><p>Our goal is to think declaratively (specifying what is to be done, not how) and create highly dynamic and adaptable programs. We do this by adopting a general rule: program for the general case, and put the specifics somewhere else—outside the compiled code base.</p></blockquote><p>这一段写的非常出乎我意料. *<em>我们写出的程序是一次性编译的, 那么就不应该存在特定的目的. *</em></p><p>最理想的状态是用metadata描述程序的功能, 然后整个程序是一个引擎, 对描述进行解析, 并按照预想的方式运行. 这样, 程序的功能部分用人类语言描述出来, 保留了大部分业务逻辑的信息. 然后引擎本身也是高度解耦的, 可以较大程度覆盖可能的业务逻辑.</p><p>在工作场景里, 写一个程序不仅要覆盖给定的需求, 更要在拓展潜在需求上尽量做到健壮, 灵活. 这种写程序的目标是整个可能性的组合, 而不是一个单一的目的.</p><h3 id="workflow-用户的操作空间"><a href="#workflow-用户的操作空间" class="headerlink" title="workflow 用户的操作空间"></a>workflow 用户的操作空间</h3><blockquote><p>It can be eye-opening to see where the dependencies really exist.</p></blockquote><p>workflow用在这种地方: 用户可以执行不同的操作, 但是一些操作需要在另一些操作执行完以后才能执行. 那么如何设计程序? 这就是<strong>用图形表达出用户可能的所有操作, 即一个操作空间</strong></p><p>基于操作空间, 可以设计前端的结构:</p><blockquote><p>In a hungry consumer model, you replace the central scheduler with a number of independent consumer tasks and a centralized work queue.</p></blockquote><p>序列化, 也就是将用户的操作拆分成<strong>去中心化的动作, 然后放在中心化的序列中</strong>, 这种设置比用很多flag表示要有效得多.</p><p>同时, 可以将多个序列进行拆分重组, 进而达到多线程的目的. 上述的workflow检测依赖性, 然后将满足解耦条件的动作从序列中抽出. 也可以合并多个序列, 只要检测能否互相并存即可. 这种情况下, <strong>所有的依赖性都可以通过检测序列来实现</strong></p><h3 id="concurrency-同时性"><a href="#concurrency-同时性" class="headerlink" title="concurrency 同时性"></a>concurrency 同时性</h3><blockquote><p>Because things can now happen at the “same time,” you may suddenly see some time-based dependencies.</p></blockquote><p>多线程并不是”麻烦”的技术, 相反, 多线程给代码设置更高的要求, 让一些低劣的代码不能正常运行, 这促使开发者提高编程水平.</p><h3 id="Publish-Subscribe消息机制"><a href="#Publish-Subscribe消息机制" class="headerlink" title="Publish/Subscribe消息机制"></a>Publish/Subscribe消息机制</h3><blockquote><p>Objects should be able to register to receive only the events they need, and should never be sent events they don’t need.</p></blockquote><p>这个消息通知机制就是cocos2d里用到的机制: <strong>接受者向发送者注册, 然后发送者每回发送的时候, 都向注册了的组件发出通知</strong></p><p>这里我有一些启发: 对于可以通信的东西, 它们交流代码媒介是什么呢? 既然消息是去中心化的, 那么交流一定要有一个共同语言. 而<strong>共同的基类就是组件间交流的语言</strong>, 当组件都有相同的基类的时候, 组件间的交流就可以基于这个语言, 当然也只能限于这个语言.</p><h3 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h3><p><a href="https://baike.baidu.com/item/MVC%E6%A1%86%E6%9E%B6/9241230?fromtitle=MVC%E6%A8%A1%E5%BC%8F&fromid=713147&fr=aladdin" target="_blank" rel="noopener">MVC设计模式</a></p><blockquote><p>separating the model from both the GUI that represents it and the controls that manage the view</p></blockquote><p>这是MVC的设计思想:<strong>数据被封装成一个model, 读取和写入都是单向的</strong>,</p><p>MVC的设计思想不仅用在GUI的设计中, 只要是涉及数据+交互的, 都可以用MVC进行解耦.</p><h3 id="Blackboard-匿名论坛设计模式"><a href="#Blackboard-匿名论坛设计模式" class="headerlink" title="Blackboard 匿名论坛设计模式"></a>Blackboard 匿名论坛设计模式</h3><blockquote><p>A blackboard system lets us decouple our objects from each other completely, providing a forum where knowledge consumers and producers can exchange data anonymously and asynchronously.</p></blockquote><p>黑板设计模式的意义在于<strong>黑板本身仅是一个容器, 而业务逻辑被分散到各个组件中去</strong>, 这是去中心化的. 去中心化有它的好处, 对于非常复杂的规则, 如果编写一个中心化的东西(可以参考桌游的gm), 那么对所有情况进行组合是非常困难的. 但是现实中很多逻辑本身就是去中心化的, 比如人与人的交流活动, 而将去中心化的东西用程序实现, 就涉及到一个”论坛”, 论坛中的讨论者是去中心化的, 但是论坛本身是中心化的, 这样就可以做到组件的充分解耦.</p><p>我也想把这个模式叫做<strong>匿名论坛模式</strong></p><h3 id="Programming-by-Coincidence"><a href="#Programming-by-Coincidence" class="headerlink" title="Programming by Coincidence"></a>Programming by Coincidence</h3><blockquote><p>As developers, we also work in minefields.</p></blockquote><p>要避免coding中的一些潜在问题, 我摘选了几点比较好的建议:</p><ol><li>在运用新技术时一定要先作技术验证, 避免产生歧义.</li><li>不要依赖潜在的东西, 比如语言, 平台, 和测试的特定接口</li><li>在测试的时候, 不仅确保结果正确, 也确保过程和预想的一样.</li><li>不要为了兼容而兼容, 在适当的时候就要果断进行重构<h3 id="optimizing-性能优化"><a href="#optimizing-性能优化" class="headerlink" title="optimizing 性能优化"></a>optimizing 性能优化</h3></li></ol><p>这部分还是关于时间复杂度的, 但是程序整体的性能瓶颈并不一定是算法, 也可能是读写速度, 存储空间等</p><h3 id="refactor-重构"><a href="#refactor-重构" class="headerlink" title="refactor 重构"></a>refactor 重构</h3><p>四个重构的场景:</p><ol><li>代码有重复性(DRY)</li><li>代码耦合度高</li><li>代码中应用的assumption过于陈旧</li><li>有性能瓶颈<blockquote><p>Don’t try to refactor and add functionality at the same time.</p></blockquote></li></ol><p>重构的理念是<strong>小步重构, 大量测试</strong>, 也就是不要在重构的时候无意间改变了原先的业务逻辑.</p><h3 id="test-测试"><a href="#test-测试" class="headerlink" title="test 测试"></a>test 测试</h3><blockquote><p>In C++ you can achieve the same effect (at compile time) by using #ifdef to compile unit test code selectively.</p></blockquote><p>之前有提到说每一个模块都应该带有对自身的测试代码, 那么这些测试代码就可以放在宏定义里面. 当然, <strong>测试的逻辑一定要和业务逻辑的代码解耦</strong></p><blockquote><p>A test harness can handle common operations such as logging status, analyzing output for expected results, and selecting and running the tests.</p></blockquote><p>我认为每个系统的测试都是不一样的, 很难做到同一个测试系统用于不同的代码, 但是在log中对error和warning由专门的分类比直接用string写字符串要好很多.</p><p>我认为一个良好的log应该是包含<strong>可视化, 分级, 折叠, 自动保存信息</strong>等功能, 用不同的颜色输出error和warning, 然后每次输出后都保存到文档中, 以便下次调试时比较. 对于比较复杂的系统, 将次要的输出信息折叠起来, 只保留主要部分.</p><p>但与其对一段不良的代码做许多测试, 还不如<strong>尽量编写没有bug的代码</strong>,通过改良编程习惯, 加深对底层的理解,做到防患于未然</p><blockquote><p>The wizard code is not factored out behind a tidy interface—it is interwoven line by line with functionality that Joe writes.</p></blockquote><p>这里的wizard指的是自动代码生成器, 就像自动类框架生成这种东西. 但是使用的条件是开发者必须完全熟悉wizard生成的代码, 因为这些代码是全面地和开发者的代码混合的.</p><h3 id="The-Requirements-Pit-充分理解需求"><a href="#The-Requirements-Pit-充分理解需求" class="headerlink" title="The Requirements Pit 充分理解需求"></a>The Requirements Pit 充分理解需求</h3><blockquote><p>Requirements rarely lie on the surface. Normally, they’re buried deep beneath layers of assumptions, misconceptions, and politics.</p></blockquote><p>寻找<strong>真正的需求</strong>确实是比较困难的, 有时候难以想象完全整个交互场景, 有时候没有真正拆解需求的组合, 导致设计的框架过于复杂.</p><blockquote><p>It’s important to discover the underlying reason why users do a particular thing, rather than just the way they currently do it.</p></blockquote><p>真正的需求可能连用户自己都不清楚, 因为<strong>一个单一的需求无法决定整个程序框架, 可能的需求和潜在的变动一同组成的需求域才能决定程序哪方面需要flexible</strong></p><p>另一个了解需求的方法是: 假设自己是用户. 也就是站在用户的角度思考自己计划的设计是否足够强大, 且足够方便.</p><blockquote><p>Don’t be a slave to any notation; use whatever method best communicates the requirements with your audience.</p></blockquote><p>在理解并记录需求的时候需要的是最符合业务逻辑的语言, <strong>业务逻辑的语言并不局限于任何一种图表或记号</strong></p><h3 id="Maintain-a-Glossary-制作术语表"><a href="#Maintain-a-Glossary-制作术语表" class="headerlink" title="Maintain a Glossary 制作术语表"></a>Maintain a Glossary 制作术语表</h3><p>这也是一个<strong>标准化</strong>的东西, 对文档中的描述给定一个准确的定义, 当然这主要用在大型项目中. 从共同的语言中特异化一些东西来描述业务逻辑, 可以说是一种”业务语言”</p><h3 id="while-in-coding"><a href="#while-in-coding" class="headerlink" title="while in coding"></a>while in coding</h3><p>这一节实际上是之前的小节的汇总, 包含一些我觉得很有用的观点.</p><ol><li>在开始项目之前做技术验证和原型建模</li><li>在开始项目之前先扫除直觉上的担忧</li><li>不要写太多太详细的技术文档, 要拥有较强的灵活性<blockquote><p>Often, it is only during coding that certain options become apparent.</p></blockquote></li></ol><p>我也有类似的经验, 写着写着才发现有的地方可以用很巧妙的方式实现, 或者以另一个方式拓展. 但是否要遵循这种方向? 我觉得应该要看这个拓展性是不是符合项目需求或潜在需求的.</p><blockquote><p>Never underestimate the cost of adopting new tools and methods.</p></blockquote><p>这是建议不要在正式项目中<strong>过多使用不熟悉的技术</strong>, 同样地, 框架设计应该在满足需求的同时尽可能简洁, 而不是在没有必要的地方留下拓展接口.</p><blockquote><p>Test Early. Test Often. Test Automatically.</p></blockquote><p>在集成化测试前作单元测试是很有必要的, 因为越是复杂的不可靠系统越难找到真正的bug, 最好在每次build时都自动地进行测试</p><h3 id="comments-注释"><a href="#comments-注释" class="headerlink" title="comments 注释"></a>comments 注释</h3><blockquote><p>In general, comments should discuss why something is done, its purpose and its goal.</p></blockquote><p>注释是另一个维度的东西, 注释补全了代码中人的意图和业务逻辑, <strong>注释和代码是互补的, 是高层次的逻辑抽象, 而不是代码的翻译</strong></p><p>与doxygen相反地, 可以把<strong>设计文档的一部分通过自动生成器同步到代码注释中去</strong>, 也可以将代码注释和技术文档各自独立, 并单向集成到API Reference中</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>读完真是身心俱疲…</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>编程思想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程设开发总结</title>
    <link href="/2020/07/24/%E7%A8%8B%E8%AE%BE%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <url>/2020/07/24/%E7%A8%8B%E8%AE%BE%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="2020年7月程设开发总结"><a href="#2020年7月程设开发总结" class="headerlink" title="2020年7月程设开发总结"></a>2020年7月程设开发总结</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今年6月上旬到七月初的这二十多天大概是我人生中第一次写一个3K-5K量级的项目, 从第一天对游戏引擎完全不了解, 到自己用一下午去设计一个UI界面, 甚至去分析飞船的结构特点, 最终用稍微超过预期的时间完成了一个勉强满意的”模具”, 虽然离理想中的游戏差距很多, 但是提供了一个可以完善的平台, 让我有信心继续做下去. 中间着实有不少困难, 甚至让最初企划时的兴奋感都消散殆尽, 但是能做出一个能代表自己风格的作品, 确实是一件有意义的事, 甚至可以说没有什么比自我实现这种事更有意义了.</p><p>当然, 在这种量级的开发中, 尽管已经提前设想过一些解决方案, 但还是遇到了意料之外的情况. 设计的理念也有待改进. 这篇文章就是总结这些琐碎的东西的.</p><h3 id="健壮性和复杂性-应当考虑不变的是什么-而不是可变的是什么"><a href="#健壮性和复杂性-应当考虑不变的是什么-而不是可变的是什么" class="headerlink" title="健壮性和复杂性: 应当考虑不变的是什么, 而不是可变的是什么."></a>健壮性和复杂性: 应当考虑不变的是什么, 而不是可变的是什么.</h3><p>在写这个游戏的最开始, 我的构想还不是很成熟, 于是最初的目标就是: 尽可能保证底层设计的健壮性, 这样以后再变动设计时就能尽量减小重构次数. 依照这个方案, 前期对底层的处理确实比较模块化, 同时避免了后面的许多问题. 但是这样也使得整个设计非常复杂, 在处理<strong>类的相互包含问题</strong>的时候, 我之前设计的复杂的相互引用机制让debug变得异常困难. 如果舍弃这个机制, 整个底层都要重构, 好在最后尽量避免了相互引用, 然后<strong>把独立的方法集成到一个工具类中</strong>, 这样就确定了一个不循环的结构关系, 当然<strong>如何设计一个自顶而下又可以互相通信的机制</strong>也是我没考虑过的问题. 所以这里我先提出一点想法:</p><p><strong>在设计的时候先考虑哪些需求是不会改变的, 再以此设计一个最精简的系统</strong></p><p>就例如游戏中的各个scene, 整个游戏流程只需要提供一个实例, 那么scene只需要一个静态成员存放instance就可以了, 然后用getInstance()方法, 完全可以避免成员需要拿指针的问题. DataLoader也是, 同一时间只能加载一个存放的内容, 不同存档不需要交换信息, 而且DataLoader的类型也是确定的: 加载游戏配置数据和玩家存档里的数据, 这样就只要设定两个静态成员就可以了.</p><h3 id="对内部细节的封装"><a href="#对内部细节的封装" class="headerlink" title="对内部细节的封装"></a>对内部细节的封装</h3><p>一开始我对飞机的定义很不明确, 武器是否可更换? 飞机是否可更换? 飞机型号是否有特殊技能? 是否有特定的增益? 但在设计的时候应该始终把飞机看作一个”黑箱”, 对战斗scene来说, 只要能获取飞机的位置/血量等数据就可以, 而不需要关注内部的东西, 同样整个level生产的也无外乎飞机/子弹/掉落物/特效等, 设计的时候就设计几个基类供level调用即可.</p><h3 id="代码的可维护性"><a href="#代码的可维护性" class="headerlink" title="代码的可维护性"></a>代码的可维护性</h3><p>写到后面的时候时常会犯一些低级错误: 重载函数写错了参数列表, if语句中==少打了一个=, 还有各种约定的规则没有被遵守. coding的过程也是<strong>不断制定规则的过程</strong>, 但是这些规则在编写的时候制定下来, 又如何保证一定能被遵守呢? <strong>任何程序员自行编写的规则都尽量要做到强制被遵守</strong>, 例如两个函数调用前后的顺序, 就用isLoaded来检测, 在没有遵守的时候抛出异常, 又如Reflection这个类的机制, 这是个反例, 所有的飞机都需要在创建的时候手动向反射表注册, 这样并不符合上面所说的理念. 这个改进的方案还没想好(也许没有?), 但是像这种规则即使不能避免, 也要及时整理在技术文档里.</p><p>save里的数据也缺乏维护性, 这是因为最初的时候对<strong>飞机/子弹的实例和模版概念没有分清</strong>导致的, 按理说save里只能存放实例, 也就是一些具有特异性的东西, 但是<strong>属性本身就是有变和不变两个性质的</strong>, 属性的数量/类别/作用都是不变的, 但属性的数值却是可变的, 所以一个武器的属性表就应该同时存放在gameData和save里, 同时这里实例的概念是什么? 是拥有相同属性, 相同的类模版, 但属性数值可以不同的一些飞船. 一个实例并不代表游戏里的一个飞船, 事实上<strong>实例本身仅有数值特意化的功能, 实际生成的数量是由程序控制的, 每个游戏内实体的区分也仅靠内存地址的不同</strong>, storage里存放的实例都是不同的, 因为给玩家相同参数的东西没有意义, 所以每个物品对应一个实例, 但level里的实例是可复用的, 因为生成的飞机基本都是一样的外观, 方便动态控制生成的数量. 这也限制了按照实例查找个体的范围, 这个范围是不能包括可复用实例的区域的.</p><p>像这种唯一性的确定规则, 应当在设计的时候就想好. 后期更改会带来很大的麻烦</p><h3 id="开发进度的可视化-amp-迭代开发"><a href="#开发进度的可视化-amp-迭代开发" class="headerlink" title="开发进度的可视化&amp;迭代开发"></a>开发进度的可视化&amp;迭代开发</h3><p>整个开发过程最艰难的大概就是做UI和写行星生成器的时候, 这里我的开发流程并不合理, 首先行星生成器我花了3天时间研究, 但是结果上这一个东西因为性能原因不能产生大面积的可动背景, 而这三天里, 我并没有做任何推动开发进度的东西, 导致写完以后一度丧失了进行下去的信心. <strong>对一个独立开发者而言, 如何规定开发计划, 让整个开发进度可视化, 并得到充分的反馈, 是开发能否进行下去的关键</strong>, 在做行星生成器的时候, 我把整个游戏背景设计/UI设计完全押注在这一个技术的实现上, 然而这种是很危险的. 对一个最精简框架所必须的UI, 背景图片而言, 他们虽然要遵循一个统一的视觉形象, 但是不能依赖一个未知能否实现的技术.</p><p>在规划的时候也应该从最精简的框架入手, 先<strong>搭建出一个能用的东西, 再去思考怎样让它变得更好</strong>. 过度追求完美是很危险的, 就像我在写行星生成器的时候, 过度想让它完美呈现, 却因此破坏了整个游戏的开发进程, 也破坏了迭代开发的原则. 以后的设计中要避免各个技术的相互耦合, 对于难度高的技术, 尽量先写一个可用的版本, 再去完善它.</p><h3 id="文档规范化-amp-注释规范化"><a href="#文档规范化-amp-注释规范化" class="headerlink" title="文档规范化&amp;注释规范化"></a>文档规范化&amp;注释规范化</h3><p>这次没有用doxygen生成文档, 虽然写了许多注释, 但回看的时候效果都很差: <strong>太少注释让人无法理解运行原理, 太多注释让人花费大量的时间在浏览无用信息上</strong>, 后期修改一个源文件的时候, 经常在十几个方法里面寻找, 但是在中途就忘记了自己要找什么东西. 同时满足注释的详细程度和检索遍历程度, 听起来是矛盾的, 但其实也有方法: <strong>一些注释是只需要全局检索的, 例如TODO, 那么只要有可检索的关键字就行了</strong>, 而需要让人了解”这个方法是干什么的”这些注释, 不能写得太过琐碎, 最好写出<strong>一整块注释, 大致说明代码的功能, 需要特别注意的地方在所在行添加注释</strong>, 这样就不必在繁多的注释行中不断阅读.</p><p>doxygen也是比较方便的, 但是我还没有关注过注释的可维护性, 在对程序进行修改的时候, 注释很难进行同步修改, 这也是我写大量功能性注释的弊端:<strong>注释太多反而加大了修改的工作量, 也增添了额外的规则</strong>, 而最好是在一段代码通过稳定测试以后再写一个总结性质的注释.</p><h3 id="过程中的奇异bug们与一些零碎经验"><a href="#过程中的奇异bug们与一些零碎经验" class="headerlink" title="过程中的奇异bug们与一些零碎经验"></a>过程中的奇异bug们与一些零碎经验</h3><p>开发过程中也遇上了一些奇怪的bug:</p><ol><li><p>枚举的size{small,medium,large}中的small与cocos2d命名空间的一个宏定义重名(所以<strong>一般在cpp里用using namespace而不要在头文件里用</strong>)</p></li><li><p>设置rotation后再设置anchorPoint总是显示错位, 后来发现是因为旋转后锚点的位置也会在坐标系中改变</p></li><li><p>提示nullptr, 是因为垃圾自动回收机制导致的</p></li><li><p>用removeChildByName的时候, 对参数理解不到位, 导致后来一些奇奇怪怪的报错(以后要多看reference)<br>也有一些零碎的东西需要改进</p></li><li><p>cocos2d::ui这个命名空间太长了, 最好用 <code>namespace vlns = very::long::namespace</code> 削短</p></li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
      <category>游戏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏开发</tag>
      
      <tag>cocos2d</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020SummerGame：美工设计笔记</title>
    <link href="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="2020SummerGame：美工设计笔记"><a href="#2020SummerGame：美工设计笔记" class="headerlink" title="2020SummerGame：美工设计笔记"></a>2020SummerGame：美工设计笔记</h1><h2 id="美工设计笔记——飞船设计P"><a href="#美工设计笔记——飞船设计P" class="headerlink" title="美工设计笔记——飞船设计P"></a>美工设计笔记——飞船设计P</h2><p>因为假期时间很充裕，这次游戏的美工打算自己画，也是积累一些美术方面的经验。整个学习过程就是：观看优秀的美工设计-总结各自的优缺点和风格特异性-尝试转移到自己的设计上。而关于理论方面，我打算先自己看完优秀案例再学习理论基础，以便能随时与实践联系起来。</p><p>初步来说，整体的美工设计包括飞船设计、武器设计、子弹/激光等特效设计，爆炸效果设计，游戏背景设计，UI设计，宝石设计。当然整体的风格要统一。</p><h3 id="Star-sector飞船拆解：涂装、外壳纹理、外壳结构、内部器件、功能模块"><a href="#Star-sector飞船拆解：涂装、外壳纹理、外壳结构、内部器件、功能模块" class="headerlink" title="Star sector飞船拆解：涂装、外壳纹理、外壳结构、内部器件、功能模块"></a>Star sector飞船拆解：涂装、外壳纹理、外壳结构、内部器件、功能模块</h3><p>Star sector的飞船设计很明显的特点就是：各方阵容特色鲜明，整体造型统一，同时与UI搭配和谐。整体拆解如上所说，但是部分结构还是需要细分：首先关注一下打光，star sector的飞船打光大都是<strong>从上向下的点光源或线光源</strong>，打光区分<strong>球面</strong>和<strong>圆盘</strong>，同时根据反光度的不同，区分<strong>外壳</strong>和内部<strong>器件</strong>，同时根据光和阴影的分布，可以将飞船的曲面表示出来，许多飞船<strong>中间亮两边暗</strong>，整体呈现半球形的曲面分布。</p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/b9a5e2688026aea33132a83487f68bbb.png" srcset="/img/loading.gif" class=""><p>（打光下的球体，注意两个小球的光点并不在中间，这种对应的物理结构我还没搞清楚）</p><p>不同阵营的涂装、外壳结构、外壳纹理是不同的。<strong>外壳覆盖范围</strong>有全覆盖型（看起来很坚固，但是速度缓慢）、半覆盖型、贴边覆盖型（只有贴边的平行装甲，中间部分都是露出的）、无覆盖型（找不到光滑面，都是内部器件）。按照<strong>对称性</strong>划分可以有对称型和不规则型，其中不规则型大多采用圆滑设计，来保持整体美观。同样，根据势力范围不同，飞船的<strong>基本图案</strong>也是不同的，分为以平行四边形为基础和以圆形为基础。但是，在各个阵营的飞船中也能找到共同的东西，比如<strong>统一为白色的舰桥</strong>：</p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/71532e57a67ac4f036ba59f9177281ef.png" srcset="/img/loading.gif" class=""><p>当外壳结构确定好后，外壳纹理起到细化的作用。<strong>拼装式外壳纹理</strong>经常在以圆形为基础的飞船上看见，此时飞船表面像是被设计好的几块外壳拼装出来一样：</p><p><strong>搭建式外壳纹理</strong>在以平行四边形为基础的飞船上看见，此时飞船表面各部件有实际的层次。这是因为拼装出的类似球状在光的渲染下比较好看，而如果平行四边形采用拼装式，那么只能得到一块平面，如果平行四边形在3维空间采用曲面设计的话，就其二维特征不统一了，反而会破坏飞船的美感。</p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/6a8b6a51709adf96539ca7cf85bc9ecf.png" srcset="/img/loading.gif" class=""><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/1e18c10bef9b8a3e85fc039c0db29d29.png" srcset="/img/loading.gif" class=""><p>再来看下涂装，starsector飞船有涂装的很少，但是涂装能大大改善单个机体的外观确是无疑的。涂装分为两种：<strong>线型涂装</strong>主要沿机体方向勾勒出一条或几条线，它能直接把繁复的装甲结构统一成一个整体，由涂装飞船获得了精细与整体性的平衡。而<strong>面型涂装</strong>主要是有装饰作用，所有外壳刷上统一色系的涂装会强烈凸显出外壳与内部器件的对比感。另外，当飞船装甲过大时，合理利用涂装以显示分区可以让整体更加醒目</p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/27a23ea4f02a4091df97886fb83ac69d.png" srcset="/img/loading.gif" class=""><p>此外，海盗在其他势力的制式飞船上加涂装更能彰显其个性——这也是其他制式飞船很少画涂装的原因。</p><p>飞船的功能结构与其游戏内容是契合的，这里发现的<strong>功能结构</strong>有武器（机枪、激光）、机库、舰桥（航母有大舰桥，小飞机有小的舰桥）、引擎周围的导热管、货仓、存储罐、舷窗（有黄色亮光）、飞机指示灯（在机翼边缘）、反应装甲（这是从坦克上借鉴的）</p><p>飞船的“内部器件”是具有重要功能的模块，颜色一般以灰色、深灰色为主，内容主要是<strong>平行的管线</strong>、<strong>类似集成电路的设计</strong>，内部器件被故意设计成繁复的，一是为了凸显<strong>飞船的真实性</strong>，比如引擎给人的印象就是复杂，这种设计能突出引擎特征，二是与相对简单的装甲形成<strong>强烈对比</strong>，增添飞船层次性，让整个设计错落有致。在外壳周围的一些暗部设计很好地起到了<strong>装饰边缘</strong>的作用。</p><p>综合起来，starsector的飞船设计理念可以总结为：统一性、多样性、对称性、层次性、功能性、阵营风格各异。当然缺点也存在：大多数飞船缺乏涂装，内部器件和外部装甲的比例不协调，而且外部装甲的装饰太过复杂，导致整体看起来过于零碎没有统一感。大多数飞船色彩搭配并不鲜艳（虽然在鲜艳和真实感之间取得平衡时很困难的事），但有少数飞船结合优秀的曲面设计和对称性设计，虽然不鲜艳但是给人以强烈的美感。</p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/45f6a4319921dbfa4e24a680da4bd785.png" srcset="/img/loading.gif" class=""><h3 id="其他设计飞船拆解：案例与优劣分析"><a href="#其他设计飞船拆解：案例与优劣分析" class="headerlink" title="其他设计飞船拆解：案例与优劣分析"></a>其他设计飞船拆解：案例与优劣分析</h3><p><strong>一种相对小巧的飞船</strong></p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/5507559d4c9368d20e2751def388db6d.png" srcset="/img/loading.gif" class=""><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/cc2b75a5c6cba835fe489d3fa0ff4838.png" srcset="/img/loading.gif" class=""><p>优势：P2的颜色设计非常值得借鉴，灯光将机体的<strong>边缘</strong>映照出相同的颜色，白色作为<strong>连通颜色</strong>连接不同的区域，让足足5种颜色和谐地融汇在一起。P1和P2装甲的非发光部分做了做旧处理，增加了阴影，整体摆脱了平面化。</p><p>劣势：虽然有阴影，但是整体的光源并不清晰，也可能是平面光，让飞船的立体感不强烈。同时缺少作为复杂性点缀的内部器件，导致颜色的整体对比度也不强烈，缺少现实感。</p><p><strong>使用偏置光源的立体式飞船</strong></p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/664050ac456f11d91ec7984f15295521.png" srcset="/img/loading.gif" class=""><p>评价：这个飞船使用的是偏置光源，同时注意飞船的结构是三维立体式结构，这种结构的劣势在于：它<strong>过于写实</strong>，从而与低像素的画风形成不统一。3维飞船的直接映射需要强烈的立体支撑感，包括高清晰度、光源的正确照射，甚至要求必须在三维背景下完成，而这种设定对一个2D游戏是不可接受的。另外，因为3维飞船的真实性，许多2D用到的技巧都不可行，比如在飞船周围增加武器零件以丰富颜色对比度，这使得飞船的观感更差。</p><p><strong>配色出彩的一组飞船</strong></p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/3eb22e6231fbd04cd1e92be577aca4d4.png" srcset="/img/loading.gif" class=""><p>评价：这组飞船的最大特点就是配色非常舒服，每个飞船大致有3种主要颜色：一种主颜色和两种辅助色，主颜色又包含偏暗的阴影颜色。辅助色用于驾驶舱、灯光等点缀。</p><p><strong>造型和涂装都富有特色的飞船</strong></p><img src="/2020/07/24/2020SummerGame%EF%BC%9A%E7%BE%8E%E5%B7%A5%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/1c8b396ab142f8ffae13f9053b1fd71f.png" srcset="/img/loading.gif" class=""><p>评价：这个飞船的造型很好看，整体呈现一个三角形，明显的轴对称结构，中间紧实两侧舒展，越靠近中间处颜色越浅，两侧占面积比较大的区域用深灰色，这样让整个飞机中心突出。同时在深灰色区域也都加上装甲设计，略微摆脱廉价感。但不足的是，没有强烈的阴影对照，整体的立体感欠缺很多。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>人权的边界线——底层人民的经济困境与生育权利</title>
    <link href="/2020/07/24/%E4%BA%BA%E6%9D%83%E7%9A%84%E8%BE%B9%E7%95%8C%E7%BA%BF%E2%80%94%E2%80%94%E5%BA%95%E5%B1%82%E4%BA%BA%E6%B0%91%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%9B%B0%E5%A2%83%E4%B8%8E%E7%94%9F%E8%82%B2%E6%9D%83%E5%88%A9/"/>
    <url>/2020/07/24/%E4%BA%BA%E6%9D%83%E7%9A%84%E8%BE%B9%E7%95%8C%E7%BA%BF%E2%80%94%E2%80%94%E5%BA%95%E5%B1%82%E4%BA%BA%E6%B0%91%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%9B%B0%E5%A2%83%E4%B8%8E%E7%94%9F%E8%82%B2%E6%9D%83%E5%88%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="人权的边界线——底层人民的经济困境与生育权利"><a href="#人权的边界线——底层人民的经济困境与生育权利" class="headerlink" title="人权的边界线——底层人民的经济困境与生育权利"></a>人权的边界线——底层人民的经济困境与生育权利</h1><blockquote><p>2020年5月29日广西河池，都安县保安乡上镇村弄邓，一对90后夫妻目前生育有9个孩子，分别有3个女儿6个儿子，最大的孩子12岁在读4年级，还有1个再有3个月也会降生。男子平时外出在工地打工赚钱养家，家里种有玉米自己吃。男子表示有在家产子的经历，都是老妈在帮忙。这对夫妻对未来充满希望，表示会慢慢打工为所有的孩子赚足学费。</p></blockquote><p>将每个家庭的财产与生育率作一幅图，生育率的图像呈现哑铃形：最低处是中产家庭，两边是富裕家庭和底层家庭。富裕家庭为了确保自己的产业有继承者，往往会生育不只一个孩子；底层人民则是在买“生产力”，一般来说，一个男孩成年后打工或者务农，总能挣到超过他抚养费用的生活费，加上政府给的低保费用，一户贫穷人家由此重获新生，如果中了“生育彩票”，培养出有正经工作的孩子，那么这户人家就很大可能在接下来的几十年内摆脱贫困，所有兄弟姐妹都可以过上好日子。</p><p>但我看到这个理论的时候，总是对其有很深的抵触，思考许久，我的疑惑是：人的权利，到底是谁在维护谁的权利？</p><hr><p><strong>消灭苦难有两种方式，要么改善现状，要么消灭幸福</strong></p><p>人们总是认为贫穷是单纯的，就像是缺水、缺粮一样，忍忍就过去了。但贫穷有着独特的吸引力：它将开阔的变成狭隘的、将公平变成嫉妒、将善良变成丑恶。就像是千千万万贪欲“幸福”的困苦家庭一样，这户人家选择在贫困中创造一个又一个生命。忍受着常年的物质匮乏，接受远远落后于他们求知欲的教育，长大则背负十一份责任，曾经的兄弟姐妹都化作工厂里大汗淋漓时承受的压力，如此一日又一日，一年又一年，年老力衰时回到那个抚育自己的村落，又有了数倍于自己一辈的孩子们，十人养一人，百人养十人，这一循环不会轻易打破，因为每个人都心知肚明：如果不再让新的生命献祭给“贫穷”，那么他们自身就会被献祭——无劳动能力者没有活下去的权利。</p><p>在大一返乡时，我在动荡的火车厢里翻阅着何夕的《大饥之年》，“大饥之年，人易子而食。”那天的夜里没有星星，空气中混合着人们的谈论声，这几百上千人融洽地待在狭小的车厢中，一定程度上缓解了我的恐惧感。当时我应该想到，几百公里之外的广西，那是另一种的易子而食，人出生即被预支出劳动力，永远看不到理想，永远看不到自由，我们为何不将其视为家畜呢？当然，他们是幸福的，因为在满是苦难的土壤里根本不存在幸福的种子，活在相对性里的人们，将隆起的高山看作地之柱，将奔流而下的瀑布视为天之泉。</p><p>存在者才有权利，存在者构建的法律，保障的是存在者的权利。时间是它们忠实的卫士，试图违背人类本性的反叛者都在短短百年内被不留痕迹地抹去。在过去几千年的历史中，人类的一部分当然也尝试过改写这一法律，但最后，往往只有存在者的法律获得了最多的拥护，婴儿出生后即受法律保护，因为任何谋杀的手段都让现存于世的人们感到自身的存在受到威胁。未存在于世的“人”会如何感想呢？谁也不管这个。但奇怪的是，我竟然认为人在诞生之前就是被保护的，就像是对废纸篓怜悯每一丝纤维一样无意义。</p><hr><p><strong>相对性与生存策略</strong></p><p>若是作一个审判者，以绝对自洽的法律判断对错，我找不到这样的标准。我现在如此怜悯贫困中的孩子，也有千百年后生活在物质无限充足的社会中，那些怜悯着我的人类。我的生活是如我认为的那般幸福，还是说我也同那些孩子一样，只在苦难中存在？道德与正义建立在相对性之上，人们如同一个个观察者，在不同的时间、不同的地位上去看待一件事，谁是“真理”呢？历史已经写下了答案，真理并不存在于世界上，有的只是无穷无尽的斗争与反斗争，支配与反支配。</p><p>人是有会创造文化认同的社会性动物，它们是图腾。如果将人类看作一个整体，它的进化无疑是令人惊叹的：人类在无数的个体竞争中进行自我迭代，又在多变的历史环境下不断异化。贫穷的人不再遵循自然法则，他们的法则是金钱的法则、法律的法则。活在资本主义“世界”的人们开始了自己的异化：泯灭自由意志、吃苦耐劳、容易满足、永远乐观。基因里强大的适应能力给了人类无穷无尽的生存动力，他们从泥土里挖掘草根，在时间域里开拓近似无穷尽的生产力工具——他们自己是工具，工具也是自己。局外人用自己的图腾去衡量异教徒，注定是毫无意义的。</p><p>正如尼采所说：上帝已死。</p><p>不到二十年时间，我也不例外地找到了自己的生存方式。可我不能再论证人类超越动物性的“道德”与“正义”了，唯物者的视角被笼上一层阴影，当然，总有毫无阴霾的唯物者们信仰这一图腾。过去的时间里我为了是否接受人性的异化而犹豫着，最终选择了规则，但也留存一些大义的理想，其实是欲望的延伸，来自于幼小时记忆中不知名的角落。当然了，理想是相对的，手段是唯一的。理性视角下的我无须为自己的规则与外界格格不入而懊恼，但依然需要进行庞大的知识整理使得理论自洽。想想生活在相对论宇宙中的人类吧，地球以每秒29.8千米的速度绕太阳公转，太阳也以一个速度绕银河系公转，银河系与仙女系在几亿年后交融在一起……但博尔特的短跑记录是百米9秒58。相对性下的人类世界依然是可以被构建的。</p><p>自由意志，那是更深层的本源，人顺应异化本能地活着，与在自由意志的控制下活着，究竟是否为同一个事物呢？让我发笑的是，我的理想是试图用前者的方法构建后者的世界。这大概是互相矛盾的吧，但如果两者能统一的话，就没有任何问题了。</p><hr><p><strong>后记</strong></p><p>这篇文章写在假期的深夜，尽管已经过了凌晨一点，但我还是毫无睡意，有时候也为了自身的存在迷茫过，在思考很久以后，得到了这篇答案。无意义吗？意义是不存在的，每个人创建自己的图腾，然后按照规则行事。</p>]]></content>
    
    
    <categories>
      
      <category>经济</category>
      
    </categories>
    
    
    <tags>
      
      <tag>时政分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
